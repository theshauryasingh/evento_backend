"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranspileWebpackPlugin = void 0;
const node_os_1 = __importDefault(require("node:os"));
const node_path_1 = __importDefault(require("node:path"));
const node_util_1 = require("node:util");
const lodash_1 = require("lodash");
const schema_utils_1 = require("schema-utils");
const commonDir_1 = require("./commonDir");
const compilerOptions_1 = require("./compilerOptions");
const conditionTest_1 = require("./conditionTest");
const constants_1 = require("./constants");
const optionsSchema_json_1 = __importDefault(require("./optionsSchema.json"));
const webpack_1 = require("./peers/webpack");
const ModuleProfile_1 = __importDefault(require("./peers/webpack/lib/ModuleProfile"));
const SourceMapDevToolPluginController_1 = require("./SourceMapDevToolPluginController");
const TerserWebpackPluginController_1 = require("./TerserWebpackPluginController");
const TranspileExternalModule_1 = require("./TranspileExternalModule");
const walkDependencies_1 = require("./walkDependencies");
const { RawSource } = webpack_1.sources;
class TranspileWebpackPlugin {
    constructor(options = {}) {
        var _a, _b, _c, _d;
        (0, schema_utils_1.validate)(optionsSchema_json_1.default, options, {
            name: constants_1.pluginName,
            baseDataPath: 'options',
        });
        this.options = Object.assign(Object.assign({}, options), { exclude: (_a = options.exclude) !== null && _a !== void 0 ? _a : [], hoistNodeModules: (_b = options.hoistNodeModules) !== null && _b !== void 0 ? _b : true, extentionMapping: (_c = options.extentionMapping) !== null && _c !== void 0 ? _c : {}, preferResolveByDependencyAsCjs: (_d = options.preferResolveByDependencyAsCjs) !== null && _d !== void 0 ? _d : true });
        this.sourceMapDevToolPluginController = new SourceMapDevToolPluginController_1.SourceMapDevToolPluginController();
        this.terserWebpackPluginController = new TerserWebpackPluginController_1.TerserWebpackPluginController();
    }
    apply(compiler) {
        const { exclude, hoistNodeModules, longestCommonDir, extentionMapping, preferResolveByDependencyAsCjs, } = this.options;
        (0, compilerOptions_1.forceDisableSplitChunks)(compiler.options);
        (0, compilerOptions_1.forceSetLibraryType)(compiler.options, constants_1.outputLibraryTypeCjs);
        (0, compilerOptions_1.forceDisableOutputModule)(compiler.options);
        const isPathExcluded = (0, conditionTest_1.createConditionTest)(exclude);
        const isPathInNodeModules = (0, conditionTest_1.createConditionTest)(constants_1.reNodeModules);
        const isPathMjsFile = (0, conditionTest_1.createConditionTest)(constants_1.reMjsFile);
        this.sourceMapDevToolPluginController.apply(compiler);
        this.terserWebpackPluginController.apply(compiler);
        compiler.hooks.environment.tap({ name: constants_1.pluginName, stage: constants_1.hookStageVeryEarly }, () => {
            (0, compilerOptions_1.throwErrIfOutputPathNotSpecified)(compiler.options);
            (0, compilerOptions_1.throwErrIfHotModuleReplacementEnabled)(compiler.options);
            if ((0, compilerOptions_1.isTargetNodeCompatible)(compiler.options.target)) {
                (0, compilerOptions_1.enableBuiltinNodeGlobalsByDefault)(compiler.options);
            }
            if (preferResolveByDependencyAsCjs) {
                (0, compilerOptions_1.alignResolveByDependency)(compiler.options, constants_1.resolveByDependencyTypeCjs);
            }
        });
        compiler.hooks.finishMake.tapPromise(constants_1.pluginName, (compilation) => __awaiter(this, void 0, void 0, function* () {
            // Only evaluates new entries in the main compilation.
            if (compilation.compiler !== compiler)
                return;
            const outputPath = compiler.options.output.path;
            const outputPathOfNodeModules = node_path_1.default.resolve(outputPath, constants_1.baseNodeModules);
            const context = compiler.options.context;
            const entryDeps = new Map();
            const touchedMods = new Set();
            for (const e of compilation.entries.values()) {
                for (const d of e.dependencies) {
                    collectEntryDepsRecursively(d);
                }
            }
            touchedMods.clear();
            const entryResourcePaths = Array.from(entryDeps.keys());
            const entryResourcePathsWoNodeModules = entryResourcePaths.filter((p) => !isPathInNodeModules(p));
            if (entryResourcePathsWoNodeModules.length === 0) {
                throw new Error(`${constants_1.pluginName}${node_os_1.default.EOL}No entry is found outside 'node_modules'`);
            }
            if ((0, compilerOptions_1.isTargetNodeCompatible)(compiler.options.target)) {
                const entryResourceMjsFiles = entryResourcePaths.filter(isPathMjsFile);
                if (entryResourceMjsFiles.length > 0) {
                    const warning = new webpack_1.WebpackError(`${constants_1.pluginName}${node_os_1.default.EOL}Might be problematic to run '.mjs' files with target 'node'. Found '.mjs' files:${node_os_1.default.EOL}` +
                        entryResourceMjsFiles
                            .map((p) => `  .${node_path_1.default.sep}${node_path_1.default.relative(context, p)}`)
                            .join(node_os_1.default.EOL));
                    compilation.warnings.push(warning);
                }
            }
            const commonDir = (0, commonDir_1.commonDirSync)(entryResourcePaths, {
                context,
                longestCommonDir,
            });
            const commonDirWoNodeModules = (0, commonDir_1.commonDirSync)(entryResourcePathsWoNodeModules, {
                context,
                longestCommonDir,
            });
            for (const entryDep of entryDeps.values()) {
                yield makeExtDepsRecursively(entryDep);
            }
            touchedMods.clear();
            const entries = new Map();
            const entryExtentionsToHaveSourceMaps = new Set();
            makeEntriesAndCollectEntryExtentions();
            entryDeps.clear();
            this.sourceMapDevToolPluginController.setExtensionsToHaveSourceMaps(entryExtentionsToHaveSourceMaps);
            entryExtentionsToHaveSourceMaps.clear();
            this.terserWebpackPluginController.setNamesToBeMinimized(entries.keys());
            compilation.entries.clear();
            compilation.entries = entries;
            /* **** */
            function collectEntryDepsRecursively(entryDep) {
                var _a;
                const entryMod = compilation.moduleGraph.getModule(entryDep);
                if (!entryMod || touchedMods.has(entryMod))
                    return;
                if (entryMod instanceof webpack_1.NormalModule) {
                    const isEntryResourceLocalFile = node_path_1.default.isAbsolute(entryMod.resource);
                    const entryResourcePath = (_a = entryMod.resourceResolveData) === null || _a === void 0 ? void 0 : _a.path;
                    if (isEntryResourceLocalFile &&
                        typeof entryResourcePath === 'string' &&
                        !isPathExcluded(entryResourcePath)) {
                        // Collects the dependency closest to root as the entry dependency.
                        if (!entryDeps.has(entryResourcePath)) {
                            entryDeps.set(entryResourcePath, entryDep);
                        }
                    }
                }
                touchedMods.add(entryMod);
                (0, walkDependencies_1.walkDependenciesSync)(entryMod, collectEntryDepsRecursively);
            }
            function makeExtDepsRecursively(entryDep) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    const entryMod = compilation.moduleGraph.getModule(entryDep);
                    if (!entryMod || touchedMods.has(entryMod))
                        return;
                    let isEntryModExcluded = false;
                    if (entryMod instanceof webpack_1.NormalModule) {
                        const entryResourcePath = (_a = entryMod.resourceResolveData) === null || _a === void 0 ? void 0 : _a.path;
                        isEntryModExcluded =
                            typeof entryResourcePath !== 'string' ||
                                !entryResourcePaths.includes(entryResourcePath);
                    }
                    if (isEntryModExcluded)
                        return;
                    const allDependencies = new Set(entryMod.dependencies);
                    for (const b of entryMod.blocks) {
                        for (const d of b.dependencies) {
                            allDependencies.add(d);
                        }
                    }
                    yield (0, walkDependencies_1.walkDependencies)(entryMod, (d, i, deps) => makeExtDepToReplaceChildDepIfNotInSameResourcePath(deps, i, entryDep));
                    touchedMods.add(entryMod);
                    for (const d of allDependencies)
                        yield makeExtDepsRecursively(d);
                });
            }
            function makeExtDepToReplaceChildDepIfNotInSameResourcePath(childDependencies, childDepIndex, entryDep) {
                var _a, _b, _c;
                return __awaiter(this, void 0, void 0, function* () {
                    const childDep = childDependencies[childDepIndex];
                    const childMod = compilation.moduleGraph.getModule(childDep);
                    if (!(childMod instanceof webpack_1.NormalModule))
                        return;
                    const childResourcePath = (_a = childMod.resourceResolveData) === null || _a === void 0 ? void 0 : _a.path;
                    const entryMod = compilation.moduleGraph.getModule(entryDep);
                    const entryParentMod = compilation.moduleGraph.getParentModule(entryDep);
                    let entryResourcePath;
                    if (entryMod instanceof webpack_1.NormalModule) {
                        entryResourcePath = (_b = entryMod.resourceResolveData) === null || _b === void 0 ? void 0 : _b.path;
                    }
                    else if (entryParentMod instanceof webpack_1.NormalModule) {
                        entryResourcePath = (_c = entryParentMod.resourceResolveData) === null || _c === void 0 ? void 0 : _c.path;
                    }
                    else
                        return;
                    if (typeof childResourcePath !== 'string' || typeof entryResourcePath !== 'string')
                        return;
                    if (childResourcePath === entryResourcePath)
                        return;
                    // Makes the requireable relative path for the external mod.
                    const entryBundlePath = evaluateBundlePath(entryResourcePath);
                    const childBundlePath = evaluateBundlePath(childResourcePath);
                    let request = node_path_1.default.relative(node_path_1.default.dirname(entryBundlePath), childBundlePath);
                    if (!node_path_1.default.isAbsolute(request) && !request.startsWith('.')) {
                        request = `.${node_path_1.default.sep}${request}`;
                    }
                    request = request.replace(/\\/g, node_path_1.default.posix.sep);
                    const extModCandidate = new TranspileExternalModule_1.TranspileExternalModule(request, constants_1.externalModuleTypeCjs, entryResourcePath);
                    let extMod = compilation.getModule(extModCandidate);
                    let doesExtModNeedBuild = false;
                    if (!(extMod instanceof webpack_1.ExternalModule)) {
                        if (compilation.profile) {
                            compilation.moduleGraph.setProfile(extModCandidate, new ModuleProfile_1.default());
                        }
                        const extModReturned = yield (0, node_util_1.promisify)(compilation.addModule).call(compilation, extModCandidate);
                        // Uses extModReturned prior to extModCandidate in case some cached module
                        // is used in compilation.addModule.
                        extMod = extModReturned !== null && extModReturned !== void 0 ? extModReturned : extModCandidate;
                        doesExtModNeedBuild = true;
                    }
                    // Clones child dep to make external dep for connecting external mod so that
                    // connections of child dep get preserved for making entries.
                    const extDep = (0, lodash_1.clone)(childDep);
                    childDependencies[childDepIndex] = extDep;
                    const childConnection = compilation.moduleGraph.getConnection(childDep);
                    if (childConnection) {
                        const entryMgm = compilation.moduleGraph._getModuleGraphModule(entryMod);
                        entryMgm.outgoingConnections.delete(childConnection);
                    }
                    compilation.moduleGraph.setResolvedModule(entryMod, extDep, extMod);
                    compilation.moduleGraph.setIssuerIfUnset(extMod, entryMod);
                    if (doesExtModNeedBuild) {
                        yield (0, node_util_1.promisify)(compilation.buildModule).call(compilation, extMod);
                    }
                });
            }
            function evaluateBundlePath(resourcePath) {
                let bundlePath = resourcePath;
                if (entryResourcePaths.includes(resourcePath)) {
                    if (hoistNodeModules) {
                        const matchesNodeModules = resourcePath.match(constants_1.reNodeModules);
                        if (matchesNodeModules) {
                            bundlePath = node_path_1.default.resolve(outputPathOfNodeModules, resourcePath.substring(matchesNodeModules.index + matchesNodeModules[0].length));
                        }
                        else {
                            bundlePath = node_path_1.default.resolve(outputPath, node_path_1.default.relative(commonDirWoNodeModules, resourcePath));
                        }
                    }
                    else {
                        bundlePath = node_path_1.default.resolve(outputPath, node_path_1.default.relative(commonDir, resourcePath));
                    }
                    const bundlePathParsed = node_path_1.default.parse(bundlePath);
                    const bundlePathNewExt = extentionMapping[bundlePathParsed.ext];
                    if (typeof bundlePathNewExt === 'string') {
                        bundlePath = node_path_1.default.format(Object.assign(Object.assign({}, bundlePathParsed), { ext: bundlePathNewExt, base: bundlePathParsed.name + bundlePathNewExt }));
                    }
                }
                return bundlePath;
            }
            function evaluateBundleRelPath(resourcePath) {
                return node_path_1.default.relative(outputPath, evaluateBundlePath(resourcePath));
            }
            function makeEntriesAndCollectEntryExtentions() {
                for (const [entryResourcePath, entryDep] of entryDeps) {
                    const entryBundleRelPath = evaluateBundleRelPath(entryResourcePath);
                    const entryBundleRelPathParsed = node_path_1.default.parse(entryBundleRelPath);
                    if (entryBundleRelPathParsed.ext === constants_1.extJson) {
                        emitJson(entryBundleRelPath, entryResourcePath, entryDep);
                    }
                    else {
                        assignEntry(entryBundleRelPath, entryDep);
                        const entryMod = compilation.moduleGraph.getModule(entryDep);
                        if (entryMod) {
                            if (!entryMod.type.startsWith(constants_1.sourceTypeAsset)) {
                                entryExtentionsToHaveSourceMaps.add(entryBundleRelPathParsed.ext);
                            }
                        }
                    }
                }
            }
            function emitJson(entryBundleRelPath, entryResourcePath, entryDep) {
                const entryMod = compilation.moduleGraph.getModule(entryDep);
                if (entryMod instanceof webpack_1.NormalModule) {
                    const { jsonData } = entryMod.buildInfo;
                    if (!jsonData) {
                        throw new Error(`${constants_1.pluginName}${node_os_1.default.EOL}File '${node_path_1.default.relative(context, entryResourcePath)}' is not type of JSON`);
                    }
                    entryMod.buildInfo.assets = {
                        [entryBundleRelPath]: new RawSource(JSON.stringify(jsonData.get())),
                    };
                }
            }
            function assignEntry(entryBundleRelPath, entryDep) {
                const name = entryBundleRelPath;
                const filename = entryBundleRelPath;
                entries.set(name, {
                    dependencies: [entryDep],
                    includeDependencies: [],
                    options: { name, filename },
                });
            }
        }));
    }
}
exports.TranspileWebpackPlugin = TranspileWebpackPlugin;
//# sourceMappingURL=TranspileWebpackPlugin.js.map