"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.alignResolveByDependency = exports.isTargetNodeCompatible = exports.enableBuiltinNodeGlobalsByDefault = exports.throwErrIfHotModuleReplacementEnabled = exports.throwErrIfOutputPathNotSpecified = exports.forceDisableOutputModule = exports.forceSetLibraryType = exports.forceDisableSplitChunks = void 0;
const node_os_1 = __importDefault(require("node:os"));
const lodash_1 = require("lodash");
const constants_1 = require("./constants");
const defaultsSetters_1 = require("./defaultsSetters");
const webpack_1 = require("./peers/webpack");
function forceDisableSplitChunks(compilerOptions) {
    (0, lodash_1.set)(compilerOptions, 'optimization.splitChunks', false);
}
exports.forceDisableSplitChunks = forceDisableSplitChunks;
function forceSetLibraryType(compilerOptions, libraryType) {
    (0, lodash_1.set)(compilerOptions, 'output.library.type', libraryType);
}
exports.forceSetLibraryType = forceSetLibraryType;
function forceDisableOutputModule(compilerOptions) {
    (0, lodash_1.set)(compilerOptions, 'experiments.outputModule', false);
}
exports.forceDisableOutputModule = forceDisableOutputModule;
function throwErrIfOutputPathNotSpecified(compilerOptions) {
    const { output } = compilerOptions;
    if (!output.path)
        throw new Error(`${constants_1.pluginName}${node_os_1.default.EOL}The output.path in webpack config is not specified`);
}
exports.throwErrIfOutputPathNotSpecified = throwErrIfOutputPathNotSpecified;
function throwErrIfHotModuleReplacementEnabled(compilerOptions) {
    const { plugins } = compilerOptions;
    for (const p of plugins) {
        if (p instanceof webpack_1.HotModuleReplacementPlugin ||
            p.constructor.name === 'HotModuleReplacementPlugin') {
            throw new Error(`${constants_1.pluginName}${node_os_1.default.EOL}Hot module replacement is not supported when using plugin '${constants_1.pluginName}'`);
        }
    }
}
exports.throwErrIfHotModuleReplacementEnabled = throwErrIfHotModuleReplacementEnabled;
function enableBuiltinNodeGlobalsByDefault(compilerOptions) {
    if (compilerOptions.node) {
        (0, defaultsSetters_1.D)(compilerOptions.node, '__dirname', false);
        (0, defaultsSetters_1.D)(compilerOptions.node, '__filename', false);
    }
}
exports.enableBuiltinNodeGlobalsByDefault = enableBuiltinNodeGlobalsByDefault;
function isTargetNodeCompatible(target) {
    return (0, lodash_1.flatten)([target]).some((t) => typeof t === 'string' && t.includes('node'));
}
exports.isTargetNodeCompatible = isTargetNodeCompatible;
function alignResolveByDependency(compilerOptions, preferredType) {
    const { byDependency } = compilerOptions.resolve;
    if (!byDependency)
        return;
    if (!Object.prototype.hasOwnProperty.call(byDependency, preferredType))
        preferredType = 'unknown';
    const preferredOpts = byDependency[preferredType];
    for (const [type, opts] of Object.entries(byDependency)) {
        if (type !== preferredType) {
            Object.assign(opts, (0, lodash_1.pick)(preferredOpts, Object.keys(opts)));
        }
    }
}
exports.alignResolveByDependency = alignResolveByDependency;
//# sourceMappingURL=compilerOptions.js.map