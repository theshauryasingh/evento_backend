
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model User_Plan
 * 
 */
export type User_Plan = $Result.DefaultSelection<Prisma.$User_PlanPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Sponsor
 * 
 */
export type Sponsor = $Result.DefaultSelection<Prisma.$SponsorPayload>
/**
 * Model Advertisement
 * 
 */
export type Advertisement = $Result.DefaultSelection<Prisma.$AdvertisementPayload>
/**
 * Model LostAndFound
 * 
 */
export type LostAndFound = $Result.DefaultSelection<Prisma.$LostAndFoundPayload>
/**
 * Model EventMap
 * 
 */
export type EventMap = $Result.DefaultSelection<Prisma.$EventMapPayload>
/**
 * Model Shops
 * 
 */
export type Shops = $Result.DefaultSelection<Prisma.$ShopsPayload>
/**
 * Model ShopPayment
 * 
 */
export type ShopPayment = $Result.DefaultSelection<Prisma.$ShopPaymentPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Itinerary
 * 
 */
export type Itinerary = $Result.DefaultSelection<Prisma.$ItineraryPayload>
/**
 * Model Favourite
 * 
 */
export type Favourite = $Result.DefaultSelection<Prisma.$FavouritePayload>
/**
 * Model Token_Transaction
 * 
 */
export type Token_Transaction = $Result.DefaultSelection<Prisma.$Token_TransactionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Amenities
 * 
 */
export type Amenities = $Result.DefaultSelection<Prisma.$AmenitiesPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Emergency_Contacts
 * 
 */
export type Emergency_Contacts = $Result.DefaultSelection<Prisma.$Emergency_ContactsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.user_Plan`: Exposes CRUD operations for the **User_Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Plans
    * const user_Plans = await prisma.user_Plan.findMany()
    * ```
    */
  get user_Plan(): Prisma.User_PlanDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.sponsor`: Exposes CRUD operations for the **Sponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsor.findMany()
    * ```
    */
  get sponsor(): Prisma.SponsorDelegate<ExtArgs>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **Advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.AdvertisementDelegate<ExtArgs>;

  /**
   * `prisma.lostAndFound`: Exposes CRUD operations for the **LostAndFound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LostAndFounds
    * const lostAndFounds = await prisma.lostAndFound.findMany()
    * ```
    */
  get lostAndFound(): Prisma.LostAndFoundDelegate<ExtArgs>;

  /**
   * `prisma.eventMap`: Exposes CRUD operations for the **EventMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventMaps
    * const eventMaps = await prisma.eventMap.findMany()
    * ```
    */
  get eventMap(): Prisma.EventMapDelegate<ExtArgs>;

  /**
   * `prisma.shops`: Exposes CRUD operations for the **Shops** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shops.findMany()
    * ```
    */
  get shops(): Prisma.ShopsDelegate<ExtArgs>;

  /**
   * `prisma.shopPayment`: Exposes CRUD operations for the **ShopPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopPayments
    * const shopPayments = await prisma.shopPayment.findMany()
    * ```
    */
  get shopPayment(): Prisma.ShopPaymentDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.itinerary`: Exposes CRUD operations for the **Itinerary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itineraries
    * const itineraries = await prisma.itinerary.findMany()
    * ```
    */
  get itinerary(): Prisma.ItineraryDelegate<ExtArgs>;

  /**
   * `prisma.favourite`: Exposes CRUD operations for the **Favourite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favourites
    * const favourites = await prisma.favourite.findMany()
    * ```
    */
  get favourite(): Prisma.FavouriteDelegate<ExtArgs>;

  /**
   * `prisma.token_Transaction`: Exposes CRUD operations for the **Token_Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_Transactions
    * const token_Transactions = await prisma.token_Transaction.findMany()
    * ```
    */
  get token_Transaction(): Prisma.Token_TransactionDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.amenities`: Exposes CRUD operations for the **Amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenities.findMany()
    * ```
    */
  get amenities(): Prisma.AmenitiesDelegate<ExtArgs>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs>;

  /**
   * `prisma.emergency_Contacts`: Exposes CRUD operations for the **Emergency_Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emergency_Contacts
    * const emergency_Contacts = await prisma.emergency_Contacts.findMany()
    * ```
    */
  get emergency_Contacts(): Prisma.Emergency_ContactsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    Event: 'Event',
    Plan: 'Plan',
    Transaction: 'Transaction',
    User_Plan: 'User_Plan',
    Role: 'Role',
    Sponsor: 'Sponsor',
    Advertisement: 'Advertisement',
    LostAndFound: 'LostAndFound',
    EventMap: 'EventMap',
    Shops: 'Shops',
    ShopPayment: 'ShopPayment',
    Review: 'Review',
    Itinerary: 'Itinerary',
    Favourite: 'Favourite',
    Token_Transaction: 'Token_Transaction',
    Notification: 'Notification',
    Amenities: 'Amenities',
    Venue: 'Venue',
    Emergency_Contacts: 'Emergency_Contacts'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'refreshToken' | 'event' | 'plan' | 'transaction' | 'user_Plan' | 'role' | 'sponsor' | 'advertisement' | 'lostAndFound' | 'eventMap' | 'shops' | 'shopPayment' | 'review' | 'itinerary' | 'favourite' | 'token_Transaction' | 'notification' | 'amenities' | 'venue' | 'emergency_Contacts'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>,
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      User_Plan: {
        payload: Prisma.$User_PlanPayload<ExtArgs>
        fields: Prisma.User_PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.User_PlanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.User_PlanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          findFirst: {
            args: Prisma.User_PlanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.User_PlanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          findMany: {
            args: Prisma.User_PlanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>[]
          }
          create: {
            args: Prisma.User_PlanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          createMany: {
            args: Prisma.User_PlanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.User_PlanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          update: {
            args: Prisma.User_PlanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          deleteMany: {
            args: Prisma.User_PlanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.User_PlanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.User_PlanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$User_PlanPayload>
          }
          aggregate: {
            args: Prisma.User_PlanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_Plan>
          }
          groupBy: {
            args: Prisma.User_PlanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.User_PlanCountArgs<ExtArgs>,
            result: $Utils.Optional<User_PlanCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Sponsor: {
        payload: Prisma.$SponsorPayload<ExtArgs>
        fields: Prisma.SponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findFirst: {
            args: Prisma.SponsorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findMany: {
            args: Prisma.SponsorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          create: {
            args: Prisma.SponsorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          createMany: {
            args: Prisma.SponsorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SponsorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          update: {
            args: Prisma.SponsorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          deleteMany: {
            args: Prisma.SponsorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SponsorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          aggregate: {
            args: Prisma.SponsorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSponsor>
          }
          groupBy: {
            args: Prisma.SponsorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SponsorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SponsorCountArgs<ExtArgs>,
            result: $Utils.Optional<SponsorCountAggregateOutputType> | number
          }
        }
      }
      Advertisement: {
        payload: Prisma.$AdvertisementPayload<ExtArgs>
        fields: Prisma.AdvertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findMany: {
            args: Prisma.AdvertisementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          create: {
            args: Prisma.AdvertisementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          createMany: {
            args: Prisma.AdvertisementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvertisementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          update: {
            args: Prisma.AdvertisementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.AdvertisementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvertisementCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      LostAndFound: {
        payload: Prisma.$LostAndFoundPayload<ExtArgs>
        fields: Prisma.LostAndFoundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LostAndFoundFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LostAndFoundFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          findFirst: {
            args: Prisma.LostAndFoundFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LostAndFoundFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          findMany: {
            args: Prisma.LostAndFoundFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>[]
          }
          create: {
            args: Prisma.LostAndFoundCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          createMany: {
            args: Prisma.LostAndFoundCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LostAndFoundDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          update: {
            args: Prisma.LostAndFoundUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          deleteMany: {
            args: Prisma.LostAndFoundDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LostAndFoundUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LostAndFoundUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LostAndFoundPayload>
          }
          aggregate: {
            args: Prisma.LostAndFoundAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLostAndFound>
          }
          groupBy: {
            args: Prisma.LostAndFoundGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LostAndFoundGroupByOutputType>[]
          }
          count: {
            args: Prisma.LostAndFoundCountArgs<ExtArgs>,
            result: $Utils.Optional<LostAndFoundCountAggregateOutputType> | number
          }
        }
      }
      EventMap: {
        payload: Prisma.$EventMapPayload<ExtArgs>
        fields: Prisma.EventMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventMapFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventMapFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          findFirst: {
            args: Prisma.EventMapFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventMapFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          findMany: {
            args: Prisma.EventMapFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>[]
          }
          create: {
            args: Prisma.EventMapCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          createMany: {
            args: Prisma.EventMapCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventMapDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          update: {
            args: Prisma.EventMapUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          deleteMany: {
            args: Prisma.EventMapDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventMapUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventMapUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventMapPayload>
          }
          aggregate: {
            args: Prisma.EventMapAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventMap>
          }
          groupBy: {
            args: Prisma.EventMapGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventMapCountArgs<ExtArgs>,
            result: $Utils.Optional<EventMapCountAggregateOutputType> | number
          }
        }
      }
      Shops: {
        payload: Prisma.$ShopsPayload<ExtArgs>
        fields: Prisma.ShopsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          findFirst: {
            args: Prisma.ShopsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          findMany: {
            args: Prisma.ShopsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>[]
          }
          create: {
            args: Prisma.ShopsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          createMany: {
            args: Prisma.ShopsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          update: {
            args: Prisma.ShopsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          deleteMany: {
            args: Prisma.ShopsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopsPayload>
          }
          aggregate: {
            args: Prisma.ShopsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShops>
          }
          groupBy: {
            args: Prisma.ShopsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopsCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopsCountAggregateOutputType> | number
          }
        }
      }
      ShopPayment: {
        payload: Prisma.$ShopPaymentPayload<ExtArgs>
        fields: Prisma.ShopPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          findFirst: {
            args: Prisma.ShopPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          findMany: {
            args: Prisma.ShopPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>[]
          }
          create: {
            args: Prisma.ShopPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          createMany: {
            args: Prisma.ShopPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          update: {
            args: Prisma.ShopPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ShopPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopPaymentPayload>
          }
          aggregate: {
            args: Prisma.ShopPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopPayment>
          }
          groupBy: {
            args: Prisma.ShopPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopPaymentCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Itinerary: {
        payload: Prisma.$ItineraryPayload<ExtArgs>
        fields: Prisma.ItineraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItineraryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItineraryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findFirst: {
            args: Prisma.ItineraryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItineraryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          findMany: {
            args: Prisma.ItineraryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>[]
          }
          create: {
            args: Prisma.ItineraryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          createMany: {
            args: Prisma.ItineraryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItineraryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          update: {
            args: Prisma.ItineraryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          deleteMany: {
            args: Prisma.ItineraryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItineraryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItineraryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItineraryPayload>
          }
          aggregate: {
            args: Prisma.ItineraryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItinerary>
          }
          groupBy: {
            args: Prisma.ItineraryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItineraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItineraryCountArgs<ExtArgs>,
            result: $Utils.Optional<ItineraryCountAggregateOutputType> | number
          }
        }
      }
      Favourite: {
        payload: Prisma.$FavouritePayload<ExtArgs>
        fields: Prisma.FavouriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavouriteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavouriteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          findFirst: {
            args: Prisma.FavouriteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavouriteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          findMany: {
            args: Prisma.FavouriteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>[]
          }
          create: {
            args: Prisma.FavouriteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          createMany: {
            args: Prisma.FavouriteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FavouriteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          update: {
            args: Prisma.FavouriteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          deleteMany: {
            args: Prisma.FavouriteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FavouriteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FavouriteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FavouritePayload>
          }
          aggregate: {
            args: Prisma.FavouriteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFavourite>
          }
          groupBy: {
            args: Prisma.FavouriteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FavouriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavouriteCountArgs<ExtArgs>,
            result: $Utils.Optional<FavouriteCountAggregateOutputType> | number
          }
        }
      }
      Token_Transaction: {
        payload: Prisma.$Token_TransactionPayload<ExtArgs>
        fields: Prisma.Token_TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Token_TransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Token_TransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          findFirst: {
            args: Prisma.Token_TransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Token_TransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          findMany: {
            args: Prisma.Token_TransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>[]
          }
          create: {
            args: Prisma.Token_TransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          createMany: {
            args: Prisma.Token_TransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Token_TransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          update: {
            args: Prisma.Token_TransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          deleteMany: {
            args: Prisma.Token_TransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Token_TransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Token_TransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Token_TransactionPayload>
          }
          aggregate: {
            args: Prisma.Token_TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateToken_Transaction>
          }
          groupBy: {
            args: Prisma.Token_TransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Token_TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.Token_TransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<Token_TransactionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Amenities: {
        payload: Prisma.$AmenitiesPayload<ExtArgs>
        fields: Prisma.AmenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenitiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenitiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findFirst: {
            args: Prisma.AmenitiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenitiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findMany: {
            args: Prisma.AmenitiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          create: {
            args: Prisma.AmenitiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          createMany: {
            args: Prisma.AmenitiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AmenitiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          update: {
            args: Prisma.AmenitiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          deleteMany: {
            args: Prisma.AmenitiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AmenitiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AmenitiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          aggregate: {
            args: Prisma.AmenitiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAmenities>
          }
          groupBy: {
            args: Prisma.AmenitiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AmenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenitiesCountArgs<ExtArgs>,
            result: $Utils.Optional<AmenitiesCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>,
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Emergency_Contacts: {
        payload: Prisma.$Emergency_ContactsPayload<ExtArgs>
        fields: Prisma.Emergency_ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Emergency_ContactsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Emergency_ContactsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          findFirst: {
            args: Prisma.Emergency_ContactsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Emergency_ContactsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          findMany: {
            args: Prisma.Emergency_ContactsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>[]
          }
          create: {
            args: Prisma.Emergency_ContactsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          createMany: {
            args: Prisma.Emergency_ContactsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Emergency_ContactsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          update: {
            args: Prisma.Emergency_ContactsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          deleteMany: {
            args: Prisma.Emergency_ContactsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Emergency_ContactsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Emergency_ContactsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Emergency_ContactsPayload>
          }
          aggregate: {
            args: Prisma.Emergency_ContactsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmergency_Contacts>
          }
          groupBy: {
            args: Prisma.Emergency_ContactsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Emergency_ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Emergency_ContactsCountArgs<ExtArgs>,
            result: $Utils.Optional<Emergency_ContactsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    User_plan: number
    transaction: number
    event: number
    shoppayment: number
    review: number
    favourite: number
    notification: number
    claim_user: number
    reporter_user: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_plan?: boolean | UserCountOutputTypeCountUser_planArgs
    transaction?: boolean | UserCountOutputTypeCountTransactionArgs
    event?: boolean | UserCountOutputTypeCountEventArgs
    shoppayment?: boolean | UserCountOutputTypeCountShoppaymentArgs
    review?: boolean | UserCountOutputTypeCountReviewArgs
    favourite?: boolean | UserCountOutputTypeCountFavouriteArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    claim_user?: boolean | UserCountOutputTypeCountClaim_userArgs
    reporter_user?: boolean | UserCountOutputTypeCountReporter_userArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_PlanWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopPaymentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavouriteWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaim_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LostAndFoundWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReporter_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LostAndFoundWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }



  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    lostandfound: number
    sponsor: number
    advertisement: number
    eventmap: number
    shop: number
    shoppayment: number
    review: number
    itinerary: number
    favourite: number
    tokentransaction: number
    amenities: number
    emergency_contacts: number
    venue: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lostandfound?: boolean | EventCountOutputTypeCountLostandfoundArgs
    sponsor?: boolean | EventCountOutputTypeCountSponsorArgs
    advertisement?: boolean | EventCountOutputTypeCountAdvertisementArgs
    eventmap?: boolean | EventCountOutputTypeCountEventmapArgs
    shop?: boolean | EventCountOutputTypeCountShopArgs
    shoppayment?: boolean | EventCountOutputTypeCountShoppaymentArgs
    review?: boolean | EventCountOutputTypeCountReviewArgs
    itinerary?: boolean | EventCountOutputTypeCountItineraryArgs
    favourite?: boolean | EventCountOutputTypeCountFavouriteArgs
    tokentransaction?: boolean | EventCountOutputTypeCountTokentransactionArgs
    amenities?: boolean | EventCountOutputTypeCountAmenitiesArgs
    emergency_contacts?: boolean | EventCountOutputTypeCountEmergency_contactsArgs
    venue?: boolean | EventCountOutputTypeCountVenueArgs
  }

  // Custom InputTypes

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountLostandfoundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LostAndFoundWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSponsorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAdvertisementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventMapWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopsWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountShoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopPaymentWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountFavouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavouriteWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Token_TransactionWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEmergency_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Emergency_ContactsWhereInput
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }



  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    user_plan: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_plan?: boolean | PlanCountOutputTypeCountUser_planArgs
  }

  // Custom InputTypes

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountUser_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_PlanWhereInput
  }



  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    tokentransaction: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokentransaction?: boolean | TransactionCountOutputTypeCountTokentransactionArgs
  }

  // Custom InputTypes

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountTokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Token_TransactionWhereInput
  }



  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    user: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RoleCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type ShopsCountOutputType
   */

  export type ShopsCountOutputType = {
    shoppayment: number
    tokentransaction: number
  }

  export type ShopsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shoppayment?: boolean | ShopsCountOutputTypeCountShoppaymentArgs
    tokentransaction?: boolean | ShopsCountOutputTypeCountTokentransactionArgs
  }

  // Custom InputTypes

  /**
   * ShopsCountOutputType without action
   */
  export type ShopsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopsCountOutputType
     */
    select?: ShopsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ShopsCountOutputType without action
   */
  export type ShopsCountOutputTypeCountShoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopPaymentWhereInput
  }


  /**
   * ShopsCountOutputType without action
   */
  export type ShopsCountOutputTypeCountTokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Token_TransactionWhereInput
  }



  /**
   * Count Type ItineraryCountOutputType
   */

  export type ItineraryCountOutputType = {
    favourite: number
  }

  export type ItineraryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favourite?: boolean | ItineraryCountOutputTypeCountFavouriteArgs
  }

  // Custom InputTypes

  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItineraryCountOutputType
     */
    select?: ItineraryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItineraryCountOutputType without action
   */
  export type ItineraryCountOutputTypeCountFavouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavouriteWhereInput
  }



  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    event: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | VenueCountOutputTypeCountEventArgs
  }

  // Custom InputTypes

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
    token: number | null
    role_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
    token: number | null
    role_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    contact_number: string | null
    token: number | null
    role_id: number | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    full_name: string | null
    email: string | null
    password: string | null
    contact_number: string | null
    token: number | null
    role_id: number | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    full_name: number
    email: number
    password: number
    contact_number: number
    token: number
    role_id: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
    token?: true
    role_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
    token?: true
    role_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    password?: true
    contact_number?: true
    token?: true
    role_id?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    password?: true
    contact_number?: true
    token?: true
    role_id?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    full_name?: true
    email?: true
    password?: true
    contact_number?: true
    token?: true
    role_id?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token: number
    role_id: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    contact_number?: boolean
    token?: boolean
    role_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    User_plan?: boolean | User$User_planArgs<ExtArgs>
    transaction?: boolean | User$transactionArgs<ExtArgs>
    event?: boolean | User$eventArgs<ExtArgs>
    shoppayment?: boolean | User$shoppaymentArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    favourite?: boolean | User$favouriteArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    claim_user?: boolean | User$claim_userArgs<ExtArgs>
    reporter_user?: boolean | User$reporter_userArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    user_id?: boolean
    full_name?: boolean
    email?: boolean
    password?: boolean
    contact_number?: boolean
    token?: boolean
    role_id?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    User_plan?: boolean | User$User_planArgs<ExtArgs>
    transaction?: boolean | User$transactionArgs<ExtArgs>
    event?: boolean | User$eventArgs<ExtArgs>
    shoppayment?: boolean | User$shoppaymentArgs<ExtArgs>
    review?: boolean | User$reviewArgs<ExtArgs>
    favourite?: boolean | User$favouriteArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    claim_user?: boolean | User$claim_userArgs<ExtArgs>
    reporter_user?: boolean | User$reporter_userArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      User_plan: Prisma.$User_PlanPayload<ExtArgs>[]
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs>[]
      shoppayment: Prisma.$ShopPaymentPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs>[]
      favourite: Prisma.$FavouritePayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs>[]
      claim_user: Prisma.$LostAndFoundPayload<ExtArgs>[]
      reporter_user: Prisma.$LostAndFoundPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      full_name: string
      email: string
      password: string
      contact_number: string
      token: number
      role_id: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    User_plan<T extends User$User_planArgs<ExtArgs> = {}>(args?: Subset<T, User$User_planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findMany'> | Null>;

    transaction<T extends User$transactionArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    event<T extends User$eventArgs<ExtArgs> = {}>(args?: Subset<T, User$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findMany'> | Null>;

    shoppayment<T extends User$shoppaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$shoppaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    review<T extends User$reviewArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    favourite<T extends User$favouriteArgs<ExtArgs> = {}>(args?: Subset<T, User$favouriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findMany'> | Null>;

    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    claim_user<T extends User$claim_userArgs<ExtArgs> = {}>(args?: Subset<T, User$claim_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findMany'> | Null>;

    reporter_user<T extends User$reporter_userArgs<ExtArgs> = {}>(args?: Subset<T, User$reporter_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findMany'> | Null>;

    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly user_id: FieldRef<"User", 'Int'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly contact_number: FieldRef<"User", 'String'>
    readonly token: FieldRef<"User", 'Int'>
    readonly role_id: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.User_plan
   */
  export type User$User_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    where?: User_PlanWhereInput
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    cursor?: User_PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_PlanScalarFieldEnum | User_PlanScalarFieldEnum[]
  }


  /**
   * User.transaction
   */
  export type User$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * User.event
   */
  export type User$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * User.shoppayment
   */
  export type User$shoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    where?: ShopPaymentWhereInput
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    cursor?: ShopPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * User.review
   */
  export type User$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * User.favourite
   */
  export type User$favouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    where?: FavouriteWhereInput
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    cursor?: FavouriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * User.claim_user
   */
  export type User$claim_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    where?: LostAndFoundWhereInput
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    cursor?: LostAndFoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * User.reporter_user
   */
  export type User$reporter_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    where?: LostAndFoundWhereInput
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    cursor?: LostAndFoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }


  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RefreshTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RefreshTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RefreshTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
    **/
    create<T extends RefreshTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     *     @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     *     @example
     *     // Create many RefreshTokens
     *     const refreshToken = await prisma.refreshToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RefreshTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
    **/
    delete<T extends RefreshTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RefreshTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RefreshTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RefreshTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
    **/
    upsert<T extends RefreshTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'Int'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }


  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }


  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }


  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }


  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }


  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }


  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }



  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    event_id: number | null
    creator_id: number | null
    entry_fee: number | null
    venue_id: number | null
  }

  export type EventSumAggregateOutputType = {
    event_id: number | null
    creator_id: number | null
    entry_fee: number | null
    venue_id: number | null
  }

  export type EventMinAggregateOutputType = {
    event_id: number | null
    event_name: string | null
    event_description: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    event_tags: string | null
    creator_id: number | null
    approval: boolean | null
    status: string | null
    entry_fee: number | null
    thumbnail_link: string | null
    banner_link: Date | null
    video_link: Date | null
    venue_id: number | null
  }

  export type EventMaxAggregateOutputType = {
    event_id: number | null
    event_name: string | null
    event_description: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    event_tags: string | null
    creator_id: number | null
    approval: boolean | null
    status: string | null
    entry_fee: number | null
    thumbnail_link: string | null
    banner_link: Date | null
    video_link: Date | null
    venue_id: number | null
  }

  export type EventCountAggregateOutputType = {
    event_id: number
    event_name: number
    event_description: number
    location: number
    start_date: number
    end_date: number
    event_tags: number
    creator_id: number
    approval: number
    status: number
    entry_fee: number
    thumbnail_link: number
    banner_link: number
    video_link: number
    venue_id: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    event_id?: true
    creator_id?: true
    entry_fee?: true
    venue_id?: true
  }

  export type EventSumAggregateInputType = {
    event_id?: true
    creator_id?: true
    entry_fee?: true
    venue_id?: true
  }

  export type EventMinAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    location?: true
    start_date?: true
    end_date?: true
    event_tags?: true
    creator_id?: true
    approval?: true
    status?: true
    entry_fee?: true
    thumbnail_link?: true
    banner_link?: true
    video_link?: true
    venue_id?: true
  }

  export type EventMaxAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    location?: true
    start_date?: true
    end_date?: true
    event_tags?: true
    creator_id?: true
    approval?: true
    status?: true
    entry_fee?: true
    thumbnail_link?: true
    banner_link?: true
    video_link?: true
    venue_id?: true
  }

  export type EventCountAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    location?: true
    start_date?: true
    end_date?: true
    event_tags?: true
    creator_id?: true
    approval?: true
    status?: true
    entry_fee?: true
    thumbnail_link?: true
    banner_link?: true
    video_link?: true
    venue_id?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    event_id: number
    event_name: string
    event_description: string
    location: string
    start_date: Date
    end_date: Date
    event_tags: string
    creator_id: number
    approval: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date
    video_link: Date
    venue_id: number
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    event_tags?: boolean
    creator_id?: boolean
    approval?: boolean
    status?: boolean
    entry_fee?: boolean
    thumbnail_link?: boolean
    banner_link?: boolean
    video_link?: boolean
    venue_id?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lostandfound?: boolean | Event$lostandfoundArgs<ExtArgs>
    sponsor?: boolean | Event$sponsorArgs<ExtArgs>
    advertisement?: boolean | Event$advertisementArgs<ExtArgs>
    eventmap?: boolean | Event$eventmapArgs<ExtArgs>
    shop?: boolean | Event$shopArgs<ExtArgs>
    shoppayment?: boolean | Event$shoppaymentArgs<ExtArgs>
    review?: boolean | Event$reviewArgs<ExtArgs>
    itinerary?: boolean | Event$itineraryArgs<ExtArgs>
    favourite?: boolean | Event$favouriteArgs<ExtArgs>
    tokentransaction?: boolean | Event$tokentransactionArgs<ExtArgs>
    amenities?: boolean | Event$amenitiesArgs<ExtArgs>
    emergency_contacts?: boolean | Event$emergency_contactsArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    event_tags?: boolean
    creator_id?: boolean
    approval?: boolean
    status?: boolean
    entry_fee?: boolean
    thumbnail_link?: boolean
    banner_link?: boolean
    video_link?: boolean
    venue_id?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lostandfound?: boolean | Event$lostandfoundArgs<ExtArgs>
    sponsor?: boolean | Event$sponsorArgs<ExtArgs>
    advertisement?: boolean | Event$advertisementArgs<ExtArgs>
    eventmap?: boolean | Event$eventmapArgs<ExtArgs>
    shop?: boolean | Event$shopArgs<ExtArgs>
    shoppayment?: boolean | Event$shoppaymentArgs<ExtArgs>
    review?: boolean | Event$reviewArgs<ExtArgs>
    itinerary?: boolean | Event$itineraryArgs<ExtArgs>
    favourite?: boolean | Event$favouriteArgs<ExtArgs>
    tokentransaction?: boolean | Event$tokentransactionArgs<ExtArgs>
    amenities?: boolean | Event$amenitiesArgs<ExtArgs>
    emergency_contacts?: boolean | Event$emergency_contactsArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      lostandfound: Prisma.$LostAndFoundPayload<ExtArgs>[]
      sponsor: Prisma.$SponsorPayload<ExtArgs>[]
      advertisement: Prisma.$AdvertisementPayload<ExtArgs>[]
      eventmap: Prisma.$EventMapPayload<ExtArgs>[]
      shop: Prisma.$ShopsPayload<ExtArgs>[]
      shoppayment: Prisma.$ShopPaymentPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs>[]
      itinerary: Prisma.$ItineraryPayload<ExtArgs>[]
      favourite: Prisma.$FavouritePayload<ExtArgs>[]
      tokentransaction: Prisma.$Token_TransactionPayload<ExtArgs>[]
      amenities: Prisma.$AmenitiesPayload<ExtArgs>[]
      emergency_contacts: Prisma.$Emergency_ContactsPayload<ExtArgs>[]
      venue: Prisma.$VenuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: number
      event_name: string
      event_description: string
      location: string
      start_date: Date
      end_date: Date
      event_tags: string
      creator_id: number
      approval: boolean
      status: string
      entry_fee: number
      thumbnail_link: string
      banner_link: Date
      video_link: Date
      venue_id: number
    }, ExtArgs["result"]["event"]>
    composites: {}
  }


  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.findMany({ select: { event_id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventCreateArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventDeleteArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpdateArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpsertArgs<ExtArgs>>
    ): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    lostandfound<T extends Event$lostandfoundArgs<ExtArgs> = {}>(args?: Subset<T, Event$lostandfoundArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findMany'> | Null>;

    sponsor<T extends Event$sponsorArgs<ExtArgs> = {}>(args?: Subset<T, Event$sponsorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findMany'> | Null>;

    advertisement<T extends Event$advertisementArgs<ExtArgs> = {}>(args?: Subset<T, Event$advertisementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'> | Null>;

    eventmap<T extends Event$eventmapArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventmapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findMany'> | Null>;

    shop<T extends Event$shopArgs<ExtArgs> = {}>(args?: Subset<T, Event$shopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findMany'> | Null>;

    shoppayment<T extends Event$shoppaymentArgs<ExtArgs> = {}>(args?: Subset<T, Event$shoppaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    review<T extends Event$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Event$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    itinerary<T extends Event$itineraryArgs<ExtArgs> = {}>(args?: Subset<T, Event$itineraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findMany'> | Null>;

    favourite<T extends Event$favouriteArgs<ExtArgs> = {}>(args?: Subset<T, Event$favouriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findMany'> | Null>;

    tokentransaction<T extends Event$tokentransactionArgs<ExtArgs> = {}>(args?: Subset<T, Event$tokentransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    amenities<T extends Event$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Event$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findMany'> | Null>;

    emergency_contacts<T extends Event$emergency_contactsArgs<ExtArgs> = {}>(args?: Subset<T, Event$emergency_contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findMany'> | Null>;

    venue<T extends Event$venueArgs<ExtArgs> = {}>(args?: Subset<T, Event$venueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly event_id: FieldRef<"Event", 'Int'>
    readonly event_name: FieldRef<"Event", 'String'>
    readonly event_description: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly start_date: FieldRef<"Event", 'DateTime'>
    readonly end_date: FieldRef<"Event", 'DateTime'>
    readonly event_tags: FieldRef<"Event", 'String'>
    readonly creator_id: FieldRef<"Event", 'Int'>
    readonly approval: FieldRef<"Event", 'Boolean'>
    readonly status: FieldRef<"Event", 'String'>
    readonly entry_fee: FieldRef<"Event", 'Float'>
    readonly thumbnail_link: FieldRef<"Event", 'String'>
    readonly banner_link: FieldRef<"Event", 'DateTime'>
    readonly video_link: FieldRef<"Event", 'DateTime'>
    readonly venue_id: FieldRef<"Event", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }


  /**
   * Event.lostandfound
   */
  export type Event$lostandfoundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    where?: LostAndFoundWhereInput
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    cursor?: LostAndFoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * Event.sponsor
   */
  export type Event$sponsorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    cursor?: SponsorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }


  /**
   * Event.advertisement
   */
  export type Event$advertisementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    cursor?: AdvertisementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Event.eventmap
   */
  export type Event$eventmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    where?: EventMapWhereInput
    orderBy?: EventMapOrderByWithRelationInput | EventMapOrderByWithRelationInput[]
    cursor?: EventMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventMapScalarFieldEnum | EventMapScalarFieldEnum[]
  }


  /**
   * Event.shop
   */
  export type Event$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    where?: ShopsWhereInput
    orderBy?: ShopsOrderByWithRelationInput | ShopsOrderByWithRelationInput[]
    cursor?: ShopsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopsScalarFieldEnum | ShopsScalarFieldEnum[]
  }


  /**
   * Event.shoppayment
   */
  export type Event$shoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    where?: ShopPaymentWhereInput
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    cursor?: ShopPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * Event.review
   */
  export type Event$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Event.itinerary
   */
  export type Event$itineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    cursor?: ItineraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }


  /**
   * Event.favourite
   */
  export type Event$favouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    where?: FavouriteWhereInput
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    cursor?: FavouriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * Event.tokentransaction
   */
  export type Event$tokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    where?: Token_TransactionWhereInput
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    cursor?: Token_TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Event.amenities
   */
  export type Event$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    cursor?: AmenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }


  /**
   * Event.emergency_contacts
   */
  export type Event$emergency_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    where?: Emergency_ContactsWhereInput
    orderBy?: Emergency_ContactsOrderByWithRelationInput | Emergency_ContactsOrderByWithRelationInput[]
    cursor?: Emergency_ContactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Emergency_ContactsScalarFieldEnum | Emergency_ContactsScalarFieldEnum[]
  }


  /**
   * Event.venue
   */
  export type Event$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }


  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
  }



  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    plan_id: number | null
    payment: number | null
  }

  export type PlanSumAggregateOutputType = {
    plan_id: number | null
    payment: number | null
  }

  export type PlanMinAggregateOutputType = {
    plan_id: number | null
    plan_features: string | null
    payment: number | null
    plan_name: string | null
  }

  export type PlanMaxAggregateOutputType = {
    plan_id: number | null
    plan_features: string | null
    payment: number | null
    plan_name: string | null
  }

  export type PlanCountAggregateOutputType = {
    plan_id: number
    plan_features: number
    payment: number
    plan_name: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    plan_id?: true
    payment?: true
  }

  export type PlanSumAggregateInputType = {
    plan_id?: true
    payment?: true
  }

  export type PlanMinAggregateInputType = {
    plan_id?: true
    plan_features?: true
    payment?: true
    plan_name?: true
  }

  export type PlanMaxAggregateInputType = {
    plan_id?: true
    plan_features?: true
    payment?: true
    plan_name?: true
  }

  export type PlanCountAggregateInputType = {
    plan_id?: true
    plan_features?: true
    payment?: true
    plan_name?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    plan_id: number
    plan_features: string
    payment: number
    plan_name: string
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plan_id?: boolean
    plan_features?: boolean
    payment?: boolean
    plan_name?: boolean
    user_plan?: boolean | Plan$user_planArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    plan_id?: boolean
    plan_features?: boolean
    payment?: boolean
    plan_name?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_plan?: boolean | Plan$user_planArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      user_plan: Prisma.$User_PlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      plan_id: number
      plan_features: string
      payment: number
      plan_name: string
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }


  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `plan_id`
     * const planWithPlan_idOnly = await prisma.plan.findMany({ select: { plan_id: true } })
     * 
    **/
    findMany<T extends PlanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
    **/
    create<T extends PlanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanCreateArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Plans.
     *     @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     *     @example
     *     // Create many Plans
     *     const plan = await prisma.plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
    **/
    delete<T extends PlanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
    **/
    upsert<T extends PlanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>
    ): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user_plan<T extends Plan$user_planArgs<ExtArgs> = {}>(args?: Subset<T, Plan$user_planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly plan_id: FieldRef<"Plan", 'Int'>
    readonly plan_features: FieldRef<"Plan", 'String'>
    readonly payment: FieldRef<"Plan", 'Float'>
    readonly plan_name: FieldRef<"Plan", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }


  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }


  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }


  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }


  /**
   * Plan.user_plan
   */
  export type Plan$user_planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    where?: User_PlanWhereInput
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    cursor?: User_PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_PlanScalarFieldEnum | User_PlanScalarFieldEnum[]
  }


  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlanInclude<ExtArgs> | null
  }



  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    amount: Decimal | null
    GST: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    amount: Decimal | null
    GST: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    amount: Decimal | null
    GST: Decimal | null
    transaction_id: string | null
    transaction_type: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    plan_id: number | null
    amount: Decimal | null
    GST: Decimal | null
    transaction_id: string | null
    transaction_type: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    user_id: number
    plan_id: number
    amount: number
    GST: number
    transaction_id: number
    transaction_type: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    amount?: true
    GST?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    amount?: true
    GST?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    amount?: true
    GST?: true
    transaction_id?: true
    transaction_type?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    amount?: true
    GST?: true
    transaction_id?: true
    transaction_type?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    user_id?: true
    plan_id?: true
    amount?: true
    GST?: true
    transaction_id?: true
    transaction_type?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    user_id: number
    plan_id: number
    amount: Decimal
    GST: Decimal
    transaction_id: string
    transaction_type: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    amount?: boolean
    GST?: boolean
    transaction_id?: boolean
    transaction_type?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    tokentransaction?: boolean | Transaction$tokentransactionArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    user_id?: boolean
    plan_id?: boolean
    amount?: boolean
    GST?: boolean
    transaction_id?: boolean
    transaction_type?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    tokentransaction?: boolean | Transaction$tokentransactionArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      tokentransaction: Prisma.$Token_TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      plan_id: number
      amount: Prisma.Decimal
      GST: Prisma.Decimal
      transaction_id: string
      transaction_type: string
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }


  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tokentransaction<T extends Transaction$tokentransactionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$tokentransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly user_id: FieldRef<"Transaction", 'Int'>
    readonly plan_id: FieldRef<"Transaction", 'Int'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly GST: FieldRef<"Transaction", 'Decimal'>
    readonly transaction_id: FieldRef<"Transaction", 'String'>
    readonly transaction_type: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction.tokentransaction
   */
  export type Transaction$tokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    where?: Token_TransactionWhereInput
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    cursor?: Token_TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
  }



  /**
   * Model User_Plan
   */

  export type AggregateUser_Plan = {
    _count: User_PlanCountAggregateOutputType | null
    _avg: User_PlanAvgAggregateOutputType | null
    _sum: User_PlanSumAggregateOutputType | null
    _min: User_PlanMinAggregateOutputType | null
    _max: User_PlanMaxAggregateOutputType | null
  }

  export type User_PlanAvgAggregateOutputType = {
    plan_id: number | null
    user_id: number | null
  }

  export type User_PlanSumAggregateOutputType = {
    plan_id: number | null
    user_id: number | null
  }

  export type User_PlanMinAggregateOutputType = {
    plan_id: number | null
    user_id: number | null
    is_activate: boolean | null
  }

  export type User_PlanMaxAggregateOutputType = {
    plan_id: number | null
    user_id: number | null
    is_activate: boolean | null
  }

  export type User_PlanCountAggregateOutputType = {
    plan_id: number
    user_id: number
    is_activate: number
    _all: number
  }


  export type User_PlanAvgAggregateInputType = {
    plan_id?: true
    user_id?: true
  }

  export type User_PlanSumAggregateInputType = {
    plan_id?: true
    user_id?: true
  }

  export type User_PlanMinAggregateInputType = {
    plan_id?: true
    user_id?: true
    is_activate?: true
  }

  export type User_PlanMaxAggregateInputType = {
    plan_id?: true
    user_id?: true
    is_activate?: true
  }

  export type User_PlanCountAggregateInputType = {
    plan_id?: true
    user_id?: true
    is_activate?: true
    _all?: true
  }

  export type User_PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Plan to aggregate.
     */
    where?: User_PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Plans to fetch.
     */
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Plans
    **/
    _count?: true | User_PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_PlanMaxAggregateInputType
  }

  export type GetUser_PlanAggregateType<T extends User_PlanAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Plan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Plan[P]>
      : GetScalarType<T[P], AggregateUser_Plan[P]>
  }




  export type User_PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: User_PlanWhereInput
    orderBy?: User_PlanOrderByWithAggregationInput | User_PlanOrderByWithAggregationInput[]
    by: User_PlanScalarFieldEnum[] | User_PlanScalarFieldEnum
    having?: User_PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_PlanCountAggregateInputType | true
    _avg?: User_PlanAvgAggregateInputType
    _sum?: User_PlanSumAggregateInputType
    _min?: User_PlanMinAggregateInputType
    _max?: User_PlanMaxAggregateInputType
  }

  export type User_PlanGroupByOutputType = {
    plan_id: number
    user_id: number
    is_activate: boolean
    _count: User_PlanCountAggregateOutputType | null
    _avg: User_PlanAvgAggregateOutputType | null
    _sum: User_PlanSumAggregateOutputType | null
    _min: User_PlanMinAggregateOutputType | null
    _max: User_PlanMaxAggregateOutputType | null
  }

  type GetUser_PlanGroupByPayload<T extends User_PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_PlanGroupByOutputType[P]>
            : GetScalarType<T[P], User_PlanGroupByOutputType[P]>
        }
      >
    >


  export type User_PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    plan_id?: boolean
    user_id?: boolean
    is_activate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_Plan"]>

  export type User_PlanSelectScalar = {
    plan_id?: boolean
    user_id?: boolean
    is_activate?: boolean
  }

  export type User_PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }


  export type $User_PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User_Plan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      plan_id: number
      user_id: number
      is_activate: boolean
    }, ExtArgs["result"]["user_Plan"]>
    composites: {}
  }


  type User_PlanGetPayload<S extends boolean | null | undefined | User_PlanDefaultArgs> = $Result.GetResult<Prisma.$User_PlanPayload, S>

  type User_PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<User_PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_PlanCountAggregateInputType | true
    }

  export interface User_PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User_Plan'], meta: { name: 'User_Plan' } }
    /**
     * Find zero or one User_Plan that matches the filter.
     * @param {User_PlanFindUniqueArgs} args - Arguments to find a User_Plan
     * @example
     * // Get one User_Plan
     * const user_Plan = await prisma.user_Plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_PlanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanFindUniqueArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_Plan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {User_PlanFindUniqueOrThrowArgs} args - Arguments to find a User_Plan
     * @example
     * // Get one User_Plan
     * const user_Plan = await prisma.user_Plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends User_PlanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanFindFirstArgs} args - Arguments to find a User_Plan
     * @example
     * // Get one User_Plan
     * const user_Plan = await prisma.user_Plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_PlanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanFindFirstArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanFindFirstOrThrowArgs} args - Arguments to find a User_Plan
     * @example
     * // Get one User_Plan
     * const user_Plan = await prisma.user_Plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends User_PlanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Plans
     * const user_Plans = await prisma.user_Plan.findMany()
     * 
     * // Get first 10 User_Plans
     * const user_Plans = await prisma.user_Plan.findMany({ take: 10 })
     * 
     * // Only select the `plan_id`
     * const user_PlanWithPlan_idOnly = await prisma.user_Plan.findMany({ select: { plan_id: true } })
     * 
    **/
    findMany<T extends User_PlanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_Plan.
     * @param {User_PlanCreateArgs} args - Arguments to create a User_Plan.
     * @example
     * // Create one User_Plan
     * const User_Plan = await prisma.user_Plan.create({
     *   data: {
     *     // ... data to create a User_Plan
     *   }
     * })
     * 
    **/
    create<T extends User_PlanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanCreateArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_Plans.
     *     @param {User_PlanCreateManyArgs} args - Arguments to create many User_Plans.
     *     @example
     *     // Create many User_Plans
     *     const user_Plan = await prisma.user_Plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends User_PlanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_Plan.
     * @param {User_PlanDeleteArgs} args - Arguments to delete one User_Plan.
     * @example
     * // Delete one User_Plan
     * const User_Plan = await prisma.user_Plan.delete({
     *   where: {
     *     // ... filter to delete one User_Plan
     *   }
     * })
     * 
    **/
    delete<T extends User_PlanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanDeleteArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_Plan.
     * @param {User_PlanUpdateArgs} args - Arguments to update one User_Plan.
     * @example
     * // Update one User_Plan
     * const user_Plan = await prisma.user_Plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_PlanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanUpdateArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_Plans.
     * @param {User_PlanDeleteManyArgs} args - Arguments to filter User_Plans to delete.
     * @example
     * // Delete a few User_Plans
     * const { count } = await prisma.user_Plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_PlanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, User_PlanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Plans
     * const user_Plan = await prisma.user_Plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_PlanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_Plan.
     * @param {User_PlanUpsertArgs} args - Arguments to update or create a User_Plan.
     * @example
     * // Update or create a User_Plan
     * const user_Plan = await prisma.user_Plan.upsert({
     *   create: {
     *     // ... data to create a User_Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Plan we want to update
     *   }
     * })
    **/
    upsert<T extends User_PlanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, User_PlanUpsertArgs<ExtArgs>>
    ): Prisma__User_PlanClient<$Result.GetResult<Prisma.$User_PlanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanCountArgs} args - Arguments to filter User_Plans to count.
     * @example
     * // Count the number of User_Plans
     * const count = await prisma.user_Plan.count({
     *   where: {
     *     // ... the filter for the User_Plans we want to count
     *   }
     * })
    **/
    count<T extends User_PlanCountArgs>(
      args?: Subset<T, User_PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_PlanAggregateArgs>(args: Subset<T, User_PlanAggregateArgs>): Prisma.PrismaPromise<GetUser_PlanAggregateType<T>>

    /**
     * Group by User_Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_PlanGroupByArgs['orderBy'] }
        : { orderBy?: User_PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_PlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User_Plan model
   */
  readonly fields: User_PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__User_PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User_Plan model
   */ 
  interface User_PlanFieldRefs {
    readonly plan_id: FieldRef<"User_Plan", 'Int'>
    readonly user_id: FieldRef<"User_Plan", 'Int'>
    readonly is_activate: FieldRef<"User_Plan", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * User_Plan findUnique
   */
  export type User_PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter, which User_Plan to fetch.
     */
    where: User_PlanWhereUniqueInput
  }


  /**
   * User_Plan findUniqueOrThrow
   */
  export type User_PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter, which User_Plan to fetch.
     */
    where: User_PlanWhereUniqueInput
  }


  /**
   * User_Plan findFirst
   */
  export type User_PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter, which User_Plan to fetch.
     */
    where?: User_PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Plans to fetch.
     */
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Plans.
     */
    cursor?: User_PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Plans.
     */
    distinct?: User_PlanScalarFieldEnum | User_PlanScalarFieldEnum[]
  }


  /**
   * User_Plan findFirstOrThrow
   */
  export type User_PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter, which User_Plan to fetch.
     */
    where?: User_PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Plans to fetch.
     */
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Plans.
     */
    cursor?: User_PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Plans.
     */
    distinct?: User_PlanScalarFieldEnum | User_PlanScalarFieldEnum[]
  }


  /**
   * User_Plan findMany
   */
  export type User_PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter, which User_Plans to fetch.
     */
    where?: User_PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Plans to fetch.
     */
    orderBy?: User_PlanOrderByWithRelationInput | User_PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Plans.
     */
    cursor?: User_PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Plans.
     */
    skip?: number
    distinct?: User_PlanScalarFieldEnum | User_PlanScalarFieldEnum[]
  }


  /**
   * User_Plan create
   */
  export type User_PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a User_Plan.
     */
    data: XOR<User_PlanCreateInput, User_PlanUncheckedCreateInput>
  }


  /**
   * User_Plan createMany
   */
  export type User_PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many User_Plans.
     */
    data: User_PlanCreateManyInput | User_PlanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User_Plan update
   */
  export type User_PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a User_Plan.
     */
    data: XOR<User_PlanUpdateInput, User_PlanUncheckedUpdateInput>
    /**
     * Choose, which User_Plan to update.
     */
    where: User_PlanWhereUniqueInput
  }


  /**
   * User_Plan updateMany
   */
  export type User_PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update User_Plans.
     */
    data: XOR<User_PlanUpdateManyMutationInput, User_PlanUncheckedUpdateManyInput>
    /**
     * Filter which User_Plans to update
     */
    where?: User_PlanWhereInput
  }


  /**
   * User_Plan upsert
   */
  export type User_PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the User_Plan to update in case it exists.
     */
    where: User_PlanWhereUniqueInput
    /**
     * In case the User_Plan found by the `where` argument doesn't exist, create a new User_Plan with this data.
     */
    create: XOR<User_PlanCreateInput, User_PlanUncheckedCreateInput>
    /**
     * In case the User_Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_PlanUpdateInput, User_PlanUncheckedUpdateInput>
  }


  /**
   * User_Plan delete
   */
  export type User_PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
    /**
     * Filter which User_Plan to delete.
     */
    where: User_PlanWhereUniqueInput
  }


  /**
   * User_Plan deleteMany
   */
  export type User_PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User_Plans to delete
     */
    where?: User_PlanWhereInput
  }


  /**
   * User_Plan without action
   */
  export type User_PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_Plan
     */
    select?: User_PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_PlanInclude<ExtArgs> | null
  }



  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RoleSumAggregateOutputType = {
    role_id: number | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    role_name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    role_id?: true
  }

  export type RoleSumAggregateInputType = {
    role_id?: true
  }

  export type RoleMinAggregateInputType = {
    role_id?: true
    role_name?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: number
    role_name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    user?: boolean | Role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }


  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Role$userArgs<ExtArgs> = {}>(args?: Subset<T, Role$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly role_id: FieldRef<"Role", 'Int'>
    readonly role_name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.user
   */
  export type Role$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
  }



  /**
   * Model Sponsor
   */

  export type AggregateSponsor = {
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  export type SponsorAvgAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
    venue_id: number | null
  }

  export type SponsorSumAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
    venue_id: number | null
  }

  export type SponsorMinAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
    title: string | null
    description: string | null
    image_url: string | null
    start_time: string | null
    end_time: string | null
    venue_id: number | null
  }

  export type SponsorMaxAggregateOutputType = {
    sponsor_id: number | null
    event_id: number | null
    title: string | null
    description: string | null
    image_url: string | null
    start_time: string | null
    end_time: string | null
    venue_id: number | null
  }

  export type SponsorCountAggregateOutputType = {
    sponsor_id: number
    event_id: number
    title: number
    description: number
    image_url: number
    start_time: number
    end_time: number
    venue_id: number
    _all: number
  }


  export type SponsorAvgAggregateInputType = {
    sponsor_id?: true
    event_id?: true
    venue_id?: true
  }

  export type SponsorSumAggregateInputType = {
    sponsor_id?: true
    event_id?: true
    venue_id?: true
  }

  export type SponsorMinAggregateInputType = {
    sponsor_id?: true
    event_id?: true
    title?: true
    description?: true
    image_url?: true
    start_time?: true
    end_time?: true
    venue_id?: true
  }

  export type SponsorMaxAggregateInputType = {
    sponsor_id?: true
    event_id?: true
    title?: true
    description?: true
    image_url?: true
    start_time?: true
    end_time?: true
    venue_id?: true
  }

  export type SponsorCountAggregateInputType = {
    sponsor_id?: true
    event_id?: true
    title?: true
    description?: true
    image_url?: true
    start_time?: true
    end_time?: true
    venue_id?: true
    _all?: true
  }

  export type SponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsor to aggregate.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SponsorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SponsorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorMaxAggregateInputType
  }

  export type GetSponsorAggregateType<T extends SponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsor[P]>
      : GetScalarType<T[P], AggregateSponsor[P]>
  }




  export type SponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithAggregationInput | SponsorOrderByWithAggregationInput[]
    by: SponsorScalarFieldEnum[] | SponsorScalarFieldEnum
    having?: SponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorCountAggregateInputType | true
    _avg?: SponsorAvgAggregateInputType
    _sum?: SponsorSumAggregateInputType
    _min?: SponsorMinAggregateInputType
    _max?: SponsorMaxAggregateInputType
  }

  export type SponsorGroupByOutputType = {
    sponsor_id: number
    event_id: number
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
    _count: SponsorCountAggregateOutputType | null
    _avg: SponsorAvgAggregateOutputType | null
    _sum: SponsorSumAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  type GetSponsorGroupByPayload<T extends SponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorGroupByOutputType[P]>
        }
      >
    >


  export type SponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sponsor_id?: boolean
    event_id?: boolean
    title?: boolean
    description?: boolean
    image_url?: boolean
    start_time?: boolean
    end_time?: boolean
    venue_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sponsor"]>

  export type SponsorSelectScalar = {
    sponsor_id?: boolean
    event_id?: boolean
    title?: boolean
    description?: boolean
    image_url?: boolean
    start_time?: boolean
    end_time?: boolean
    venue_id?: boolean
  }

  export type SponsorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $SponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsor"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sponsor_id: number
      event_id: number
      title: string
      description: string
      image_url: string
      start_time: string
      end_time: string
      venue_id: number
    }, ExtArgs["result"]["sponsor"]>
    composites: {}
  }


  type SponsorGetPayload<S extends boolean | null | undefined | SponsorDefaultArgs> = $Result.GetResult<Prisma.$SponsorPayload, S>

  type SponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SponsorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SponsorCountAggregateInputType | true
    }

  export interface SponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsor'], meta: { name: 'Sponsor' } }
    /**
     * Find zero or one Sponsor that matches the filter.
     * @param {SponsorFindUniqueArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SponsorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorFindUniqueArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sponsor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SponsorFindUniqueOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SponsorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SponsorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorFindFirstArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SponsorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsor.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsor.findMany({ take: 10 })
     * 
     * // Only select the `sponsor_id`
     * const sponsorWithSponsor_idOnly = await prisma.sponsor.findMany({ select: { sponsor_id: true } })
     * 
    **/
    findMany<T extends SponsorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sponsor.
     * @param {SponsorCreateArgs} args - Arguments to create a Sponsor.
     * @example
     * // Create one Sponsor
     * const Sponsor = await prisma.sponsor.create({
     *   data: {
     *     // ... data to create a Sponsor
     *   }
     * })
     * 
    **/
    create<T extends SponsorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorCreateArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sponsors.
     *     @param {SponsorCreateManyArgs} args - Arguments to create many Sponsors.
     *     @example
     *     // Create many Sponsors
     *     const sponsor = await prisma.sponsor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SponsorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sponsor.
     * @param {SponsorDeleteArgs} args - Arguments to delete one Sponsor.
     * @example
     * // Delete one Sponsor
     * const Sponsor = await prisma.sponsor.delete({
     *   where: {
     *     // ... filter to delete one Sponsor
     *   }
     * })
     * 
    **/
    delete<T extends SponsorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorDeleteArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sponsor.
     * @param {SponsorUpdateArgs} args - Arguments to update one Sponsor.
     * @example
     * // Update one Sponsor
     * const sponsor = await prisma.sponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SponsorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorUpdateArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SponsorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SponsorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SponsorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sponsor.
     * @param {SponsorUpsertArgs} args - Arguments to update or create a Sponsor.
     * @example
     * // Update or create a Sponsor
     * const sponsor = await prisma.sponsor.upsert({
     *   create: {
     *     // ... data to create a Sponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsor we want to update
     *   }
     * })
    **/
    upsert<T extends SponsorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SponsorUpsertArgs<ExtArgs>>
    ): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsor.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorCountArgs>(
      args?: Subset<T, SponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorAggregateArgs>(args: Subset<T, SponsorAggregateArgs>): Prisma.PrismaPromise<GetSponsorAggregateType<T>>

    /**
     * Group by Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorGroupByArgs['orderBy'] }
        : { orderBy?: SponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsor model
   */
  readonly fields: SponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sponsor model
   */ 
  interface SponsorFieldRefs {
    readonly sponsor_id: FieldRef<"Sponsor", 'Int'>
    readonly event_id: FieldRef<"Sponsor", 'Int'>
    readonly title: FieldRef<"Sponsor", 'String'>
    readonly description: FieldRef<"Sponsor", 'String'>
    readonly image_url: FieldRef<"Sponsor", 'String'>
    readonly start_time: FieldRef<"Sponsor", 'String'>
    readonly end_time: FieldRef<"Sponsor", 'String'>
    readonly venue_id: FieldRef<"Sponsor", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Sponsor findUnique
   */
  export type SponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }


  /**
   * Sponsor findUniqueOrThrow
   */
  export type SponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }


  /**
   * Sponsor findFirst
   */
  export type SponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }


  /**
   * Sponsor findFirstOrThrow
   */
  export type SponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }


  /**
   * Sponsor findMany
   */
  export type SponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }


  /**
   * Sponsor create
   */
  export type SponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sponsor.
     */
    data: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
  }


  /**
   * Sponsor createMany
   */
  export type SponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Sponsor update
   */
  export type SponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sponsor.
     */
    data: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
    /**
     * Choose, which Sponsor to update.
     */
    where: SponsorWhereUniqueInput
  }


  /**
   * Sponsor updateMany
   */
  export type SponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
  }


  /**
   * Sponsor upsert
   */
  export type SponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sponsor to update in case it exists.
     */
    where: SponsorWhereUniqueInput
    /**
     * In case the Sponsor found by the `where` argument doesn't exist, create a new Sponsor with this data.
     */
    create: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
    /**
     * In case the Sponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
  }


  /**
   * Sponsor delete
   */
  export type SponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
    /**
     * Filter which Sponsor to delete.
     */
    where: SponsorWhereUniqueInput
  }


  /**
   * Sponsor deleteMany
   */
  export type SponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorWhereInput
  }


  /**
   * Sponsor without action
   */
  export type SponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SponsorInclude<ExtArgs> | null
  }



  /**
   * Model Advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    advertisement_id: number | null
    event_id: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    advertisement_id: number | null
    event_id: number | null
  }

  export type AdvertisementMinAggregateOutputType = {
    advertisement_id: number | null
    event_id: number | null
    title: string | null
    level: string | null
    start_date: Date | null
    end_date: Date | null
    image_url: string | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    advertisement_id: number | null
    event_id: number | null
    title: string | null
    level: string | null
    start_date: Date | null
    end_date: Date | null
    image_url: string | null
  }

  export type AdvertisementCountAggregateOutputType = {
    advertisement_id: number
    event_id: number
    title: number
    level: number
    start_date: number
    end_date: number
    image_url: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    advertisement_id?: true
    event_id?: true
  }

  export type AdvertisementSumAggregateInputType = {
    advertisement_id?: true
    event_id?: true
  }

  export type AdvertisementMinAggregateInputType = {
    advertisement_id?: true
    event_id?: true
    title?: true
    level?: true
    start_date?: true
    end_date?: true
    image_url?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    advertisement_id?: true
    event_id?: true
    title?: true
    level?: true
    start_date?: true
    end_date?: true
    image_url?: true
  }

  export type AdvertisementCountAggregateInputType = {
    advertisement_id?: true
    event_id?: true
    title?: true
    level?: true
    start_date?: true
    end_date?: true
    image_url?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisement to aggregate.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type AdvertisementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithAggregationInput | AdvertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: AdvertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    advertisement_id: number
    event_id: number
    title: string
    level: string
    start_date: Date
    end_date: Date
    image_url: string
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends AdvertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    advertisement_id?: boolean
    event_id?: boolean
    title?: boolean
    level?: boolean
    start_date?: boolean
    end_date?: boolean
    image_url?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectScalar = {
    advertisement_id?: boolean
    event_id?: boolean
    title?: boolean
    level?: boolean
    start_date?: boolean
    end_date?: boolean
    image_url?: boolean
  }

  export type AdvertisementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $AdvertisementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advertisement"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      advertisement_id: number
      event_id: number
      title: string
      level: string
      start_date: Date
      end_date: Date
      image_url: string
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }


  type AdvertisementGetPayload<S extends boolean | null | undefined | AdvertisementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisementPayload, S>

  type AdvertisementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvertisementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface AdvertisementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advertisement'], meta: { name: 'Advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {AdvertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvertisementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Advertisement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvertisementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvertisementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvertisementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `advertisement_id`
     * const advertisementWithAdvertisement_idOnly = await prisma.advertisement.findMany({ select: { advertisement_id: true } })
     * 
    **/
    findMany<T extends AdvertisementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Advertisement.
     * @param {AdvertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
    **/
    create<T extends AdvertisementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementCreateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Advertisements.
     *     @param {AdvertisementCreateManyArgs} args - Arguments to create many Advertisements.
     *     @example
     *     // Create many Advertisements
     *     const advertisement = await prisma.advertisement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvertisementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisement.
     * @param {AdvertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
    **/
    delete<T extends AdvertisementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementDeleteArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Advertisement.
     * @param {AdvertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvertisementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvertisementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvertisementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisement.
     * @param {AdvertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
    **/
    upsert<T extends AdvertisementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpsertArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementCountArgs>(
      args?: Subset<T, AdvertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advertisement model
   */
  readonly fields: AdvertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Advertisement model
   */ 
  interface AdvertisementFieldRefs {
    readonly advertisement_id: FieldRef<"Advertisement", 'Int'>
    readonly event_id: FieldRef<"Advertisement", 'Int'>
    readonly title: FieldRef<"Advertisement", 'String'>
    readonly level: FieldRef<"Advertisement", 'String'>
    readonly start_date: FieldRef<"Advertisement", 'DateTime'>
    readonly end_date: FieldRef<"Advertisement", 'DateTime'>
    readonly image_url: FieldRef<"Advertisement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Advertisement findUnique
   */
  export type AdvertisementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findUniqueOrThrow
   */
  export type AdvertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findFirst
   */
  export type AdvertisementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findFirstOrThrow
   */
  export type AdvertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findMany
   */
  export type AdvertisementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisements to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement create
   */
  export type AdvertisementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to create a Advertisement.
     */
    data: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
  }


  /**
   * Advertisement createMany
   */
  export type AdvertisementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Advertisement update
   */
  export type AdvertisementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to update a Advertisement.
     */
    data: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
    /**
     * Choose, which Advertisement to update.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement updateMany
   */
  export type AdvertisementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement upsert
   */
  export type AdvertisementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The filter to search for the Advertisement to update in case it exists.
     */
    where: AdvertisementWhereUniqueInput
    /**
     * In case the Advertisement found by the `where` argument doesn't exist, create a new Advertisement with this data.
     */
    create: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
    /**
     * In case the Advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
  }


  /**
   * Advertisement delete
   */
  export type AdvertisementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter which Advertisement to delete.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement deleteMany
   */
  export type AdvertisementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisements to delete
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement without action
   */
  export type AdvertisementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
  }



  /**
   * Model LostAndFound
   */

  export type AggregateLostAndFound = {
    _count: LostAndFoundCountAggregateOutputType | null
    _avg: LostAndFoundAvgAggregateOutputType | null
    _sum: LostAndFoundSumAggregateOutputType | null
    _min: LostAndFoundMinAggregateOutputType | null
    _max: LostAndFoundMaxAggregateOutputType | null
  }

  export type LostAndFoundAvgAggregateOutputType = {
    lost_and_found_id: number | null
    event_id: number | null
    claim_user_id: number | null
    reporter_user_id: number | null
  }

  export type LostAndFoundSumAggregateOutputType = {
    lost_and_found_id: number | null
    event_id: number | null
    claim_user_id: number | null
    reporter_user_id: number | null
  }

  export type LostAndFoundMinAggregateOutputType = {
    lost_and_found_id: number | null
    event_id: number | null
    item_name: string | null
    description: string | null
    is_claimed: boolean | null
    claim_user_id: number | null
    reporting_timestamp: Date | null
    claim_timestamp: Date | null
    reporter_user_id: number | null
  }

  export type LostAndFoundMaxAggregateOutputType = {
    lost_and_found_id: number | null
    event_id: number | null
    item_name: string | null
    description: string | null
    is_claimed: boolean | null
    claim_user_id: number | null
    reporting_timestamp: Date | null
    claim_timestamp: Date | null
    reporter_user_id: number | null
  }

  export type LostAndFoundCountAggregateOutputType = {
    lost_and_found_id: number
    event_id: number
    item_name: number
    description: number
    is_claimed: number
    claim_user_id: number
    reporting_timestamp: number
    claim_timestamp: number
    reporter_user_id: number
    _all: number
  }


  export type LostAndFoundAvgAggregateInputType = {
    lost_and_found_id?: true
    event_id?: true
    claim_user_id?: true
    reporter_user_id?: true
  }

  export type LostAndFoundSumAggregateInputType = {
    lost_and_found_id?: true
    event_id?: true
    claim_user_id?: true
    reporter_user_id?: true
  }

  export type LostAndFoundMinAggregateInputType = {
    lost_and_found_id?: true
    event_id?: true
    item_name?: true
    description?: true
    is_claimed?: true
    claim_user_id?: true
    reporting_timestamp?: true
    claim_timestamp?: true
    reporter_user_id?: true
  }

  export type LostAndFoundMaxAggregateInputType = {
    lost_and_found_id?: true
    event_id?: true
    item_name?: true
    description?: true
    is_claimed?: true
    claim_user_id?: true
    reporting_timestamp?: true
    claim_timestamp?: true
    reporter_user_id?: true
  }

  export type LostAndFoundCountAggregateInputType = {
    lost_and_found_id?: true
    event_id?: true
    item_name?: true
    description?: true
    is_claimed?: true
    claim_user_id?: true
    reporting_timestamp?: true
    claim_timestamp?: true
    reporter_user_id?: true
    _all?: true
  }

  export type LostAndFoundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LostAndFound to aggregate.
     */
    where?: LostAndFoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LostAndFounds to fetch.
     */
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LostAndFoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LostAndFounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LostAndFounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LostAndFounds
    **/
    _count?: true | LostAndFoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LostAndFoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LostAndFoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LostAndFoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LostAndFoundMaxAggregateInputType
  }

  export type GetLostAndFoundAggregateType<T extends LostAndFoundAggregateArgs> = {
        [P in keyof T & keyof AggregateLostAndFound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLostAndFound[P]>
      : GetScalarType<T[P], AggregateLostAndFound[P]>
  }




  export type LostAndFoundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LostAndFoundWhereInput
    orderBy?: LostAndFoundOrderByWithAggregationInput | LostAndFoundOrderByWithAggregationInput[]
    by: LostAndFoundScalarFieldEnum[] | LostAndFoundScalarFieldEnum
    having?: LostAndFoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LostAndFoundCountAggregateInputType | true
    _avg?: LostAndFoundAvgAggregateInputType
    _sum?: LostAndFoundSumAggregateInputType
    _min?: LostAndFoundMinAggregateInputType
    _max?: LostAndFoundMaxAggregateInputType
  }

  export type LostAndFoundGroupByOutputType = {
    lost_and_found_id: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date
    claim_timestamp: Date
    reporter_user_id: number
    _count: LostAndFoundCountAggregateOutputType | null
    _avg: LostAndFoundAvgAggregateOutputType | null
    _sum: LostAndFoundSumAggregateOutputType | null
    _min: LostAndFoundMinAggregateOutputType | null
    _max: LostAndFoundMaxAggregateOutputType | null
  }

  type GetLostAndFoundGroupByPayload<T extends LostAndFoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LostAndFoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LostAndFoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LostAndFoundGroupByOutputType[P]>
            : GetScalarType<T[P], LostAndFoundGroupByOutputType[P]>
        }
      >
    >


  export type LostAndFoundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lost_and_found_id?: boolean
    event_id?: boolean
    item_name?: boolean
    description?: boolean
    is_claimed?: boolean
    claim_user_id?: boolean
    reporting_timestamp?: boolean
    claim_timestamp?: boolean
    reporter_user_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    claim_user?: boolean | UserDefaultArgs<ExtArgs>
    reporter_user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lostAndFound"]>

  export type LostAndFoundSelectScalar = {
    lost_and_found_id?: boolean
    event_id?: boolean
    item_name?: boolean
    description?: boolean
    is_claimed?: boolean
    claim_user_id?: boolean
    reporting_timestamp?: boolean
    claim_timestamp?: boolean
    reporter_user_id?: boolean
  }

  export type LostAndFoundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    claim_user?: boolean | UserDefaultArgs<ExtArgs>
    reporter_user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $LostAndFoundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LostAndFound"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      claim_user: Prisma.$UserPayload<ExtArgs>
      reporter_user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lost_and_found_id: number
      event_id: number
      item_name: string
      description: string
      is_claimed: boolean
      claim_user_id: number
      reporting_timestamp: Date
      claim_timestamp: Date
      reporter_user_id: number
    }, ExtArgs["result"]["lostAndFound"]>
    composites: {}
  }


  type LostAndFoundGetPayload<S extends boolean | null | undefined | LostAndFoundDefaultArgs> = $Result.GetResult<Prisma.$LostAndFoundPayload, S>

  type LostAndFoundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LostAndFoundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LostAndFoundCountAggregateInputType | true
    }

  export interface LostAndFoundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LostAndFound'], meta: { name: 'LostAndFound' } }
    /**
     * Find zero or one LostAndFound that matches the filter.
     * @param {LostAndFoundFindUniqueArgs} args - Arguments to find a LostAndFound
     * @example
     * // Get one LostAndFound
     * const lostAndFound = await prisma.lostAndFound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LostAndFoundFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundFindUniqueArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LostAndFound that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LostAndFoundFindUniqueOrThrowArgs} args - Arguments to find a LostAndFound
     * @example
     * // Get one LostAndFound
     * const lostAndFound = await prisma.lostAndFound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LostAndFoundFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LostAndFound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundFindFirstArgs} args - Arguments to find a LostAndFound
     * @example
     * // Get one LostAndFound
     * const lostAndFound = await prisma.lostAndFound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LostAndFoundFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundFindFirstArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LostAndFound that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundFindFirstOrThrowArgs} args - Arguments to find a LostAndFound
     * @example
     * // Get one LostAndFound
     * const lostAndFound = await prisma.lostAndFound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LostAndFoundFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LostAndFounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LostAndFounds
     * const lostAndFounds = await prisma.lostAndFound.findMany()
     * 
     * // Get first 10 LostAndFounds
     * const lostAndFounds = await prisma.lostAndFound.findMany({ take: 10 })
     * 
     * // Only select the `lost_and_found_id`
     * const lostAndFoundWithLost_and_found_idOnly = await prisma.lostAndFound.findMany({ select: { lost_and_found_id: true } })
     * 
    **/
    findMany<T extends LostAndFoundFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LostAndFound.
     * @param {LostAndFoundCreateArgs} args - Arguments to create a LostAndFound.
     * @example
     * // Create one LostAndFound
     * const LostAndFound = await prisma.lostAndFound.create({
     *   data: {
     *     // ... data to create a LostAndFound
     *   }
     * })
     * 
    **/
    create<T extends LostAndFoundCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundCreateArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LostAndFounds.
     *     @param {LostAndFoundCreateManyArgs} args - Arguments to create many LostAndFounds.
     *     @example
     *     // Create many LostAndFounds
     *     const lostAndFound = await prisma.lostAndFound.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LostAndFoundCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LostAndFound.
     * @param {LostAndFoundDeleteArgs} args - Arguments to delete one LostAndFound.
     * @example
     * // Delete one LostAndFound
     * const LostAndFound = await prisma.lostAndFound.delete({
     *   where: {
     *     // ... filter to delete one LostAndFound
     *   }
     * })
     * 
    **/
    delete<T extends LostAndFoundDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundDeleteArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LostAndFound.
     * @param {LostAndFoundUpdateArgs} args - Arguments to update one LostAndFound.
     * @example
     * // Update one LostAndFound
     * const lostAndFound = await prisma.lostAndFound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LostAndFoundUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundUpdateArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LostAndFounds.
     * @param {LostAndFoundDeleteManyArgs} args - Arguments to filter LostAndFounds to delete.
     * @example
     * // Delete a few LostAndFounds
     * const { count } = await prisma.lostAndFound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LostAndFoundDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LostAndFoundDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LostAndFounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LostAndFounds
     * const lostAndFound = await prisma.lostAndFound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LostAndFoundUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LostAndFound.
     * @param {LostAndFoundUpsertArgs} args - Arguments to update or create a LostAndFound.
     * @example
     * // Update or create a LostAndFound
     * const lostAndFound = await prisma.lostAndFound.upsert({
     *   create: {
     *     // ... data to create a LostAndFound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LostAndFound we want to update
     *   }
     * })
    **/
    upsert<T extends LostAndFoundUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LostAndFoundUpsertArgs<ExtArgs>>
    ): Prisma__LostAndFoundClient<$Result.GetResult<Prisma.$LostAndFoundPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LostAndFounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundCountArgs} args - Arguments to filter LostAndFounds to count.
     * @example
     * // Count the number of LostAndFounds
     * const count = await prisma.lostAndFound.count({
     *   where: {
     *     // ... the filter for the LostAndFounds we want to count
     *   }
     * })
    **/
    count<T extends LostAndFoundCountArgs>(
      args?: Subset<T, LostAndFoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LostAndFoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LostAndFound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LostAndFoundAggregateArgs>(args: Subset<T, LostAndFoundAggregateArgs>): Prisma.PrismaPromise<GetLostAndFoundAggregateType<T>>

    /**
     * Group by LostAndFound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LostAndFoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LostAndFoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LostAndFoundGroupByArgs['orderBy'] }
        : { orderBy?: LostAndFoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LostAndFoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLostAndFoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LostAndFound model
   */
  readonly fields: LostAndFoundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LostAndFound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LostAndFoundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claim_user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reporter_user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LostAndFound model
   */ 
  interface LostAndFoundFieldRefs {
    readonly lost_and_found_id: FieldRef<"LostAndFound", 'Int'>
    readonly event_id: FieldRef<"LostAndFound", 'Int'>
    readonly item_name: FieldRef<"LostAndFound", 'String'>
    readonly description: FieldRef<"LostAndFound", 'String'>
    readonly is_claimed: FieldRef<"LostAndFound", 'Boolean'>
    readonly claim_user_id: FieldRef<"LostAndFound", 'Int'>
    readonly reporting_timestamp: FieldRef<"LostAndFound", 'DateTime'>
    readonly claim_timestamp: FieldRef<"LostAndFound", 'DateTime'>
    readonly reporter_user_id: FieldRef<"LostAndFound", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LostAndFound findUnique
   */
  export type LostAndFoundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter, which LostAndFound to fetch.
     */
    where: LostAndFoundWhereUniqueInput
  }


  /**
   * LostAndFound findUniqueOrThrow
   */
  export type LostAndFoundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter, which LostAndFound to fetch.
     */
    where: LostAndFoundWhereUniqueInput
  }


  /**
   * LostAndFound findFirst
   */
  export type LostAndFoundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter, which LostAndFound to fetch.
     */
    where?: LostAndFoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LostAndFounds to fetch.
     */
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LostAndFounds.
     */
    cursor?: LostAndFoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LostAndFounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LostAndFounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LostAndFounds.
     */
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * LostAndFound findFirstOrThrow
   */
  export type LostAndFoundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter, which LostAndFound to fetch.
     */
    where?: LostAndFoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LostAndFounds to fetch.
     */
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LostAndFounds.
     */
    cursor?: LostAndFoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LostAndFounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LostAndFounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LostAndFounds.
     */
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * LostAndFound findMany
   */
  export type LostAndFoundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter, which LostAndFounds to fetch.
     */
    where?: LostAndFoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LostAndFounds to fetch.
     */
    orderBy?: LostAndFoundOrderByWithRelationInput | LostAndFoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LostAndFounds.
     */
    cursor?: LostAndFoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LostAndFounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LostAndFounds.
     */
    skip?: number
    distinct?: LostAndFoundScalarFieldEnum | LostAndFoundScalarFieldEnum[]
  }


  /**
   * LostAndFound create
   */
  export type LostAndFoundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * The data needed to create a LostAndFound.
     */
    data: XOR<LostAndFoundCreateInput, LostAndFoundUncheckedCreateInput>
  }


  /**
   * LostAndFound createMany
   */
  export type LostAndFoundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LostAndFounds.
     */
    data: LostAndFoundCreateManyInput | LostAndFoundCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LostAndFound update
   */
  export type LostAndFoundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * The data needed to update a LostAndFound.
     */
    data: XOR<LostAndFoundUpdateInput, LostAndFoundUncheckedUpdateInput>
    /**
     * Choose, which LostAndFound to update.
     */
    where: LostAndFoundWhereUniqueInput
  }


  /**
   * LostAndFound updateMany
   */
  export type LostAndFoundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LostAndFounds.
     */
    data: XOR<LostAndFoundUpdateManyMutationInput, LostAndFoundUncheckedUpdateManyInput>
    /**
     * Filter which LostAndFounds to update
     */
    where?: LostAndFoundWhereInput
  }


  /**
   * LostAndFound upsert
   */
  export type LostAndFoundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * The filter to search for the LostAndFound to update in case it exists.
     */
    where: LostAndFoundWhereUniqueInput
    /**
     * In case the LostAndFound found by the `where` argument doesn't exist, create a new LostAndFound with this data.
     */
    create: XOR<LostAndFoundCreateInput, LostAndFoundUncheckedCreateInput>
    /**
     * In case the LostAndFound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LostAndFoundUpdateInput, LostAndFoundUncheckedUpdateInput>
  }


  /**
   * LostAndFound delete
   */
  export type LostAndFoundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
    /**
     * Filter which LostAndFound to delete.
     */
    where: LostAndFoundWhereUniqueInput
  }


  /**
   * LostAndFound deleteMany
   */
  export type LostAndFoundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LostAndFounds to delete
     */
    where?: LostAndFoundWhereInput
  }


  /**
   * LostAndFound without action
   */
  export type LostAndFoundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LostAndFound
     */
    select?: LostAndFoundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LostAndFoundInclude<ExtArgs> | null
  }



  /**
   * Model EventMap
   */

  export type AggregateEventMap = {
    _count: EventMapCountAggregateOutputType | null
    _avg: EventMapAvgAggregateOutputType | null
    _sum: EventMapSumAggregateOutputType | null
    _min: EventMapMinAggregateOutputType | null
    _max: EventMapMaxAggregateOutputType | null
  }

  export type EventMapAvgAggregateOutputType = {
    event_map_id: number | null
    event_id: number | null
  }

  export type EventMapSumAggregateOutputType = {
    event_map_id: number | null
    event_id: number | null
  }

  export type EventMapMinAggregateOutputType = {
    event_map_id: number | null
    map_object: string | null
    event_id: number | null
  }

  export type EventMapMaxAggregateOutputType = {
    event_map_id: number | null
    map_object: string | null
    event_id: number | null
  }

  export type EventMapCountAggregateOutputType = {
    event_map_id: number
    map_object: number
    event_id: number
    _all: number
  }


  export type EventMapAvgAggregateInputType = {
    event_map_id?: true
    event_id?: true
  }

  export type EventMapSumAggregateInputType = {
    event_map_id?: true
    event_id?: true
  }

  export type EventMapMinAggregateInputType = {
    event_map_id?: true
    map_object?: true
    event_id?: true
  }

  export type EventMapMaxAggregateInputType = {
    event_map_id?: true
    map_object?: true
    event_id?: true
  }

  export type EventMapCountAggregateInputType = {
    event_map_id?: true
    map_object?: true
    event_id?: true
    _all?: true
  }

  export type EventMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventMap to aggregate.
     */
    where?: EventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventMaps to fetch.
     */
    orderBy?: EventMapOrderByWithRelationInput | EventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventMaps
    **/
    _count?: true | EventMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMapMaxAggregateInputType
  }

  export type GetEventMapAggregateType<T extends EventMapAggregateArgs> = {
        [P in keyof T & keyof AggregateEventMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventMap[P]>
      : GetScalarType<T[P], AggregateEventMap[P]>
  }




  export type EventMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventMapWhereInput
    orderBy?: EventMapOrderByWithAggregationInput | EventMapOrderByWithAggregationInput[]
    by: EventMapScalarFieldEnum[] | EventMapScalarFieldEnum
    having?: EventMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventMapCountAggregateInputType | true
    _avg?: EventMapAvgAggregateInputType
    _sum?: EventMapSumAggregateInputType
    _min?: EventMapMinAggregateInputType
    _max?: EventMapMaxAggregateInputType
  }

  export type EventMapGroupByOutputType = {
    event_map_id: number
    map_object: string
    event_id: number
    _count: EventMapCountAggregateOutputType | null
    _avg: EventMapAvgAggregateOutputType | null
    _sum: EventMapSumAggregateOutputType | null
    _min: EventMapMinAggregateOutputType | null
    _max: EventMapMaxAggregateOutputType | null
  }

  type GetEventMapGroupByPayload<T extends EventMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventMapGroupByOutputType[P]>
            : GetScalarType<T[P], EventMapGroupByOutputType[P]>
        }
      >
    >


  export type EventMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_map_id?: boolean
    map_object?: boolean
    event_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventMap"]>

  export type EventMapSelectScalar = {
    event_map_id?: boolean
    map_object?: boolean
    event_id?: boolean
  }

  export type EventMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $EventMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventMap"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_map_id: number
      map_object: string
      event_id: number
    }, ExtArgs["result"]["eventMap"]>
    composites: {}
  }


  type EventMapGetPayload<S extends boolean | null | undefined | EventMapDefaultArgs> = $Result.GetResult<Prisma.$EventMapPayload, S>

  type EventMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventMapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventMapCountAggregateInputType | true
    }

  export interface EventMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventMap'], meta: { name: 'EventMap' } }
    /**
     * Find zero or one EventMap that matches the filter.
     * @param {EventMapFindUniqueArgs} args - Arguments to find a EventMap
     * @example
     * // Get one EventMap
     * const eventMap = await prisma.eventMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventMapFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapFindUniqueArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EventMap that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventMapFindUniqueOrThrowArgs} args - Arguments to find a EventMap
     * @example
     * // Get one EventMap
     * const eventMap = await prisma.eventMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventMapFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EventMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapFindFirstArgs} args - Arguments to find a EventMap
     * @example
     * // Get one EventMap
     * const eventMap = await prisma.eventMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventMapFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapFindFirstArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EventMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapFindFirstOrThrowArgs} args - Arguments to find a EventMap
     * @example
     * // Get one EventMap
     * const eventMap = await prisma.eventMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventMapFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EventMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventMaps
     * const eventMaps = await prisma.eventMap.findMany()
     * 
     * // Get first 10 EventMaps
     * const eventMaps = await prisma.eventMap.findMany({ take: 10 })
     * 
     * // Only select the `event_map_id`
     * const eventMapWithEvent_map_idOnly = await prisma.eventMap.findMany({ select: { event_map_id: true } })
     * 
    **/
    findMany<T extends EventMapFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EventMap.
     * @param {EventMapCreateArgs} args - Arguments to create a EventMap.
     * @example
     * // Create one EventMap
     * const EventMap = await prisma.eventMap.create({
     *   data: {
     *     // ... data to create a EventMap
     *   }
     * })
     * 
    **/
    create<T extends EventMapCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapCreateArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EventMaps.
     *     @param {EventMapCreateManyArgs} args - Arguments to create many EventMaps.
     *     @example
     *     // Create many EventMaps
     *     const eventMap = await prisma.eventMap.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventMapCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventMap.
     * @param {EventMapDeleteArgs} args - Arguments to delete one EventMap.
     * @example
     * // Delete one EventMap
     * const EventMap = await prisma.eventMap.delete({
     *   where: {
     *     // ... filter to delete one EventMap
     *   }
     * })
     * 
    **/
    delete<T extends EventMapDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapDeleteArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EventMap.
     * @param {EventMapUpdateArgs} args - Arguments to update one EventMap.
     * @example
     * // Update one EventMap
     * const eventMap = await prisma.eventMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventMapUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapUpdateArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EventMaps.
     * @param {EventMapDeleteManyArgs} args - Arguments to filter EventMaps to delete.
     * @example
     * // Delete a few EventMaps
     * const { count } = await prisma.eventMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventMapDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventMapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventMaps
     * const eventMap = await prisma.eventMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventMapUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventMap.
     * @param {EventMapUpsertArgs} args - Arguments to update or create a EventMap.
     * @example
     * // Update or create a EventMap
     * const eventMap = await prisma.eventMap.upsert({
     *   create: {
     *     // ... data to create a EventMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventMap we want to update
     *   }
     * })
    **/
    upsert<T extends EventMapUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventMapUpsertArgs<ExtArgs>>
    ): Prisma__EventMapClient<$Result.GetResult<Prisma.$EventMapPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EventMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapCountArgs} args - Arguments to filter EventMaps to count.
     * @example
     * // Count the number of EventMaps
     * const count = await prisma.eventMap.count({
     *   where: {
     *     // ... the filter for the EventMaps we want to count
     *   }
     * })
    **/
    count<T extends EventMapCountArgs>(
      args?: Subset<T, EventMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventMapAggregateArgs>(args: Subset<T, EventMapAggregateArgs>): Prisma.PrismaPromise<GetEventMapAggregateType<T>>

    /**
     * Group by EventMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventMapGroupByArgs['orderBy'] }
        : { orderBy?: EventMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventMap model
   */
  readonly fields: EventMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EventMap model
   */ 
  interface EventMapFieldRefs {
    readonly event_map_id: FieldRef<"EventMap", 'Int'>
    readonly map_object: FieldRef<"EventMap", 'String'>
    readonly event_id: FieldRef<"EventMap", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EventMap findUnique
   */
  export type EventMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter, which EventMap to fetch.
     */
    where: EventMapWhereUniqueInput
  }


  /**
   * EventMap findUniqueOrThrow
   */
  export type EventMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter, which EventMap to fetch.
     */
    where: EventMapWhereUniqueInput
  }


  /**
   * EventMap findFirst
   */
  export type EventMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter, which EventMap to fetch.
     */
    where?: EventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventMaps to fetch.
     */
    orderBy?: EventMapOrderByWithRelationInput | EventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventMaps.
     */
    cursor?: EventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventMaps.
     */
    distinct?: EventMapScalarFieldEnum | EventMapScalarFieldEnum[]
  }


  /**
   * EventMap findFirstOrThrow
   */
  export type EventMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter, which EventMap to fetch.
     */
    where?: EventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventMaps to fetch.
     */
    orderBy?: EventMapOrderByWithRelationInput | EventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventMaps.
     */
    cursor?: EventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventMaps.
     */
    distinct?: EventMapScalarFieldEnum | EventMapScalarFieldEnum[]
  }


  /**
   * EventMap findMany
   */
  export type EventMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter, which EventMaps to fetch.
     */
    where?: EventMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventMaps to fetch.
     */
    orderBy?: EventMapOrderByWithRelationInput | EventMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventMaps.
     */
    cursor?: EventMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventMaps.
     */
    skip?: number
    distinct?: EventMapScalarFieldEnum | EventMapScalarFieldEnum[]
  }


  /**
   * EventMap create
   */
  export type EventMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * The data needed to create a EventMap.
     */
    data: XOR<EventMapCreateInput, EventMapUncheckedCreateInput>
  }


  /**
   * EventMap createMany
   */
  export type EventMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventMaps.
     */
    data: EventMapCreateManyInput | EventMapCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EventMap update
   */
  export type EventMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * The data needed to update a EventMap.
     */
    data: XOR<EventMapUpdateInput, EventMapUncheckedUpdateInput>
    /**
     * Choose, which EventMap to update.
     */
    where: EventMapWhereUniqueInput
  }


  /**
   * EventMap updateMany
   */
  export type EventMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventMaps.
     */
    data: XOR<EventMapUpdateManyMutationInput, EventMapUncheckedUpdateManyInput>
    /**
     * Filter which EventMaps to update
     */
    where?: EventMapWhereInput
  }


  /**
   * EventMap upsert
   */
  export type EventMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * The filter to search for the EventMap to update in case it exists.
     */
    where: EventMapWhereUniqueInput
    /**
     * In case the EventMap found by the `where` argument doesn't exist, create a new EventMap with this data.
     */
    create: XOR<EventMapCreateInput, EventMapUncheckedCreateInput>
    /**
     * In case the EventMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventMapUpdateInput, EventMapUncheckedUpdateInput>
  }


  /**
   * EventMap delete
   */
  export type EventMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
    /**
     * Filter which EventMap to delete.
     */
    where: EventMapWhereUniqueInput
  }


  /**
   * EventMap deleteMany
   */
  export type EventMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventMaps to delete
     */
    where?: EventMapWhereInput
  }


  /**
   * EventMap without action
   */
  export type EventMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventMap
     */
    select?: EventMapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventMapInclude<ExtArgs> | null
  }



  /**
   * Model Shops
   */

  export type AggregateShops = {
    _count: ShopsCountAggregateOutputType | null
    _avg: ShopsAvgAggregateOutputType | null
    _sum: ShopsSumAggregateOutputType | null
    _min: ShopsMinAggregateOutputType | null
    _max: ShopsMaxAggregateOutputType | null
  }

  export type ShopsAvgAggregateOutputType = {
    shop_id: number | null
    event_id: number | null
  }

  export type ShopsSumAggregateOutputType = {
    shop_id: number | null
    event_id: number | null
  }

  export type ShopsMinAggregateOutputType = {
    shop_id: number | null
    shop_name: string | null
    event_id: number | null
    shop_type: string | null
  }

  export type ShopsMaxAggregateOutputType = {
    shop_id: number | null
    shop_name: string | null
    event_id: number | null
    shop_type: string | null
  }

  export type ShopsCountAggregateOutputType = {
    shop_id: number
    shop_name: number
    event_id: number
    shop_type: number
    _all: number
  }


  export type ShopsAvgAggregateInputType = {
    shop_id?: true
    event_id?: true
  }

  export type ShopsSumAggregateInputType = {
    shop_id?: true
    event_id?: true
  }

  export type ShopsMinAggregateInputType = {
    shop_id?: true
    shop_name?: true
    event_id?: true
    shop_type?: true
  }

  export type ShopsMaxAggregateInputType = {
    shop_id?: true
    shop_name?: true
    event_id?: true
    shop_type?: true
  }

  export type ShopsCountAggregateInputType = {
    shop_id?: true
    shop_name?: true
    event_id?: true
    shop_type?: true
    _all?: true
  }

  export type ShopsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to aggregate.
     */
    where?: ShopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopsOrderByWithRelationInput | ShopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopsMaxAggregateInputType
  }

  export type GetShopsAggregateType<T extends ShopsAggregateArgs> = {
        [P in keyof T & keyof AggregateShops]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShops[P]>
      : GetScalarType<T[P], AggregateShops[P]>
  }




  export type ShopsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopsWhereInput
    orderBy?: ShopsOrderByWithAggregationInput | ShopsOrderByWithAggregationInput[]
    by: ShopsScalarFieldEnum[] | ShopsScalarFieldEnum
    having?: ShopsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopsCountAggregateInputType | true
    _avg?: ShopsAvgAggregateInputType
    _sum?: ShopsSumAggregateInputType
    _min?: ShopsMinAggregateInputType
    _max?: ShopsMaxAggregateInputType
  }

  export type ShopsGroupByOutputType = {
    shop_id: number
    shop_name: string
    event_id: number
    shop_type: string
    _count: ShopsCountAggregateOutputType | null
    _avg: ShopsAvgAggregateOutputType | null
    _sum: ShopsSumAggregateOutputType | null
    _min: ShopsMinAggregateOutputType | null
    _max: ShopsMaxAggregateOutputType | null
  }

  type GetShopsGroupByPayload<T extends ShopsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopsGroupByOutputType[P]>
            : GetScalarType<T[P], ShopsGroupByOutputType[P]>
        }
      >
    >


  export type ShopsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shop_id?: boolean
    shop_name?: boolean
    event_id?: boolean
    shop_type?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    shoppayment?: boolean | Shops$shoppaymentArgs<ExtArgs>
    tokentransaction?: boolean | Shops$tokentransactionArgs<ExtArgs>
    _count?: boolean | ShopsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shops"]>

  export type ShopsSelectScalar = {
    shop_id?: boolean
    shop_name?: boolean
    event_id?: boolean
    shop_type?: boolean
  }

  export type ShopsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    shoppayment?: boolean | Shops$shoppaymentArgs<ExtArgs>
    tokentransaction?: boolean | Shops$tokentransactionArgs<ExtArgs>
    _count?: boolean | ShopsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ShopsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shops"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      shoppayment: Prisma.$ShopPaymentPayload<ExtArgs>[]
      tokentransaction: Prisma.$Token_TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shop_id: number
      shop_name: string
      event_id: number
      shop_type: string
    }, ExtArgs["result"]["shops"]>
    composites: {}
  }


  type ShopsGetPayload<S extends boolean | null | undefined | ShopsDefaultArgs> = $Result.GetResult<Prisma.$ShopsPayload, S>

  type ShopsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopsCountAggregateInputType | true
    }

  export interface ShopsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shops'], meta: { name: 'Shops' } }
    /**
     * Find zero or one Shops that matches the filter.
     * @param {ShopsFindUniqueArgs} args - Arguments to find a Shops
     * @example
     * // Get one Shops
     * const shops = await prisma.shops.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Shops that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopsFindUniqueOrThrowArgs} args - Arguments to find a Shops
     * @example
     * // Get one Shops
     * const shops = await prisma.shops.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsFindFirstArgs} args - Arguments to find a Shops
     * @example
     * // Get one Shops
     * const shops = await prisma.shops.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsFindFirstArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Shops that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsFindFirstOrThrowArgs} args - Arguments to find a Shops
     * @example
     * // Get one Shops
     * const shops = await prisma.shops.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shops.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shops.findMany({ take: 10 })
     * 
     * // Only select the `shop_id`
     * const shopsWithShop_idOnly = await prisma.shops.findMany({ select: { shop_id: true } })
     * 
    **/
    findMany<T extends ShopsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Shops.
     * @param {ShopsCreateArgs} args - Arguments to create a Shops.
     * @example
     * // Create one Shops
     * const Shops = await prisma.shops.create({
     *   data: {
     *     // ... data to create a Shops
     *   }
     * })
     * 
    **/
    create<T extends ShopsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsCreateArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Shops.
     *     @param {ShopsCreateManyArgs} args - Arguments to create many Shops.
     *     @example
     *     // Create many Shops
     *     const shops = await prisma.shops.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shops.
     * @param {ShopsDeleteArgs} args - Arguments to delete one Shops.
     * @example
     * // Delete one Shops
     * const Shops = await prisma.shops.delete({
     *   where: {
     *     // ... filter to delete one Shops
     *   }
     * })
     * 
    **/
    delete<T extends ShopsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsDeleteArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Shops.
     * @param {ShopsUpdateArgs} args - Arguments to update one Shops.
     * @example
     * // Update one Shops
     * const shops = await prisma.shops.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsUpdateArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Shops.
     * @param {ShopsDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shops.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shops = await prisma.shops.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shops.
     * @param {ShopsUpsertArgs} args - Arguments to update or create a Shops.
     * @example
     * // Update or create a Shops
     * const shops = await prisma.shops.upsert({
     *   create: {
     *     // ... data to create a Shops
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shops we want to update
     *   }
     * })
    **/
    upsert<T extends ShopsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopsUpsertArgs<ExtArgs>>
    ): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shops.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopsCountArgs>(
      args?: Subset<T, ShopsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopsAggregateArgs>(args: Subset<T, ShopsAggregateArgs>): Prisma.PrismaPromise<GetShopsAggregateType<T>>

    /**
     * Group by Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopsGroupByArgs['orderBy'] }
        : { orderBy?: ShopsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shops model
   */
  readonly fields: ShopsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shops.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shoppayment<T extends Shops$shoppaymentArgs<ExtArgs> = {}>(args?: Subset<T, Shops$shoppaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    tokentransaction<T extends Shops$tokentransactionArgs<ExtArgs> = {}>(args?: Subset<T, Shops$tokentransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Shops model
   */ 
  interface ShopsFieldRefs {
    readonly shop_id: FieldRef<"Shops", 'Int'>
    readonly shop_name: FieldRef<"Shops", 'String'>
    readonly event_id: FieldRef<"Shops", 'Int'>
    readonly shop_type: FieldRef<"Shops", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Shops findUnique
   */
  export type ShopsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where: ShopsWhereUniqueInput
  }


  /**
   * Shops findUniqueOrThrow
   */
  export type ShopsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where: ShopsWhereUniqueInput
  }


  /**
   * Shops findFirst
   */
  export type ShopsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopsOrderByWithRelationInput | ShopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopsScalarFieldEnum | ShopsScalarFieldEnum[]
  }


  /**
   * Shops findFirstOrThrow
   */
  export type ShopsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopsOrderByWithRelationInput | ShopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopsScalarFieldEnum | ShopsScalarFieldEnum[]
  }


  /**
   * Shops findMany
   */
  export type ShopsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopsOrderByWithRelationInput | ShopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopsScalarFieldEnum | ShopsScalarFieldEnum[]
  }


  /**
   * Shops create
   */
  export type ShopsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * The data needed to create a Shops.
     */
    data: XOR<ShopsCreateInput, ShopsUncheckedCreateInput>
  }


  /**
   * Shops createMany
   */
  export type ShopsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopsCreateManyInput | ShopsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Shops update
   */
  export type ShopsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * The data needed to update a Shops.
     */
    data: XOR<ShopsUpdateInput, ShopsUncheckedUpdateInput>
    /**
     * Choose, which Shops to update.
     */
    where: ShopsWhereUniqueInput
  }


  /**
   * Shops updateMany
   */
  export type ShopsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopsUpdateManyMutationInput, ShopsUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopsWhereInput
  }


  /**
   * Shops upsert
   */
  export type ShopsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * The filter to search for the Shops to update in case it exists.
     */
    where: ShopsWhereUniqueInput
    /**
     * In case the Shops found by the `where` argument doesn't exist, create a new Shops with this data.
     */
    create: XOR<ShopsCreateInput, ShopsUncheckedCreateInput>
    /**
     * In case the Shops was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopsUpdateInput, ShopsUncheckedUpdateInput>
  }


  /**
   * Shops delete
   */
  export type ShopsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
    /**
     * Filter which Shops to delete.
     */
    where: ShopsWhereUniqueInput
  }


  /**
   * Shops deleteMany
   */
  export type ShopsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopsWhereInput
  }


  /**
   * Shops.shoppayment
   */
  export type Shops$shoppaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    where?: ShopPaymentWhereInput
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    cursor?: ShopPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * Shops.tokentransaction
   */
  export type Shops$tokentransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    where?: Token_TransactionWhereInput
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    cursor?: Token_TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Shops without action
   */
  export type ShopsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shops
     */
    select?: ShopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopsInclude<ExtArgs> | null
  }



  /**
   * Model ShopPayment
   */

  export type AggregateShopPayment = {
    _count: ShopPaymentCountAggregateOutputType | null
    _avg: ShopPaymentAvgAggregateOutputType | null
    _sum: ShopPaymentSumAggregateOutputType | null
    _min: ShopPaymentMinAggregateOutputType | null
    _max: ShopPaymentMaxAggregateOutputType | null
  }

  export type ShopPaymentAvgAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    shop_id: number | null
    event_id: number | null
    user_id: number | null
  }

  export type ShopPaymentSumAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    shop_id: number | null
    event_id: number | null
    user_id: number | null
  }

  export type ShopPaymentMinAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    shop_id: number | null
    event_id: number | null
    user_id: number | null
  }

  export type ShopPaymentMaxAggregateOutputType = {
    payment_id: number | null
    amount: number | null
    shop_id: number | null
    event_id: number | null
    user_id: number | null
  }

  export type ShopPaymentCountAggregateOutputType = {
    payment_id: number
    amount: number
    shop_id: number
    event_id: number
    user_id: number
    _all: number
  }


  export type ShopPaymentAvgAggregateInputType = {
    payment_id?: true
    amount?: true
    shop_id?: true
    event_id?: true
    user_id?: true
  }

  export type ShopPaymentSumAggregateInputType = {
    payment_id?: true
    amount?: true
    shop_id?: true
    event_id?: true
    user_id?: true
  }

  export type ShopPaymentMinAggregateInputType = {
    payment_id?: true
    amount?: true
    shop_id?: true
    event_id?: true
    user_id?: true
  }

  export type ShopPaymentMaxAggregateInputType = {
    payment_id?: true
    amount?: true
    shop_id?: true
    event_id?: true
    user_id?: true
  }

  export type ShopPaymentCountAggregateInputType = {
    payment_id?: true
    amount?: true
    shop_id?: true
    event_id?: true
    user_id?: true
    _all?: true
  }

  export type ShopPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopPayment to aggregate.
     */
    where?: ShopPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopPayments to fetch.
     */
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopPayments
    **/
    _count?: true | ShopPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopPaymentMaxAggregateInputType
  }

  export type GetShopPaymentAggregateType<T extends ShopPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateShopPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopPayment[P]>
      : GetScalarType<T[P], AggregateShopPayment[P]>
  }




  export type ShopPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopPaymentWhereInput
    orderBy?: ShopPaymentOrderByWithAggregationInput | ShopPaymentOrderByWithAggregationInput[]
    by: ShopPaymentScalarFieldEnum[] | ShopPaymentScalarFieldEnum
    having?: ShopPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopPaymentCountAggregateInputType | true
    _avg?: ShopPaymentAvgAggregateInputType
    _sum?: ShopPaymentSumAggregateInputType
    _min?: ShopPaymentMinAggregateInputType
    _max?: ShopPaymentMaxAggregateInputType
  }

  export type ShopPaymentGroupByOutputType = {
    payment_id: number
    amount: number
    shop_id: number
    event_id: number
    user_id: number
    _count: ShopPaymentCountAggregateOutputType | null
    _avg: ShopPaymentAvgAggregateOutputType | null
    _sum: ShopPaymentSumAggregateOutputType | null
    _min: ShopPaymentMinAggregateOutputType | null
    _max: ShopPaymentMaxAggregateOutputType | null
  }

  type GetShopPaymentGroupByPayload<T extends ShopPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ShopPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ShopPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    amount?: boolean
    shop_id?: boolean
    event_id?: boolean
    user_id?: boolean
    shop?: boolean | ShopsDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopPayment"]>

  export type ShopPaymentSelectScalar = {
    payment_id?: boolean
    amount?: boolean
    shop_id?: boolean
    event_id?: boolean
    user_id?: boolean
  }

  export type ShopPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopsDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ShopPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopPayment"
    objects: {
      shop: Prisma.$ShopsPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_id: number
      amount: number
      shop_id: number
      event_id: number
      user_id: number
    }, ExtArgs["result"]["shopPayment"]>
    composites: {}
  }


  type ShopPaymentGetPayload<S extends boolean | null | undefined | ShopPaymentDefaultArgs> = $Result.GetResult<Prisma.$ShopPaymentPayload, S>

  type ShopPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopPaymentCountAggregateInputType | true
    }

  export interface ShopPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopPayment'], meta: { name: 'ShopPayment' } }
    /**
     * Find zero or one ShopPayment that matches the filter.
     * @param {ShopPaymentFindUniqueArgs} args - Arguments to find a ShopPayment
     * @example
     * // Get one ShopPayment
     * const shopPayment = await prisma.shopPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopPayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopPaymentFindUniqueOrThrowArgs} args - Arguments to find a ShopPayment
     * @example
     * // Get one ShopPayment
     * const shopPayment = await prisma.shopPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentFindFirstArgs} args - Arguments to find a ShopPayment
     * @example
     * // Get one ShopPayment
     * const shopPayment = await prisma.shopPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentFindFirstOrThrowArgs} args - Arguments to find a ShopPayment
     * @example
     * // Get one ShopPayment
     * const shopPayment = await prisma.shopPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopPayments
     * const shopPayments = await prisma.shopPayment.findMany()
     * 
     * // Get first 10 ShopPayments
     * const shopPayments = await prisma.shopPayment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const shopPaymentWithPayment_idOnly = await prisma.shopPayment.findMany({ select: { payment_id: true } })
     * 
    **/
    findMany<T extends ShopPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopPayment.
     * @param {ShopPaymentCreateArgs} args - Arguments to create a ShopPayment.
     * @example
     * // Create one ShopPayment
     * const ShopPayment = await prisma.shopPayment.create({
     *   data: {
     *     // ... data to create a ShopPayment
     *   }
     * })
     * 
    **/
    create<T extends ShopPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentCreateArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopPayments.
     *     @param {ShopPaymentCreateManyArgs} args - Arguments to create many ShopPayments.
     *     @example
     *     // Create many ShopPayments
     *     const shopPayment = await prisma.shopPayment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopPayment.
     * @param {ShopPaymentDeleteArgs} args - Arguments to delete one ShopPayment.
     * @example
     * // Delete one ShopPayment
     * const ShopPayment = await prisma.shopPayment.delete({
     *   where: {
     *     // ... filter to delete one ShopPayment
     *   }
     * })
     * 
    **/
    delete<T extends ShopPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentDeleteArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopPayment.
     * @param {ShopPaymentUpdateArgs} args - Arguments to update one ShopPayment.
     * @example
     * // Update one ShopPayment
     * const shopPayment = await prisma.shopPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentUpdateArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopPayments.
     * @param {ShopPaymentDeleteManyArgs} args - Arguments to filter ShopPayments to delete.
     * @example
     * // Delete a few ShopPayments
     * const { count } = await prisma.shopPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopPayments
     * const shopPayment = await prisma.shopPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopPayment.
     * @param {ShopPaymentUpsertArgs} args - Arguments to update or create a ShopPayment.
     * @example
     * // Update or create a ShopPayment
     * const shopPayment = await prisma.shopPayment.upsert({
     *   create: {
     *     // ... data to create a ShopPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopPayment we want to update
     *   }
     * })
    **/
    upsert<T extends ShopPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopPaymentUpsertArgs<ExtArgs>>
    ): Prisma__ShopPaymentClient<$Result.GetResult<Prisma.$ShopPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentCountArgs} args - Arguments to filter ShopPayments to count.
     * @example
     * // Count the number of ShopPayments
     * const count = await prisma.shopPayment.count({
     *   where: {
     *     // ... the filter for the ShopPayments we want to count
     *   }
     * })
    **/
    count<T extends ShopPaymentCountArgs>(
      args?: Subset<T, ShopPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopPaymentAggregateArgs>(args: Subset<T, ShopPaymentAggregateArgs>): Prisma.PrismaPromise<GetShopPaymentAggregateType<T>>

    /**
     * Group by ShopPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ShopPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopPayment model
   */
  readonly fields: ShopPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    shop<T extends ShopsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopsDefaultArgs<ExtArgs>>): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopPayment model
   */ 
  interface ShopPaymentFieldRefs {
    readonly payment_id: FieldRef<"ShopPayment", 'Int'>
    readonly amount: FieldRef<"ShopPayment", 'Float'>
    readonly shop_id: FieldRef<"ShopPayment", 'Int'>
    readonly event_id: FieldRef<"ShopPayment", 'Int'>
    readonly user_id: FieldRef<"ShopPayment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ShopPayment findUnique
   */
  export type ShopPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ShopPayment to fetch.
     */
    where: ShopPaymentWhereUniqueInput
  }


  /**
   * ShopPayment findUniqueOrThrow
   */
  export type ShopPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ShopPayment to fetch.
     */
    where: ShopPaymentWhereUniqueInput
  }


  /**
   * ShopPayment findFirst
   */
  export type ShopPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ShopPayment to fetch.
     */
    where?: ShopPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopPayments to fetch.
     */
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopPayments.
     */
    cursor?: ShopPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopPayments.
     */
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * ShopPayment findFirstOrThrow
   */
  export type ShopPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ShopPayment to fetch.
     */
    where?: ShopPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopPayments to fetch.
     */
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopPayments.
     */
    cursor?: ShopPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopPayments.
     */
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * ShopPayment findMany
   */
  export type ShopPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ShopPayments to fetch.
     */
    where?: ShopPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopPayments to fetch.
     */
    orderBy?: ShopPaymentOrderByWithRelationInput | ShopPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopPayments.
     */
    cursor?: ShopPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopPayments.
     */
    skip?: number
    distinct?: ShopPaymentScalarFieldEnum | ShopPaymentScalarFieldEnum[]
  }


  /**
   * ShopPayment create
   */
  export type ShopPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopPayment.
     */
    data: XOR<ShopPaymentCreateInput, ShopPaymentUncheckedCreateInput>
  }


  /**
   * ShopPayment createMany
   */
  export type ShopPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopPayments.
     */
    data: ShopPaymentCreateManyInput | ShopPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopPayment update
   */
  export type ShopPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopPayment.
     */
    data: XOR<ShopPaymentUpdateInput, ShopPaymentUncheckedUpdateInput>
    /**
     * Choose, which ShopPayment to update.
     */
    where: ShopPaymentWhereUniqueInput
  }


  /**
   * ShopPayment updateMany
   */
  export type ShopPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopPayments.
     */
    data: XOR<ShopPaymentUpdateManyMutationInput, ShopPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ShopPayments to update
     */
    where?: ShopPaymentWhereInput
  }


  /**
   * ShopPayment upsert
   */
  export type ShopPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopPayment to update in case it exists.
     */
    where: ShopPaymentWhereUniqueInput
    /**
     * In case the ShopPayment found by the `where` argument doesn't exist, create a new ShopPayment with this data.
     */
    create: XOR<ShopPaymentCreateInput, ShopPaymentUncheckedCreateInput>
    /**
     * In case the ShopPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopPaymentUpdateInput, ShopPaymentUncheckedUpdateInput>
  }


  /**
   * ShopPayment delete
   */
  export type ShopPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
    /**
     * Filter which ShopPayment to delete.
     */
    where: ShopPaymentWhereUniqueInput
  }


  /**
   * ShopPayment deleteMany
   */
  export type ShopPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopPayments to delete
     */
    where?: ShopPaymentWhereInput
  }


  /**
   * ShopPayment without action
   */
  export type ShopPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopPayment
     */
    select?: ShopPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopPaymentInclude<ExtArgs> | null
  }



  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    rating: number | null
    event_id: number | null
  }

  export type ReviewSumAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    rating: number | null
    event_id: number | null
  }

  export type ReviewMinAggregateOutputType = {
    review_id: number | null
    review_title: string | null
    review_desc: string | null
    user_id: number | null
    rating: number | null
    timestamp: Date | null
    event_id: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    review_id: number | null
    review_title: string | null
    review_desc: string | null
    user_id: number | null
    rating: number | null
    timestamp: Date | null
    event_id: number | null
  }

  export type ReviewCountAggregateOutputType = {
    review_id: number
    review_title: number
    review_desc: number
    user_id: number
    rating: number
    timestamp: number
    event_id: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    review_id?: true
    user_id?: true
    rating?: true
    event_id?: true
  }

  export type ReviewSumAggregateInputType = {
    review_id?: true
    user_id?: true
    rating?: true
    event_id?: true
  }

  export type ReviewMinAggregateInputType = {
    review_id?: true
    review_title?: true
    review_desc?: true
    user_id?: true
    rating?: true
    timestamp?: true
    event_id?: true
  }

  export type ReviewMaxAggregateInputType = {
    review_id?: true
    review_title?: true
    review_desc?: true
    user_id?: true
    rating?: true
    timestamp?: true
    event_id?: true
  }

  export type ReviewCountAggregateInputType = {
    review_id?: true
    review_title?: true
    review_desc?: true
    user_id?: true
    rating?: true
    timestamp?: true
    event_id?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    review_id: number
    review_title: string
    review_desc: string
    user_id: number
    rating: number
    timestamp: Date
    event_id: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    review_title?: boolean
    review_desc?: boolean
    user_id?: boolean
    rating?: boolean
    timestamp?: boolean
    event_id?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    review_id?: boolean
    review_title?: boolean
    review_desc?: boolean
    user_id?: boolean
    rating?: boolean
    timestamp?: boolean
    event_id?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      review_id: number
      review_title: string
      review_desc: string
      user_id: number
      rating: number
      timestamp: Date
      event_id: number
    }, ExtArgs["result"]["review"]>
    composites: {}
  }


  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.findMany({ select: { review_id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly review_id: FieldRef<"Review", 'Int'>
    readonly review_title: FieldRef<"Review", 'String'>
    readonly review_desc: FieldRef<"Review", 'String'>
    readonly user_id: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly timestamp: FieldRef<"Review", 'DateTime'>
    readonly event_id: FieldRef<"Review", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
  }



  /**
   * Model Itinerary
   */

  export type AggregateItinerary = {
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  export type ItineraryAvgAggregateOutputType = {
    itinerary_id: number | null
    event_id: number | null
  }

  export type ItinerarySumAggregateOutputType = {
    itinerary_id: number | null
    event_id: number | null
  }

  export type ItineraryMinAggregateOutputType = {
    itinerary_id: number | null
    event_id: number | null
    itinerary_name: string | null
    itinerary_description: string | null
    timestamp: Date | null
    image_url: string | null
  }

  export type ItineraryMaxAggregateOutputType = {
    itinerary_id: number | null
    event_id: number | null
    itinerary_name: string | null
    itinerary_description: string | null
    timestamp: Date | null
    image_url: string | null
  }

  export type ItineraryCountAggregateOutputType = {
    itinerary_id: number
    event_id: number
    itinerary_name: number
    itinerary_description: number
    timestamp: number
    image_url: number
    _all: number
  }


  export type ItineraryAvgAggregateInputType = {
    itinerary_id?: true
    event_id?: true
  }

  export type ItinerarySumAggregateInputType = {
    itinerary_id?: true
    event_id?: true
  }

  export type ItineraryMinAggregateInputType = {
    itinerary_id?: true
    event_id?: true
    itinerary_name?: true
    itinerary_description?: true
    timestamp?: true
    image_url?: true
  }

  export type ItineraryMaxAggregateInputType = {
    itinerary_id?: true
    event_id?: true
    itinerary_name?: true
    itinerary_description?: true
    timestamp?: true
    image_url?: true
  }

  export type ItineraryCountAggregateInputType = {
    itinerary_id?: true
    event_id?: true
    itinerary_name?: true
    itinerary_description?: true
    timestamp?: true
    image_url?: true
    _all?: true
  }

  export type ItineraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itinerary to aggregate.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Itineraries
    **/
    _count?: true | ItineraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItineraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItineraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItineraryMaxAggregateInputType
  }

  export type GetItineraryAggregateType<T extends ItineraryAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerary[P]>
      : GetScalarType<T[P], AggregateItinerary[P]>
  }




  export type ItineraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItineraryWhereInput
    orderBy?: ItineraryOrderByWithAggregationInput | ItineraryOrderByWithAggregationInput[]
    by: ItineraryScalarFieldEnum[] | ItineraryScalarFieldEnum
    having?: ItineraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItineraryCountAggregateInputType | true
    _avg?: ItineraryAvgAggregateInputType
    _sum?: ItinerarySumAggregateInputType
    _min?: ItineraryMinAggregateInputType
    _max?: ItineraryMaxAggregateInputType
  }

  export type ItineraryGroupByOutputType = {
    itinerary_id: number
    event_id: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date
    image_url: string
    _count: ItineraryCountAggregateOutputType | null
    _avg: ItineraryAvgAggregateOutputType | null
    _sum: ItinerarySumAggregateOutputType | null
    _min: ItineraryMinAggregateOutputType | null
    _max: ItineraryMaxAggregateOutputType | null
  }

  type GetItineraryGroupByPayload<T extends ItineraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItineraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItineraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
            : GetScalarType<T[P], ItineraryGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itinerary_id?: boolean
    event_id?: boolean
    itinerary_name?: boolean
    itinerary_description?: boolean
    timestamp?: boolean
    image_url?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    favourite?: boolean | Itinerary$favouriteArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerary"]>

  export type ItinerarySelectScalar = {
    itinerary_id?: boolean
    event_id?: boolean
    itinerary_name?: boolean
    itinerary_description?: boolean
    timestamp?: boolean
    image_url?: boolean
  }

  export type ItineraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    favourite?: boolean | Itinerary$favouriteArgs<ExtArgs>
    _count?: boolean | ItineraryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItineraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Itinerary"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      favourite: Prisma.$FavouritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      itinerary_id: number
      event_id: number
      itinerary_name: string
      itinerary_description: string
      timestamp: Date
      image_url: string
    }, ExtArgs["result"]["itinerary"]>
    composites: {}
  }


  type ItineraryGetPayload<S extends boolean | null | undefined | ItineraryDefaultArgs> = $Result.GetResult<Prisma.$ItineraryPayload, S>

  type ItineraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItineraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItineraryCountAggregateInputType | true
    }

  export interface ItineraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Itinerary'], meta: { name: 'Itinerary' } }
    /**
     * Find zero or one Itinerary that matches the filter.
     * @param {ItineraryFindUniqueArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItineraryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryFindUniqueArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Itinerary that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItineraryFindUniqueOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItineraryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItineraryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindFirstArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Itinerary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindFirstOrThrowArgs} args - Arguments to find a Itinerary
     * @example
     * // Get one Itinerary
     * const itinerary = await prisma.itinerary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItineraryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Itineraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itineraries
     * const itineraries = await prisma.itinerary.findMany()
     * 
     * // Get first 10 Itineraries
     * const itineraries = await prisma.itinerary.findMany({ take: 10 })
     * 
     * // Only select the `itinerary_id`
     * const itineraryWithItinerary_idOnly = await prisma.itinerary.findMany({ select: { itinerary_id: true } })
     * 
    **/
    findMany<T extends ItineraryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Itinerary.
     * @param {ItineraryCreateArgs} args - Arguments to create a Itinerary.
     * @example
     * // Create one Itinerary
     * const Itinerary = await prisma.itinerary.create({
     *   data: {
     *     // ... data to create a Itinerary
     *   }
     * })
     * 
    **/
    create<T extends ItineraryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryCreateArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Itineraries.
     *     @param {ItineraryCreateManyArgs} args - Arguments to create many Itineraries.
     *     @example
     *     // Create many Itineraries
     *     const itinerary = await prisma.itinerary.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItineraryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Itinerary.
     * @param {ItineraryDeleteArgs} args - Arguments to delete one Itinerary.
     * @example
     * // Delete one Itinerary
     * const Itinerary = await prisma.itinerary.delete({
     *   where: {
     *     // ... filter to delete one Itinerary
     *   }
     * })
     * 
    **/
    delete<T extends ItineraryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryDeleteArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Itinerary.
     * @param {ItineraryUpdateArgs} args - Arguments to update one Itinerary.
     * @example
     * // Update one Itinerary
     * const itinerary = await prisma.itinerary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItineraryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpdateArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Itineraries.
     * @param {ItineraryDeleteManyArgs} args - Arguments to filter Itineraries to delete.
     * @example
     * // Delete a few Itineraries
     * const { count } = await prisma.itinerary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItineraryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItineraryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itineraries
     * const itinerary = await prisma.itinerary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItineraryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerary.
     * @param {ItineraryUpsertArgs} args - Arguments to update or create a Itinerary.
     * @example
     * // Update or create a Itinerary
     * const itinerary = await prisma.itinerary.upsert({
     *   create: {
     *     // ... data to create a Itinerary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerary we want to update
     *   }
     * })
    **/
    upsert<T extends ItineraryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItineraryUpsertArgs<ExtArgs>>
    ): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Itineraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryCountArgs} args - Arguments to filter Itineraries to count.
     * @example
     * // Count the number of Itineraries
     * const count = await prisma.itinerary.count({
     *   where: {
     *     // ... the filter for the Itineraries we want to count
     *   }
     * })
    **/
    count<T extends ItineraryCountArgs>(
      args?: Subset<T, ItineraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItineraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItineraryAggregateArgs>(args: Subset<T, ItineraryAggregateArgs>): Prisma.PrismaPromise<GetItineraryAggregateType<T>>

    /**
     * Group by Itinerary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItineraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItineraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItineraryGroupByArgs['orderBy'] }
        : { orderBy?: ItineraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItineraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItineraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Itinerary model
   */
  readonly fields: ItineraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Itinerary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItineraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    favourite<T extends Itinerary$favouriteArgs<ExtArgs> = {}>(args?: Subset<T, Itinerary$favouriteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Itinerary model
   */ 
  interface ItineraryFieldRefs {
    readonly itinerary_id: FieldRef<"Itinerary", 'Int'>
    readonly event_id: FieldRef<"Itinerary", 'Int'>
    readonly itinerary_name: FieldRef<"Itinerary", 'String'>
    readonly itinerary_description: FieldRef<"Itinerary", 'String'>
    readonly timestamp: FieldRef<"Itinerary", 'DateTime'>
    readonly image_url: FieldRef<"Itinerary", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Itinerary findUnique
   */
  export type ItineraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary findUniqueOrThrow
   */
  export type ItineraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary findFirst
   */
  export type ItineraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }


  /**
   * Itinerary findFirstOrThrow
   */
  export type ItineraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itinerary to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Itineraries.
     */
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }


  /**
   * Itinerary findMany
   */
  export type ItineraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter, which Itineraries to fetch.
     */
    where?: ItineraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Itineraries to fetch.
     */
    orderBy?: ItineraryOrderByWithRelationInput | ItineraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Itineraries.
     */
    cursor?: ItineraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Itineraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Itineraries.
     */
    skip?: number
    distinct?: ItineraryScalarFieldEnum | ItineraryScalarFieldEnum[]
  }


  /**
   * Itinerary create
   */
  export type ItineraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Itinerary.
     */
    data: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
  }


  /**
   * Itinerary createMany
   */
  export type ItineraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Itineraries.
     */
    data: ItineraryCreateManyInput | ItineraryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Itinerary update
   */
  export type ItineraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Itinerary.
     */
    data: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
    /**
     * Choose, which Itinerary to update.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary updateMany
   */
  export type ItineraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Itineraries.
     */
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyInput>
    /**
     * Filter which Itineraries to update
     */
    where?: ItineraryWhereInput
  }


  /**
   * Itinerary upsert
   */
  export type ItineraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Itinerary to update in case it exists.
     */
    where: ItineraryWhereUniqueInput
    /**
     * In case the Itinerary found by the `where` argument doesn't exist, create a new Itinerary with this data.
     */
    create: XOR<ItineraryCreateInput, ItineraryUncheckedCreateInput>
    /**
     * In case the Itinerary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItineraryUpdateInput, ItineraryUncheckedUpdateInput>
  }


  /**
   * Itinerary delete
   */
  export type ItineraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
    /**
     * Filter which Itinerary to delete.
     */
    where: ItineraryWhereUniqueInput
  }


  /**
   * Itinerary deleteMany
   */
  export type ItineraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Itineraries to delete
     */
    where?: ItineraryWhereInput
  }


  /**
   * Itinerary.favourite
   */
  export type Itinerary$favouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    where?: FavouriteWhereInput
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    cursor?: FavouriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * Itinerary without action
   */
  export type ItineraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Itinerary
     */
    select?: ItinerarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItineraryInclude<ExtArgs> | null
  }



  /**
   * Model Favourite
   */

  export type AggregateFavourite = {
    _count: FavouriteCountAggregateOutputType | null
    _avg: FavouriteAvgAggregateOutputType | null
    _sum: FavouriteSumAggregateOutputType | null
    _min: FavouriteMinAggregateOutputType | null
    _max: FavouriteMaxAggregateOutputType | null
  }

  export type FavouriteAvgAggregateOutputType = {
    event_id: number | null
    itinerary_id: number | null
    user_id: number | null
  }

  export type FavouriteSumAggregateOutputType = {
    event_id: number | null
    itinerary_id: number | null
    user_id: number | null
  }

  export type FavouriteMinAggregateOutputType = {
    event_id: number | null
    itinerary_id: number | null
    user_id: number | null
  }

  export type FavouriteMaxAggregateOutputType = {
    event_id: number | null
    itinerary_id: number | null
    user_id: number | null
  }

  export type FavouriteCountAggregateOutputType = {
    event_id: number
    itinerary_id: number
    user_id: number
    _all: number
  }


  export type FavouriteAvgAggregateInputType = {
    event_id?: true
    itinerary_id?: true
    user_id?: true
  }

  export type FavouriteSumAggregateInputType = {
    event_id?: true
    itinerary_id?: true
    user_id?: true
  }

  export type FavouriteMinAggregateInputType = {
    event_id?: true
    itinerary_id?: true
    user_id?: true
  }

  export type FavouriteMaxAggregateInputType = {
    event_id?: true
    itinerary_id?: true
    user_id?: true
  }

  export type FavouriteCountAggregateInputType = {
    event_id?: true
    itinerary_id?: true
    user_id?: true
    _all?: true
  }

  export type FavouriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favourite to aggregate.
     */
    where?: FavouriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favourites to fetch.
     */
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavouriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favourites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favourites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favourites
    **/
    _count?: true | FavouriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavouriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavouriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavouriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavouriteMaxAggregateInputType
  }

  export type GetFavouriteAggregateType<T extends FavouriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavourite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavourite[P]>
      : GetScalarType<T[P], AggregateFavourite[P]>
  }




  export type FavouriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavouriteWhereInput
    orderBy?: FavouriteOrderByWithAggregationInput | FavouriteOrderByWithAggregationInput[]
    by: FavouriteScalarFieldEnum[] | FavouriteScalarFieldEnum
    having?: FavouriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavouriteCountAggregateInputType | true
    _avg?: FavouriteAvgAggregateInputType
    _sum?: FavouriteSumAggregateInputType
    _min?: FavouriteMinAggregateInputType
    _max?: FavouriteMaxAggregateInputType
  }

  export type FavouriteGroupByOutputType = {
    event_id: number
    itinerary_id: number
    user_id: number
    _count: FavouriteCountAggregateOutputType | null
    _avg: FavouriteAvgAggregateOutputType | null
    _sum: FavouriteSumAggregateOutputType | null
    _min: FavouriteMinAggregateOutputType | null
    _max: FavouriteMaxAggregateOutputType | null
  }

  type GetFavouriteGroupByPayload<T extends FavouriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavouriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavouriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavouriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavouriteGroupByOutputType[P]>
        }
      >
    >


  export type FavouriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    itinerary_id?: boolean
    user_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favourite"]>

  export type FavouriteSelectScalar = {
    event_id?: boolean
    itinerary_id?: boolean
    user_id?: boolean
  }

  export type FavouriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    itinerary?: boolean | ItineraryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $FavouritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favourite"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      itinerary: Prisma.$ItineraryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: number
      itinerary_id: number
      user_id: number
    }, ExtArgs["result"]["favourite"]>
    composites: {}
  }


  type FavouriteGetPayload<S extends boolean | null | undefined | FavouriteDefaultArgs> = $Result.GetResult<Prisma.$FavouritePayload, S>

  type FavouriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavouriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavouriteCountAggregateInputType | true
    }

  export interface FavouriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favourite'], meta: { name: 'Favourite' } }
    /**
     * Find zero or one Favourite that matches the filter.
     * @param {FavouriteFindUniqueArgs} args - Arguments to find a Favourite
     * @example
     * // Get one Favourite
     * const favourite = await prisma.favourite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FavouriteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteFindUniqueArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Favourite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FavouriteFindUniqueOrThrowArgs} args - Arguments to find a Favourite
     * @example
     * // Get one Favourite
     * const favourite = await prisma.favourite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FavouriteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Favourite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteFindFirstArgs} args - Arguments to find a Favourite
     * @example
     * // Get one Favourite
     * const favourite = await prisma.favourite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FavouriteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteFindFirstArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Favourite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteFindFirstOrThrowArgs} args - Arguments to find a Favourite
     * @example
     * // Get one Favourite
     * const favourite = await prisma.favourite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FavouriteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Favourites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favourites
     * const favourites = await prisma.favourite.findMany()
     * 
     * // Get first 10 Favourites
     * const favourites = await prisma.favourite.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const favouriteWithEvent_idOnly = await prisma.favourite.findMany({ select: { event_id: true } })
     * 
    **/
    findMany<T extends FavouriteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Favourite.
     * @param {FavouriteCreateArgs} args - Arguments to create a Favourite.
     * @example
     * // Create one Favourite
     * const Favourite = await prisma.favourite.create({
     *   data: {
     *     // ... data to create a Favourite
     *   }
     * })
     * 
    **/
    create<T extends FavouriteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteCreateArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Favourites.
     *     @param {FavouriteCreateManyArgs} args - Arguments to create many Favourites.
     *     @example
     *     // Create many Favourites
     *     const favourite = await prisma.favourite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FavouriteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Favourite.
     * @param {FavouriteDeleteArgs} args - Arguments to delete one Favourite.
     * @example
     * // Delete one Favourite
     * const Favourite = await prisma.favourite.delete({
     *   where: {
     *     // ... filter to delete one Favourite
     *   }
     * })
     * 
    **/
    delete<T extends FavouriteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteDeleteArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Favourite.
     * @param {FavouriteUpdateArgs} args - Arguments to update one Favourite.
     * @example
     * // Update one Favourite
     * const favourite = await prisma.favourite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FavouriteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteUpdateArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Favourites.
     * @param {FavouriteDeleteManyArgs} args - Arguments to filter Favourites to delete.
     * @example
     * // Delete a few Favourites
     * const { count } = await prisma.favourite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FavouriteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FavouriteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favourites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favourites
     * const favourite = await prisma.favourite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FavouriteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favourite.
     * @param {FavouriteUpsertArgs} args - Arguments to update or create a Favourite.
     * @example
     * // Update or create a Favourite
     * const favourite = await prisma.favourite.upsert({
     *   create: {
     *     // ... data to create a Favourite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favourite we want to update
     *   }
     * })
    **/
    upsert<T extends FavouriteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FavouriteUpsertArgs<ExtArgs>>
    ): Prisma__FavouriteClient<$Result.GetResult<Prisma.$FavouritePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Favourites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteCountArgs} args - Arguments to filter Favourites to count.
     * @example
     * // Count the number of Favourites
     * const count = await prisma.favourite.count({
     *   where: {
     *     // ... the filter for the Favourites we want to count
     *   }
     * })
    **/
    count<T extends FavouriteCountArgs>(
      args?: Subset<T, FavouriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavouriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favourite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavouriteAggregateArgs>(args: Subset<T, FavouriteAggregateArgs>): Prisma.PrismaPromise<GetFavouriteAggregateType<T>>

    /**
     * Group by Favourite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavouriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavouriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavouriteGroupByArgs['orderBy'] }
        : { orderBy?: FavouriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavouriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavouriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favourite model
   */
  readonly fields: FavouriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favourite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavouriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    itinerary<T extends ItineraryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItineraryDefaultArgs<ExtArgs>>): Prisma__ItineraryClient<$Result.GetResult<Prisma.$ItineraryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Favourite model
   */ 
  interface FavouriteFieldRefs {
    readonly event_id: FieldRef<"Favourite", 'Int'>
    readonly itinerary_id: FieldRef<"Favourite", 'Int'>
    readonly user_id: FieldRef<"Favourite", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Favourite findUnique
   */
  export type FavouriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter, which Favourite to fetch.
     */
    where: FavouriteWhereUniqueInput
  }


  /**
   * Favourite findUniqueOrThrow
   */
  export type FavouriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter, which Favourite to fetch.
     */
    where: FavouriteWhereUniqueInput
  }


  /**
   * Favourite findFirst
   */
  export type FavouriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter, which Favourite to fetch.
     */
    where?: FavouriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favourites to fetch.
     */
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favourites.
     */
    cursor?: FavouriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favourites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favourites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favourites.
     */
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * Favourite findFirstOrThrow
   */
  export type FavouriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter, which Favourite to fetch.
     */
    where?: FavouriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favourites to fetch.
     */
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favourites.
     */
    cursor?: FavouriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favourites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favourites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favourites.
     */
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * Favourite findMany
   */
  export type FavouriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter, which Favourites to fetch.
     */
    where?: FavouriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favourites to fetch.
     */
    orderBy?: FavouriteOrderByWithRelationInput | FavouriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favourites.
     */
    cursor?: FavouriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favourites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favourites.
     */
    skip?: number
    distinct?: FavouriteScalarFieldEnum | FavouriteScalarFieldEnum[]
  }


  /**
   * Favourite create
   */
  export type FavouriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favourite.
     */
    data: XOR<FavouriteCreateInput, FavouriteUncheckedCreateInput>
  }


  /**
   * Favourite createMany
   */
  export type FavouriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favourites.
     */
    data: FavouriteCreateManyInput | FavouriteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Favourite update
   */
  export type FavouriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favourite.
     */
    data: XOR<FavouriteUpdateInput, FavouriteUncheckedUpdateInput>
    /**
     * Choose, which Favourite to update.
     */
    where: FavouriteWhereUniqueInput
  }


  /**
   * Favourite updateMany
   */
  export type FavouriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favourites.
     */
    data: XOR<FavouriteUpdateManyMutationInput, FavouriteUncheckedUpdateManyInput>
    /**
     * Filter which Favourites to update
     */
    where?: FavouriteWhereInput
  }


  /**
   * Favourite upsert
   */
  export type FavouriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favourite to update in case it exists.
     */
    where: FavouriteWhereUniqueInput
    /**
     * In case the Favourite found by the `where` argument doesn't exist, create a new Favourite with this data.
     */
    create: XOR<FavouriteCreateInput, FavouriteUncheckedCreateInput>
    /**
     * In case the Favourite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavouriteUpdateInput, FavouriteUncheckedUpdateInput>
  }


  /**
   * Favourite delete
   */
  export type FavouriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
    /**
     * Filter which Favourite to delete.
     */
    where: FavouriteWhereUniqueInput
  }


  /**
   * Favourite deleteMany
   */
  export type FavouriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favourites to delete
     */
    where?: FavouriteWhereInput
  }


  /**
   * Favourite without action
   */
  export type FavouriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favourite
     */
    select?: FavouriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FavouriteInclude<ExtArgs> | null
  }



  /**
   * Model Token_Transaction
   */

  export type AggregateToken_Transaction = {
    _count: Token_TransactionCountAggregateOutputType | null
    _avg: Token_TransactionAvgAggregateOutputType | null
    _sum: Token_TransactionSumAggregateOutputType | null
    _min: Token_TransactionMinAggregateOutputType | null
    _max: Token_TransactionMaxAggregateOutputType | null
  }

  export type Token_TransactionAvgAggregateOutputType = {
    ID: number | null
    token: number | null
    event_ID: number | null
    transaction_ID: number | null
    shop_ID: number | null
  }

  export type Token_TransactionSumAggregateOutputType = {
    ID: number | null
    token: number | null
    event_ID: number | null
    transaction_ID: number | null
    shop_ID: number | null
  }

  export type Token_TransactionMinAggregateOutputType = {
    ID: number | null
    transaction_type: string | null
    token: number | null
    event_ID: number | null
    transaction_ID: number | null
    shop_ID: number | null
  }

  export type Token_TransactionMaxAggregateOutputType = {
    ID: number | null
    transaction_type: string | null
    token: number | null
    event_ID: number | null
    transaction_ID: number | null
    shop_ID: number | null
  }

  export type Token_TransactionCountAggregateOutputType = {
    ID: number
    transaction_type: number
    token: number
    event_ID: number
    transaction_ID: number
    shop_ID: number
    _all: number
  }


  export type Token_TransactionAvgAggregateInputType = {
    ID?: true
    token?: true
    event_ID?: true
    transaction_ID?: true
    shop_ID?: true
  }

  export type Token_TransactionSumAggregateInputType = {
    ID?: true
    token?: true
    event_ID?: true
    transaction_ID?: true
    shop_ID?: true
  }

  export type Token_TransactionMinAggregateInputType = {
    ID?: true
    transaction_type?: true
    token?: true
    event_ID?: true
    transaction_ID?: true
    shop_ID?: true
  }

  export type Token_TransactionMaxAggregateInputType = {
    ID?: true
    transaction_type?: true
    token?: true
    event_ID?: true
    transaction_ID?: true
    shop_ID?: true
  }

  export type Token_TransactionCountAggregateInputType = {
    ID?: true
    transaction_type?: true
    token?: true
    event_ID?: true
    transaction_ID?: true
    shop_ID?: true
    _all?: true
  }

  export type Token_TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token_Transaction to aggregate.
     */
    where?: Token_TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Token_Transactions to fetch.
     */
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Token_TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Token_Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Token_Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Token_Transactions
    **/
    _count?: true | Token_TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_TransactionMaxAggregateInputType
  }

  export type GetToken_TransactionAggregateType<T extends Token_TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_Transaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_Transaction[P]>
      : GetScalarType<T[P], AggregateToken_Transaction[P]>
  }




  export type Token_TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Token_TransactionWhereInput
    orderBy?: Token_TransactionOrderByWithAggregationInput | Token_TransactionOrderByWithAggregationInput[]
    by: Token_TransactionScalarFieldEnum[] | Token_TransactionScalarFieldEnum
    having?: Token_TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_TransactionCountAggregateInputType | true
    _avg?: Token_TransactionAvgAggregateInputType
    _sum?: Token_TransactionSumAggregateInputType
    _min?: Token_TransactionMinAggregateInputType
    _max?: Token_TransactionMaxAggregateInputType
  }

  export type Token_TransactionGroupByOutputType = {
    ID: number
    transaction_type: string
    token: number
    event_ID: number
    transaction_ID: number
    shop_ID: number
    _count: Token_TransactionCountAggregateOutputType | null
    _avg: Token_TransactionAvgAggregateOutputType | null
    _sum: Token_TransactionSumAggregateOutputType | null
    _min: Token_TransactionMinAggregateOutputType | null
    _max: Token_TransactionMaxAggregateOutputType | null
  }

  type GetToken_TransactionGroupByPayload<T extends Token_TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Token_TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], Token_TransactionGroupByOutputType[P]>
        }
      >
    >


  export type Token_TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    transaction_type?: boolean
    token?: boolean
    event_ID?: boolean
    transaction_ID?: boolean
    shop_ID?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    shop?: boolean | ShopsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token_Transaction"]>

  export type Token_TransactionSelectScalar = {
    ID?: boolean
    transaction_type?: boolean
    token?: boolean
    event_ID?: boolean
    transaction_ID?: boolean
    shop_ID?: boolean
  }

  export type Token_TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    shop?: boolean | ShopsDefaultArgs<ExtArgs>
  }


  export type $Token_TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token_Transaction"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
      shop: Prisma.$ShopsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      transaction_type: string
      token: number
      event_ID: number
      transaction_ID: number
      shop_ID: number
    }, ExtArgs["result"]["token_Transaction"]>
    composites: {}
  }


  type Token_TransactionGetPayload<S extends boolean | null | undefined | Token_TransactionDefaultArgs> = $Result.GetResult<Prisma.$Token_TransactionPayload, S>

  type Token_TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Token_TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Token_TransactionCountAggregateInputType | true
    }

  export interface Token_TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token_Transaction'], meta: { name: 'Token_Transaction' } }
    /**
     * Find zero or one Token_Transaction that matches the filter.
     * @param {Token_TransactionFindUniqueArgs} args - Arguments to find a Token_Transaction
     * @example
     * // Get one Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Token_TransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Token_Transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Token_TransactionFindUniqueOrThrowArgs} args - Arguments to find a Token_Transaction
     * @example
     * // Get one Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Token_TransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Token_Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionFindFirstArgs} args - Arguments to find a Token_Transaction
     * @example
     * // Get one Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Token_TransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionFindFirstArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Token_Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionFindFirstOrThrowArgs} args - Arguments to find a Token_Transaction
     * @example
     * // Get one Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Token_TransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Token_Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_Transactions
     * const token_Transactions = await prisma.token_Transaction.findMany()
     * 
     * // Get first 10 Token_Transactions
     * const token_Transactions = await prisma.token_Transaction.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const token_TransactionWithIDOnly = await prisma.token_Transaction.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends Token_TransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Token_Transaction.
     * @param {Token_TransactionCreateArgs} args - Arguments to create a Token_Transaction.
     * @example
     * // Create one Token_Transaction
     * const Token_Transaction = await prisma.token_Transaction.create({
     *   data: {
     *     // ... data to create a Token_Transaction
     *   }
     * })
     * 
    **/
    create<T extends Token_TransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionCreateArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Token_Transactions.
     *     @param {Token_TransactionCreateManyArgs} args - Arguments to create many Token_Transactions.
     *     @example
     *     // Create many Token_Transactions
     *     const token_Transaction = await prisma.token_Transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Token_TransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Token_Transaction.
     * @param {Token_TransactionDeleteArgs} args - Arguments to delete one Token_Transaction.
     * @example
     * // Delete one Token_Transaction
     * const Token_Transaction = await prisma.token_Transaction.delete({
     *   where: {
     *     // ... filter to delete one Token_Transaction
     *   }
     * })
     * 
    **/
    delete<T extends Token_TransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionDeleteArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Token_Transaction.
     * @param {Token_TransactionUpdateArgs} args - Arguments to update one Token_Transaction.
     * @example
     * // Update one Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Token_TransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionUpdateArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Token_Transactions.
     * @param {Token_TransactionDeleteManyArgs} args - Arguments to filter Token_Transactions to delete.
     * @example
     * // Delete a few Token_Transactions
     * const { count } = await prisma.token_Transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Token_TransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Token_TransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_Transactions
     * const token_Transaction = await prisma.token_Transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Token_TransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token_Transaction.
     * @param {Token_TransactionUpsertArgs} args - Arguments to update or create a Token_Transaction.
     * @example
     * // Update or create a Token_Transaction
     * const token_Transaction = await prisma.token_Transaction.upsert({
     *   create: {
     *     // ... data to create a Token_Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends Token_TransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Token_TransactionUpsertArgs<ExtArgs>>
    ): Prisma__Token_TransactionClient<$Result.GetResult<Prisma.$Token_TransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Token_Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionCountArgs} args - Arguments to filter Token_Transactions to count.
     * @example
     * // Count the number of Token_Transactions
     * const count = await prisma.token_Transaction.count({
     *   where: {
     *     // ... the filter for the Token_Transactions we want to count
     *   }
     * })
    **/
    count<T extends Token_TransactionCountArgs>(
      args?: Subset<T, Token_TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_TransactionAggregateArgs>(args: Subset<T, Token_TransactionAggregateArgs>): Prisma.PrismaPromise<GetToken_TransactionAggregateType<T>>

    /**
     * Group by Token_Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Token_TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Token_TransactionGroupByArgs['orderBy'] }
        : { orderBy?: Token_TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Token_TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_TransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token_Transaction model
   */
  readonly fields: Token_TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token_Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Token_TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    shop<T extends ShopsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopsDefaultArgs<ExtArgs>>): Prisma__ShopsClient<$Result.GetResult<Prisma.$ShopsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Token_Transaction model
   */ 
  interface Token_TransactionFieldRefs {
    readonly ID: FieldRef<"Token_Transaction", 'Int'>
    readonly transaction_type: FieldRef<"Token_Transaction", 'String'>
    readonly token: FieldRef<"Token_Transaction", 'Int'>
    readonly event_ID: FieldRef<"Token_Transaction", 'Int'>
    readonly transaction_ID: FieldRef<"Token_Transaction", 'Int'>
    readonly shop_ID: FieldRef<"Token_Transaction", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Token_Transaction findUnique
   */
  export type Token_TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Token_Transaction to fetch.
     */
    where: Token_TransactionWhereUniqueInput
  }


  /**
   * Token_Transaction findUniqueOrThrow
   */
  export type Token_TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Token_Transaction to fetch.
     */
    where: Token_TransactionWhereUniqueInput
  }


  /**
   * Token_Transaction findFirst
   */
  export type Token_TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Token_Transaction to fetch.
     */
    where?: Token_TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Token_Transactions to fetch.
     */
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Token_Transactions.
     */
    cursor?: Token_TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Token_Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Token_Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Token_Transactions.
     */
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Token_Transaction findFirstOrThrow
   */
  export type Token_TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Token_Transaction to fetch.
     */
    where?: Token_TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Token_Transactions to fetch.
     */
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Token_Transactions.
     */
    cursor?: Token_TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Token_Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Token_Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Token_Transactions.
     */
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Token_Transaction findMany
   */
  export type Token_TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Token_Transactions to fetch.
     */
    where?: Token_TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Token_Transactions to fetch.
     */
    orderBy?: Token_TransactionOrderByWithRelationInput | Token_TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Token_Transactions.
     */
    cursor?: Token_TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Token_Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Token_Transactions.
     */
    skip?: number
    distinct?: Token_TransactionScalarFieldEnum | Token_TransactionScalarFieldEnum[]
  }


  /**
   * Token_Transaction create
   */
  export type Token_TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Token_Transaction.
     */
    data: XOR<Token_TransactionCreateInput, Token_TransactionUncheckedCreateInput>
  }


  /**
   * Token_Transaction createMany
   */
  export type Token_TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Token_Transactions.
     */
    data: Token_TransactionCreateManyInput | Token_TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Token_Transaction update
   */
  export type Token_TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Token_Transaction.
     */
    data: XOR<Token_TransactionUpdateInput, Token_TransactionUncheckedUpdateInput>
    /**
     * Choose, which Token_Transaction to update.
     */
    where: Token_TransactionWhereUniqueInput
  }


  /**
   * Token_Transaction updateMany
   */
  export type Token_TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Token_Transactions.
     */
    data: XOR<Token_TransactionUpdateManyMutationInput, Token_TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Token_Transactions to update
     */
    where?: Token_TransactionWhereInput
  }


  /**
   * Token_Transaction upsert
   */
  export type Token_TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Token_Transaction to update in case it exists.
     */
    where: Token_TransactionWhereUniqueInput
    /**
     * In case the Token_Transaction found by the `where` argument doesn't exist, create a new Token_Transaction with this data.
     */
    create: XOR<Token_TransactionCreateInput, Token_TransactionUncheckedCreateInput>
    /**
     * In case the Token_Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Token_TransactionUpdateInput, Token_TransactionUncheckedUpdateInput>
  }


  /**
   * Token_Transaction delete
   */
  export type Token_TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
    /**
     * Filter which Token_Transaction to delete.
     */
    where: Token_TransactionWhereUniqueInput
  }


  /**
   * Token_Transaction deleteMany
   */
  export type Token_TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token_Transactions to delete
     */
    where?: Token_TransactionWhereInput
  }


  /**
   * Token_Transaction without action
   */
  export type Token_TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token_Transaction
     */
    select?: Token_TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Token_TransactionInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    event_id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    event_id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    type: string | null
    timestamp: Date | null
    user_id: number | null
    event_id: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    type: string | null
    timestamp: Date | null
    user_id: number | null
    event_id: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    body: number
    type: number
    timestamp: number
    user_id: number
    event_id: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    user_id?: true
    event_id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    user_id?: true
    event_id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    type?: true
    timestamp?: true
    user_id?: true
    event_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    type?: true
    timestamp?: true
    user_id?: true
    event_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    type?: true
    timestamp?: true
    user_id?: true
    event_id?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string
    body: string
    type: string
    timestamp: Date
    user_id: number
    event_id: number
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    type?: boolean
    timestamp?: boolean
    user_id?: boolean
    event_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    type?: boolean
    timestamp?: boolean
    user_id?: boolean
    event_id?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      body: string
      type: string
      timestamp: Date
      user_id: number
      event_id: number
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly timestamp: FieldRef<"Notification", 'DateTime'>
    readonly user_id: FieldRef<"Notification", 'Int'>
    readonly event_id: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model Amenities
   */

  export type AggregateAmenities = {
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  export type AmenitiesAvgAggregateOutputType = {
    amenity_id: number | null
    event_id: number | null
  }

  export type AmenitiesSumAggregateOutputType = {
    amenity_id: number | null
    event_id: number | null
  }

  export type AmenitiesMinAggregateOutputType = {
    amenity_id: number | null
    event_id: number | null
    name: string | null
    description: string | null
    latitude: Date | null
    longitude: string | null
    image_url: string | null
  }

  export type AmenitiesMaxAggregateOutputType = {
    amenity_id: number | null
    event_id: number | null
    name: string | null
    description: string | null
    latitude: Date | null
    longitude: string | null
    image_url: string | null
  }

  export type AmenitiesCountAggregateOutputType = {
    amenity_id: number
    event_id: number
    name: number
    description: number
    latitude: number
    longitude: number
    image_url: number
    _all: number
  }


  export type AmenitiesAvgAggregateInputType = {
    amenity_id?: true
    event_id?: true
  }

  export type AmenitiesSumAggregateInputType = {
    amenity_id?: true
    event_id?: true
  }

  export type AmenitiesMinAggregateInputType = {
    amenity_id?: true
    event_id?: true
    name?: true
    description?: true
    latitude?: true
    longitude?: true
    image_url?: true
  }

  export type AmenitiesMaxAggregateInputType = {
    amenity_id?: true
    event_id?: true
    name?: true
    description?: true
    latitude?: true
    longitude?: true
    image_url?: true
  }

  export type AmenitiesCountAggregateInputType = {
    amenity_id?: true
    event_id?: true
    name?: true
    description?: true
    latitude?: true
    longitude?: true
    image_url?: true
    _all?: true
  }

  export type AmenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to aggregate.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenitiesMaxAggregateInputType
  }

  export type GetAmenitiesAggregateType<T extends AmenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenities[P]>
      : GetScalarType<T[P], AggregateAmenities[P]>
  }




  export type AmenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithAggregationInput | AmenitiesOrderByWithAggregationInput[]
    by: AmenitiesScalarFieldEnum[] | AmenitiesScalarFieldEnum
    having?: AmenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenitiesCountAggregateInputType | true
    _avg?: AmenitiesAvgAggregateInputType
    _sum?: AmenitiesSumAggregateInputType
    _min?: AmenitiesMinAggregateInputType
    _max?: AmenitiesMaxAggregateInputType
  }

  export type AmenitiesGroupByOutputType = {
    amenity_id: number
    event_id: number
    name: string
    description: string
    latitude: Date
    longitude: string
    image_url: string
    _count: AmenitiesCountAggregateOutputType | null
    _avg: AmenitiesAvgAggregateOutputType | null
    _sum: AmenitiesSumAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  type GetAmenitiesGroupByPayload<T extends AmenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
        }
      >
    >


  export type AmenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    amenity_id?: boolean
    event_id?: boolean
    name?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    image_url?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectScalar = {
    amenity_id?: boolean
    event_id?: boolean
    name?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    image_url?: boolean
  }

  export type AmenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $AmenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenities"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      amenity_id: number
      event_id: number
      name: string
      description: string
      latitude: Date
      longitude: string
      image_url: string
    }, ExtArgs["result"]["amenities"]>
    composites: {}
  }


  type AmenitiesGetPayload<S extends boolean | null | undefined | AmenitiesDefaultArgs> = $Result.GetResult<Prisma.$AmenitiesPayload, S>

  type AmenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AmenitiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AmenitiesCountAggregateInputType | true
    }

  export interface AmenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenities'], meta: { name: 'Amenities' } }
    /**
     * Find zero or one Amenities that matches the filter.
     * @param {AmenitiesFindUniqueArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AmenitiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesFindUniqueArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Amenities that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AmenitiesFindUniqueOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AmenitiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AmenitiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesFindFirstArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AmenitiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenities.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenities.findMany({ take: 10 })
     * 
     * // Only select the `amenity_id`
     * const amenitiesWithAmenity_idOnly = await prisma.amenities.findMany({ select: { amenity_id: true } })
     * 
    **/
    findMany<T extends AmenitiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Amenities.
     * @param {AmenitiesCreateArgs} args - Arguments to create a Amenities.
     * @example
     * // Create one Amenities
     * const Amenities = await prisma.amenities.create({
     *   data: {
     *     // ... data to create a Amenities
     *   }
     * })
     * 
    **/
    create<T extends AmenitiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesCreateArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Amenities.
     *     @param {AmenitiesCreateManyArgs} args - Arguments to create many Amenities.
     *     @example
     *     // Create many Amenities
     *     const amenities = await prisma.amenities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AmenitiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenities.
     * @param {AmenitiesDeleteArgs} args - Arguments to delete one Amenities.
     * @example
     * // Delete one Amenities
     * const Amenities = await prisma.amenities.delete({
     *   where: {
     *     // ... filter to delete one Amenities
     *   }
     * })
     * 
    **/
    delete<T extends AmenitiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesDeleteArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Amenities.
     * @param {AmenitiesUpdateArgs} args - Arguments to update one Amenities.
     * @example
     * // Update one Amenities
     * const amenities = await prisma.amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AmenitiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesUpdateArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Amenities.
     * @param {AmenitiesDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AmenitiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AmenitiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AmenitiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenities.
     * @param {AmenitiesUpsertArgs} args - Arguments to update or create a Amenities.
     * @example
     * // Update or create a Amenities
     * const amenities = await prisma.amenities.upsert({
     *   create: {
     *     // ... data to create a Amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenities we want to update
     *   }
     * })
    **/
    upsert<T extends AmenitiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AmenitiesUpsertArgs<ExtArgs>>
    ): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenities.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenitiesCountArgs>(
      args?: Subset<T, AmenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenitiesAggregateArgs>(args: Subset<T, AmenitiesAggregateArgs>): Prisma.PrismaPromise<GetAmenitiesAggregateType<T>>

    /**
     * Group by Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenitiesGroupByArgs['orderBy'] }
        : { orderBy?: AmenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenities model
   */
  readonly fields: AmenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Amenities model
   */ 
  interface AmenitiesFieldRefs {
    readonly amenity_id: FieldRef<"Amenities", 'Int'>
    readonly event_id: FieldRef<"Amenities", 'Int'>
    readonly name: FieldRef<"Amenities", 'String'>
    readonly description: FieldRef<"Amenities", 'String'>
    readonly latitude: FieldRef<"Amenities", 'DateTime'>
    readonly longitude: FieldRef<"Amenities", 'String'>
    readonly image_url: FieldRef<"Amenities", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Amenities findUnique
   */
  export type AmenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }


  /**
   * Amenities findUniqueOrThrow
   */
  export type AmenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }


  /**
   * Amenities findFirst
   */
  export type AmenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }


  /**
   * Amenities findFirstOrThrow
   */
  export type AmenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }


  /**
   * Amenities findMany
   */
  export type AmenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }


  /**
   * Amenities create
   */
  export type AmenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenities.
     */
    data: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
  }


  /**
   * Amenities createMany
   */
  export type AmenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Amenities update
   */
  export type AmenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenities.
     */
    data: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
    /**
     * Choose, which Amenities to update.
     */
    where: AmenitiesWhereUniqueInput
  }


  /**
   * Amenities updateMany
   */
  export type AmenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
  }


  /**
   * Amenities upsert
   */
  export type AmenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenities to update in case it exists.
     */
    where: AmenitiesWhereUniqueInput
    /**
     * In case the Amenities found by the `where` argument doesn't exist, create a new Amenities with this data.
     */
    create: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
    /**
     * In case the Amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
  }


  /**
   * Amenities delete
   */
  export type AmenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter which Amenities to delete.
     */
    where: AmenitiesWhereUniqueInput
  }


  /**
   * Amenities deleteMany
   */
  export type AmenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenitiesWhereInput
  }


  /**
   * Amenities without action
   */
  export type AmenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AmenitiesInclude<ExtArgs> | null
  }



  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    id: number | null
  }

  export type VenueSumAggregateOutputType = {
    id: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    latitude: Date | null
    longitude: string | null
  }

  export type VenueMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    latitude: Date | null
    longitude: string | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    name: number
    address: number
    latitude: number
    longitude: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    id?: true
  }

  export type VenueSumAggregateInputType = {
    id?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: number
    name: string
    address: string
    latitude: Date
    longitude: string
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    event?: boolean | Venue$eventArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | Venue$eventArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      latitude: Date
      longitude: string
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }


  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VenueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Venue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VenueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VenueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
    **/
    create<T extends VenueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VenueCreateArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Venues.
     *     @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     *     @example
     *     // Create many Venues
     *     const venue = await prisma.venue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VenueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
    **/
    delete<T extends VenueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VenueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VenueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VenueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
    **/
    upsert<T extends VenueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>
    ): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends Venue$eventArgs<ExtArgs> = {}>(args?: Subset<T, Venue$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Venue model
   */ 
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'Int'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly address: FieldRef<"Venue", 'String'>
    readonly latitude: FieldRef<"Venue", 'DateTime'>
    readonly longitude: FieldRef<"Venue", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }


  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }


  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }


  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }


  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }


  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }


  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }


  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
  }


  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }


  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }


  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
  }


  /**
   * Venue.event
   */
  export type Venue$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }


  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VenueInclude<ExtArgs> | null
  }



  /**
   * Model Emergency_Contacts
   */

  export type AggregateEmergency_Contacts = {
    _count: Emergency_ContactsCountAggregateOutputType | null
    _avg: Emergency_ContactsAvgAggregateOutputType | null
    _sum: Emergency_ContactsSumAggregateOutputType | null
    _min: Emergency_ContactsMinAggregateOutputType | null
    _max: Emergency_ContactsMaxAggregateOutputType | null
  }

  export type Emergency_ContactsAvgAggregateOutputType = {
    id: number | null
    event_id: number | null
  }

  export type Emergency_ContactsSumAggregateOutputType = {
    id: number | null
    event_id: number | null
  }

  export type Emergency_ContactsMinAggregateOutputType = {
    id: number | null
    event_id: number | null
    contact_name: string | null
    contact_number: string | null
    contact_type: string | null
  }

  export type Emergency_ContactsMaxAggregateOutputType = {
    id: number | null
    event_id: number | null
    contact_name: string | null
    contact_number: string | null
    contact_type: string | null
  }

  export type Emergency_ContactsCountAggregateOutputType = {
    id: number
    event_id: number
    contact_name: number
    contact_number: number
    contact_type: number
    _all: number
  }


  export type Emergency_ContactsAvgAggregateInputType = {
    id?: true
    event_id?: true
  }

  export type Emergency_ContactsSumAggregateInputType = {
    id?: true
    event_id?: true
  }

  export type Emergency_ContactsMinAggregateInputType = {
    id?: true
    event_id?: true
    contact_name?: true
    contact_number?: true
    contact_type?: true
  }

  export type Emergency_ContactsMaxAggregateInputType = {
    id?: true
    event_id?: true
    contact_name?: true
    contact_number?: true
    contact_type?: true
  }

  export type Emergency_ContactsCountAggregateInputType = {
    id?: true
    event_id?: true
    contact_name?: true
    contact_number?: true
    contact_type?: true
    _all?: true
  }

  export type Emergency_ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emergency_Contacts to aggregate.
     */
    where?: Emergency_ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergency_Contacts to fetch.
     */
    orderBy?: Emergency_ContactsOrderByWithRelationInput | Emergency_ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Emergency_ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergency_Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergency_Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emergency_Contacts
    **/
    _count?: true | Emergency_ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Emergency_ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Emergency_ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Emergency_ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Emergency_ContactsMaxAggregateInputType
  }

  export type GetEmergency_ContactsAggregateType<T extends Emergency_ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergency_Contacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergency_Contacts[P]>
      : GetScalarType<T[P], AggregateEmergency_Contacts[P]>
  }




  export type Emergency_ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Emergency_ContactsWhereInput
    orderBy?: Emergency_ContactsOrderByWithAggregationInput | Emergency_ContactsOrderByWithAggregationInput[]
    by: Emergency_ContactsScalarFieldEnum[] | Emergency_ContactsScalarFieldEnum
    having?: Emergency_ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Emergency_ContactsCountAggregateInputType | true
    _avg?: Emergency_ContactsAvgAggregateInputType
    _sum?: Emergency_ContactsSumAggregateInputType
    _min?: Emergency_ContactsMinAggregateInputType
    _max?: Emergency_ContactsMaxAggregateInputType
  }

  export type Emergency_ContactsGroupByOutputType = {
    id: number
    event_id: number
    contact_name: string
    contact_number: string
    contact_type: string
    _count: Emergency_ContactsCountAggregateOutputType | null
    _avg: Emergency_ContactsAvgAggregateOutputType | null
    _sum: Emergency_ContactsSumAggregateOutputType | null
    _min: Emergency_ContactsMinAggregateOutputType | null
    _max: Emergency_ContactsMaxAggregateOutputType | null
  }

  type GetEmergency_ContactsGroupByPayload<T extends Emergency_ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Emergency_ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Emergency_ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Emergency_ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], Emergency_ContactsGroupByOutputType[P]>
        }
      >
    >


  export type Emergency_ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_id?: boolean
    contact_name?: boolean
    contact_number?: boolean
    contact_type?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emergency_Contacts"]>

  export type Emergency_ContactsSelectScalar = {
    id?: boolean
    event_id?: boolean
    contact_name?: boolean
    contact_number?: boolean
    contact_type?: boolean
  }

  export type Emergency_ContactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }


  export type $Emergency_ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emergency_Contacts"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      event_id: number
      contact_name: string
      contact_number: string
      contact_type: string
    }, ExtArgs["result"]["emergency_Contacts"]>
    composites: {}
  }


  type Emergency_ContactsGetPayload<S extends boolean | null | undefined | Emergency_ContactsDefaultArgs> = $Result.GetResult<Prisma.$Emergency_ContactsPayload, S>

  type Emergency_ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Emergency_ContactsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Emergency_ContactsCountAggregateInputType | true
    }

  export interface Emergency_ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emergency_Contacts'], meta: { name: 'Emergency_Contacts' } }
    /**
     * Find zero or one Emergency_Contacts that matches the filter.
     * @param {Emergency_ContactsFindUniqueArgs} args - Arguments to find a Emergency_Contacts
     * @example
     * // Get one Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Emergency_ContactsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsFindUniqueArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Emergency_Contacts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Emergency_ContactsFindUniqueOrThrowArgs} args - Arguments to find a Emergency_Contacts
     * @example
     * // Get one Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Emergency_ContactsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Emergency_Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsFindFirstArgs} args - Arguments to find a Emergency_Contacts
     * @example
     * // Get one Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Emergency_ContactsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsFindFirstArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Emergency_Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsFindFirstOrThrowArgs} args - Arguments to find a Emergency_Contacts
     * @example
     * // Get one Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Emergency_ContactsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Emergency_Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findMany()
     * 
     * // Get first 10 Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergency_ContactsWithIdOnly = await prisma.emergency_Contacts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Emergency_ContactsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Emergency_Contacts.
     * @param {Emergency_ContactsCreateArgs} args - Arguments to create a Emergency_Contacts.
     * @example
     * // Create one Emergency_Contacts
     * const Emergency_Contacts = await prisma.emergency_Contacts.create({
     *   data: {
     *     // ... data to create a Emergency_Contacts
     *   }
     * })
     * 
    **/
    create<T extends Emergency_ContactsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsCreateArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Emergency_Contacts.
     *     @param {Emergency_ContactsCreateManyArgs} args - Arguments to create many Emergency_Contacts.
     *     @example
     *     // Create many Emergency_Contacts
     *     const emergency_Contacts = await prisma.emergency_Contacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Emergency_ContactsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emergency_Contacts.
     * @param {Emergency_ContactsDeleteArgs} args - Arguments to delete one Emergency_Contacts.
     * @example
     * // Delete one Emergency_Contacts
     * const Emergency_Contacts = await prisma.emergency_Contacts.delete({
     *   where: {
     *     // ... filter to delete one Emergency_Contacts
     *   }
     * })
     * 
    **/
    delete<T extends Emergency_ContactsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsDeleteArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Emergency_Contacts.
     * @param {Emergency_ContactsUpdateArgs} args - Arguments to update one Emergency_Contacts.
     * @example
     * // Update one Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Emergency_ContactsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsUpdateArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Emergency_Contacts.
     * @param {Emergency_ContactsDeleteManyArgs} args - Arguments to filter Emergency_Contacts to delete.
     * @example
     * // Delete a few Emergency_Contacts
     * const { count } = await prisma.emergency_Contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Emergency_ContactsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Emergency_ContactsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emergency_Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Emergency_ContactsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emergency_Contacts.
     * @param {Emergency_ContactsUpsertArgs} args - Arguments to update or create a Emergency_Contacts.
     * @example
     * // Update or create a Emergency_Contacts
     * const emergency_Contacts = await prisma.emergency_Contacts.upsert({
     *   create: {
     *     // ... data to create a Emergency_Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emergency_Contacts we want to update
     *   }
     * })
    **/
    upsert<T extends Emergency_ContactsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Emergency_ContactsUpsertArgs<ExtArgs>>
    ): Prisma__Emergency_ContactsClient<$Result.GetResult<Prisma.$Emergency_ContactsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Emergency_Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsCountArgs} args - Arguments to filter Emergency_Contacts to count.
     * @example
     * // Count the number of Emergency_Contacts
     * const count = await prisma.emergency_Contacts.count({
     *   where: {
     *     // ... the filter for the Emergency_Contacts we want to count
     *   }
     * })
    **/
    count<T extends Emergency_ContactsCountArgs>(
      args?: Subset<T, Emergency_ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Emergency_ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emergency_Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Emergency_ContactsAggregateArgs>(args: Subset<T, Emergency_ContactsAggregateArgs>): Prisma.PrismaPromise<GetEmergency_ContactsAggregateType<T>>

    /**
     * Group by Emergency_Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Emergency_ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Emergency_ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Emergency_ContactsGroupByArgs['orderBy'] }
        : { orderBy?: Emergency_ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Emergency_ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergency_ContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emergency_Contacts model
   */
  readonly fields: Emergency_ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emergency_Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Emergency_ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Emergency_Contacts model
   */ 
  interface Emergency_ContactsFieldRefs {
    readonly id: FieldRef<"Emergency_Contacts", 'Int'>
    readonly event_id: FieldRef<"Emergency_Contacts", 'Int'>
    readonly contact_name: FieldRef<"Emergency_Contacts", 'String'>
    readonly contact_number: FieldRef<"Emergency_Contacts", 'String'>
    readonly contact_type: FieldRef<"Emergency_Contacts", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Emergency_Contacts findUnique
   */
  export type Emergency_ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Emergency_Contacts to fetch.
     */
    where: Emergency_ContactsWhereUniqueInput
  }


  /**
   * Emergency_Contacts findUniqueOrThrow
   */
  export type Emergency_ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Emergency_Contacts to fetch.
     */
    where: Emergency_ContactsWhereUniqueInput
  }


  /**
   * Emergency_Contacts findFirst
   */
  export type Emergency_ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Emergency_Contacts to fetch.
     */
    where?: Emergency_ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergency_Contacts to fetch.
     */
    orderBy?: Emergency_ContactsOrderByWithRelationInput | Emergency_ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emergency_Contacts.
     */
    cursor?: Emergency_ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergency_Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergency_Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emergency_Contacts.
     */
    distinct?: Emergency_ContactsScalarFieldEnum | Emergency_ContactsScalarFieldEnum[]
  }


  /**
   * Emergency_Contacts findFirstOrThrow
   */
  export type Emergency_ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Emergency_Contacts to fetch.
     */
    where?: Emergency_ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergency_Contacts to fetch.
     */
    orderBy?: Emergency_ContactsOrderByWithRelationInput | Emergency_ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emergency_Contacts.
     */
    cursor?: Emergency_ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergency_Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergency_Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emergency_Contacts.
     */
    distinct?: Emergency_ContactsScalarFieldEnum | Emergency_ContactsScalarFieldEnum[]
  }


  /**
   * Emergency_Contacts findMany
   */
  export type Emergency_ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Emergency_Contacts to fetch.
     */
    where?: Emergency_ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergency_Contacts to fetch.
     */
    orderBy?: Emergency_ContactsOrderByWithRelationInput | Emergency_ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emergency_Contacts.
     */
    cursor?: Emergency_ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergency_Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergency_Contacts.
     */
    skip?: number
    distinct?: Emergency_ContactsScalarFieldEnum | Emergency_ContactsScalarFieldEnum[]
  }


  /**
   * Emergency_Contacts create
   */
  export type Emergency_ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * The data needed to create a Emergency_Contacts.
     */
    data: XOR<Emergency_ContactsCreateInput, Emergency_ContactsUncheckedCreateInput>
  }


  /**
   * Emergency_Contacts createMany
   */
  export type Emergency_ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emergency_Contacts.
     */
    data: Emergency_ContactsCreateManyInput | Emergency_ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Emergency_Contacts update
   */
  export type Emergency_ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * The data needed to update a Emergency_Contacts.
     */
    data: XOR<Emergency_ContactsUpdateInput, Emergency_ContactsUncheckedUpdateInput>
    /**
     * Choose, which Emergency_Contacts to update.
     */
    where: Emergency_ContactsWhereUniqueInput
  }


  /**
   * Emergency_Contacts updateMany
   */
  export type Emergency_ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emergency_Contacts.
     */
    data: XOR<Emergency_ContactsUpdateManyMutationInput, Emergency_ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Emergency_Contacts to update
     */
    where?: Emergency_ContactsWhereInput
  }


  /**
   * Emergency_Contacts upsert
   */
  export type Emergency_ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * The filter to search for the Emergency_Contacts to update in case it exists.
     */
    where: Emergency_ContactsWhereUniqueInput
    /**
     * In case the Emergency_Contacts found by the `where` argument doesn't exist, create a new Emergency_Contacts with this data.
     */
    create: XOR<Emergency_ContactsCreateInput, Emergency_ContactsUncheckedCreateInput>
    /**
     * In case the Emergency_Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Emergency_ContactsUpdateInput, Emergency_ContactsUncheckedUpdateInput>
  }


  /**
   * Emergency_Contacts delete
   */
  export type Emergency_ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
    /**
     * Filter which Emergency_Contacts to delete.
     */
    where: Emergency_ContactsWhereUniqueInput
  }


  /**
   * Emergency_Contacts deleteMany
   */
  export type Emergency_ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emergency_Contacts to delete
     */
    where?: Emergency_ContactsWhereInput
  }


  /**
   * Emergency_Contacts without action
   */
  export type Emergency_ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency_Contacts
     */
    select?: Emergency_ContactsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Emergency_ContactsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    full_name: 'full_name',
    email: 'email',
    password: 'password',
    contact_number: 'contact_number',
    token: 'token',
    role_id: 'role_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const EventScalarFieldEnum: {
    event_id: 'event_id',
    event_name: 'event_name',
    event_description: 'event_description',
    location: 'location',
    start_date: 'start_date',
    end_date: 'end_date',
    event_tags: 'event_tags',
    creator_id: 'creator_id',
    approval: 'approval',
    status: 'status',
    entry_fee: 'entry_fee',
    thumbnail_link: 'thumbnail_link',
    banner_link: 'banner_link',
    video_link: 'video_link',
    venue_id: 'venue_id'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    plan_id: 'plan_id',
    plan_features: 'plan_features',
    payment: 'payment',
    plan_name: 'plan_name'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    plan_id: 'plan_id',
    amount: 'amount',
    GST: 'GST',
    transaction_id: 'transaction_id',
    transaction_type: 'transaction_type'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const User_PlanScalarFieldEnum: {
    plan_id: 'plan_id',
    user_id: 'user_id',
    is_activate: 'is_activate'
  };

  export type User_PlanScalarFieldEnum = (typeof User_PlanScalarFieldEnum)[keyof typeof User_PlanScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SponsorScalarFieldEnum: {
    sponsor_id: 'sponsor_id',
    event_id: 'event_id',
    title: 'title',
    description: 'description',
    image_url: 'image_url',
    start_time: 'start_time',
    end_time: 'end_time',
    venue_id: 'venue_id'
  };

  export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    advertisement_id: 'advertisement_id',
    event_id: 'event_id',
    title: 'title',
    level: 'level',
    start_date: 'start_date',
    end_date: 'end_date',
    image_url: 'image_url'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const LostAndFoundScalarFieldEnum: {
    lost_and_found_id: 'lost_and_found_id',
    event_id: 'event_id',
    item_name: 'item_name',
    description: 'description',
    is_claimed: 'is_claimed',
    claim_user_id: 'claim_user_id',
    reporting_timestamp: 'reporting_timestamp',
    claim_timestamp: 'claim_timestamp',
    reporter_user_id: 'reporter_user_id'
  };

  export type LostAndFoundScalarFieldEnum = (typeof LostAndFoundScalarFieldEnum)[keyof typeof LostAndFoundScalarFieldEnum]


  export const EventMapScalarFieldEnum: {
    event_map_id: 'event_map_id',
    map_object: 'map_object',
    event_id: 'event_id'
  };

  export type EventMapScalarFieldEnum = (typeof EventMapScalarFieldEnum)[keyof typeof EventMapScalarFieldEnum]


  export const ShopsScalarFieldEnum: {
    shop_id: 'shop_id',
    shop_name: 'shop_name',
    event_id: 'event_id',
    shop_type: 'shop_type'
  };

  export type ShopsScalarFieldEnum = (typeof ShopsScalarFieldEnum)[keyof typeof ShopsScalarFieldEnum]


  export const ShopPaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    amount: 'amount',
    shop_id: 'shop_id',
    event_id: 'event_id',
    user_id: 'user_id'
  };

  export type ShopPaymentScalarFieldEnum = (typeof ShopPaymentScalarFieldEnum)[keyof typeof ShopPaymentScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    review_id: 'review_id',
    review_title: 'review_title',
    review_desc: 'review_desc',
    user_id: 'user_id',
    rating: 'rating',
    timestamp: 'timestamp',
    event_id: 'event_id'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ItineraryScalarFieldEnum: {
    itinerary_id: 'itinerary_id',
    event_id: 'event_id',
    itinerary_name: 'itinerary_name',
    itinerary_description: 'itinerary_description',
    timestamp: 'timestamp',
    image_url: 'image_url'
  };

  export type ItineraryScalarFieldEnum = (typeof ItineraryScalarFieldEnum)[keyof typeof ItineraryScalarFieldEnum]


  export const FavouriteScalarFieldEnum: {
    event_id: 'event_id',
    itinerary_id: 'itinerary_id',
    user_id: 'user_id'
  };

  export type FavouriteScalarFieldEnum = (typeof FavouriteScalarFieldEnum)[keyof typeof FavouriteScalarFieldEnum]


  export const Token_TransactionScalarFieldEnum: {
    ID: 'ID',
    transaction_type: 'transaction_type',
    token: 'token',
    event_ID: 'event_ID',
    transaction_ID: 'transaction_ID',
    shop_ID: 'shop_ID'
  };

  export type Token_TransactionScalarFieldEnum = (typeof Token_TransactionScalarFieldEnum)[keyof typeof Token_TransactionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    type: 'type',
    timestamp: 'timestamp',
    user_id: 'user_id',
    event_id: 'event_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AmenitiesScalarFieldEnum: {
    amenity_id: 'amenity_id',
    event_id: 'event_id',
    name: 'name',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    image_url: 'image_url'
  };

  export type AmenitiesScalarFieldEnum = (typeof AmenitiesScalarFieldEnum)[keyof typeof AmenitiesScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const Emergency_ContactsScalarFieldEnum: {
    id: 'id',
    event_id: 'event_id',
    contact_name: 'contact_name',
    contact_number: 'contact_number',
    contact_type: 'contact_type'
  };

  export type Emergency_ContactsScalarFieldEnum = (typeof Emergency_ContactsScalarFieldEnum)[keyof typeof Emergency_ContactsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    contact_number?: StringFilter<"User"> | string
    token?: IntFilter<"User"> | number
    role_id?: IntFilter<"User"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    User_plan?: User_PlanListRelationFilter
    transaction?: TransactionListRelationFilter
    event?: EventListRelationFilter
    shoppayment?: ShopPaymentListRelationFilter
    review?: ReviewListRelationFilter
    favourite?: FavouriteListRelationFilter
    notification?: NotificationListRelationFilter
    claim_user?: LostAndFoundListRelationFilter
    reporter_user?: LostAndFoundListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact_number?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    User_plan?: User_PlanOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    event?: EventOrderByRelationAggregateInput
    shoppayment?: ShopPaymentOrderByRelationAggregateInput
    review?: ReviewOrderByRelationAggregateInput
    favourite?: FavouriteOrderByRelationAggregateInput
    notification?: NotificationOrderByRelationAggregateInput
    claim_user?: LostAndFoundOrderByRelationAggregateInput
    reporter_user?: LostAndFoundOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    contact_number?: StringFilter<"User"> | string
    token?: IntFilter<"User"> | number
    role_id?: IntFilter<"User"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    User_plan?: User_PlanListRelationFilter
    transaction?: TransactionListRelationFilter
    event?: EventListRelationFilter
    shoppayment?: ShopPaymentListRelationFilter
    review?: ReviewListRelationFilter
    favourite?: FavouriteListRelationFilter
    notification?: NotificationListRelationFilter
    claim_user?: LostAndFoundListRelationFilter
    reporter_user?: LostAndFoundListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }, "user_id" | "email">

  export type UserOrderByWithAggregationInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact_number?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"User"> | number
    full_name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    contact_number?: StringWithAggregatesFilter<"User"> | string
    token?: IntWithAggregatesFilter<"User"> | number
    role_id?: IntWithAggregatesFilter<"User"> | number
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshToken"> | number
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    event_id?: IntFilter<"Event"> | number
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    location?: StringFilter<"Event"> | string
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    event_tags?: StringFilter<"Event"> | string
    creator_id?: IntFilter<"Event"> | number
    approval?: BoolFilter<"Event"> | boolean
    status?: StringFilter<"Event"> | string
    entry_fee?: FloatFilter<"Event"> | number
    thumbnail_link?: StringFilter<"Event"> | string
    banner_link?: DateTimeFilter<"Event"> | Date | string
    video_link?: DateTimeFilter<"Event"> | Date | string
    venue_id?: IntFilter<"Event"> | number
    creator?: XOR<UserRelationFilter, UserWhereInput>
    lostandfound?: LostAndFoundListRelationFilter
    sponsor?: SponsorListRelationFilter
    advertisement?: AdvertisementListRelationFilter
    eventmap?: EventMapListRelationFilter
    shop?: ShopsListRelationFilter
    shoppayment?: ShopPaymentListRelationFilter
    review?: ReviewListRelationFilter
    itinerary?: ItineraryListRelationFilter
    favourite?: FavouriteListRelationFilter
    tokentransaction?: Token_TransactionListRelationFilter
    amenities?: AmenitiesListRelationFilter
    emergency_contacts?: Emergency_ContactsListRelationFilter
    venue?: VenueListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    event_tags?: SortOrder
    creator_id?: SortOrder
    approval?: SortOrder
    status?: SortOrder
    entry_fee?: SortOrder
    thumbnail_link?: SortOrder
    banner_link?: SortOrder
    video_link?: SortOrder
    venue_id?: SortOrder
    creator?: UserOrderByWithRelationInput
    lostandfound?: LostAndFoundOrderByRelationAggregateInput
    sponsor?: SponsorOrderByRelationAggregateInput
    advertisement?: AdvertisementOrderByRelationAggregateInput
    eventmap?: EventMapOrderByRelationAggregateInput
    shop?: ShopsOrderByRelationAggregateInput
    shoppayment?: ShopPaymentOrderByRelationAggregateInput
    review?: ReviewOrderByRelationAggregateInput
    itinerary?: ItineraryOrderByRelationAggregateInput
    favourite?: FavouriteOrderByRelationAggregateInput
    tokentransaction?: Token_TransactionOrderByRelationAggregateInput
    amenities?: AmenitiesOrderByRelationAggregateInput
    emergency_contacts?: Emergency_ContactsOrderByRelationAggregateInput
    venue?: VenueOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    event_id?: number
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    location?: StringFilter<"Event"> | string
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    event_tags?: StringFilter<"Event"> | string
    creator_id?: IntFilter<"Event"> | number
    approval?: BoolFilter<"Event"> | boolean
    status?: StringFilter<"Event"> | string
    entry_fee?: FloatFilter<"Event"> | number
    thumbnail_link?: StringFilter<"Event"> | string
    banner_link?: DateTimeFilter<"Event"> | Date | string
    video_link?: DateTimeFilter<"Event"> | Date | string
    venue_id?: IntFilter<"Event"> | number
    creator?: XOR<UserRelationFilter, UserWhereInput>
    lostandfound?: LostAndFoundListRelationFilter
    sponsor?: SponsorListRelationFilter
    advertisement?: AdvertisementListRelationFilter
    eventmap?: EventMapListRelationFilter
    shop?: ShopsListRelationFilter
    shoppayment?: ShopPaymentListRelationFilter
    review?: ReviewListRelationFilter
    itinerary?: ItineraryListRelationFilter
    favourite?: FavouriteListRelationFilter
    tokentransaction?: Token_TransactionListRelationFilter
    amenities?: AmenitiesListRelationFilter
    emergency_contacts?: Emergency_ContactsListRelationFilter
    venue?: VenueListRelationFilter
  }, "event_id">

  export type EventOrderByWithAggregationInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    event_tags?: SortOrder
    creator_id?: SortOrder
    approval?: SortOrder
    status?: SortOrder
    entry_fee?: SortOrder
    thumbnail_link?: SortOrder
    banner_link?: SortOrder
    video_link?: SortOrder
    venue_id?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    event_id?: IntWithAggregatesFilter<"Event"> | number
    event_name?: StringWithAggregatesFilter<"Event"> | string
    event_description?: StringWithAggregatesFilter<"Event"> | string
    location?: StringWithAggregatesFilter<"Event"> | string
    start_date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    event_tags?: StringWithAggregatesFilter<"Event"> | string
    creator_id?: IntWithAggregatesFilter<"Event"> | number
    approval?: BoolWithAggregatesFilter<"Event"> | boolean
    status?: StringWithAggregatesFilter<"Event"> | string
    entry_fee?: FloatWithAggregatesFilter<"Event"> | number
    thumbnail_link?: StringWithAggregatesFilter<"Event"> | string
    banner_link?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    video_link?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    venue_id?: IntWithAggregatesFilter<"Event"> | number
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    plan_id?: IntFilter<"Plan"> | number
    plan_features?: StringFilter<"Plan"> | string
    payment?: FloatFilter<"Plan"> | number
    plan_name?: StringFilter<"Plan"> | string
    user_plan?: User_PlanListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    plan_id?: SortOrder
    plan_features?: SortOrder
    payment?: SortOrder
    plan_name?: SortOrder
    user_plan?: User_PlanOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    plan_id?: number
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    plan_features?: StringFilter<"Plan"> | string
    payment?: FloatFilter<"Plan"> | number
    plan_name?: StringFilter<"Plan"> | string
    user_plan?: User_PlanListRelationFilter
  }, "plan_id">

  export type PlanOrderByWithAggregationInput = {
    plan_id?: SortOrder
    plan_features?: SortOrder
    payment?: SortOrder
    plan_name?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    plan_id?: IntWithAggregatesFilter<"Plan"> | number
    plan_features?: StringWithAggregatesFilter<"Plan"> | string
    payment?: FloatWithAggregatesFilter<"Plan"> | number
    plan_name?: StringWithAggregatesFilter<"Plan"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    user_id?: IntFilter<"Transaction"> | number
    plan_id?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    GST?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFilter<"Transaction"> | string
    transaction_type?: StringFilter<"Transaction"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    tokentransaction?: Token_TransactionListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
    transaction_id?: SortOrder
    transaction_type?: SortOrder
    User?: UserOrderByWithRelationInput
    tokentransaction?: Token_TransactionOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    user_id?: IntFilter<"Transaction"> | number
    plan_id?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    GST?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFilter<"Transaction"> | string
    transaction_type?: StringFilter<"Transaction"> | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    tokentransaction?: Token_TransactionListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
    transaction_id?: SortOrder
    transaction_type?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    user_id?: IntWithAggregatesFilter<"Transaction"> | number
    plan_id?: IntWithAggregatesFilter<"Transaction"> | number
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    GST?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    transaction_id?: StringWithAggregatesFilter<"Transaction"> | string
    transaction_type?: StringWithAggregatesFilter<"Transaction"> | string
  }

  export type User_PlanWhereInput = {
    AND?: User_PlanWhereInput | User_PlanWhereInput[]
    OR?: User_PlanWhereInput[]
    NOT?: User_PlanWhereInput | User_PlanWhereInput[]
    plan_id?: IntFilter<"User_Plan"> | number
    user_id?: IntFilter<"User_Plan"> | number
    is_activate?: BoolFilter<"User_Plan"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }

  export type User_PlanOrderByWithRelationInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
    is_activate?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
  }

  export type User_PlanWhereUniqueInput = Prisma.AtLeast<{
    plan_id_user_id?: User_PlanPlan_idUser_idCompoundUniqueInput
    AND?: User_PlanWhereInput | User_PlanWhereInput[]
    OR?: User_PlanWhereInput[]
    NOT?: User_PlanWhereInput | User_PlanWhereInput[]
    plan_id?: IntFilter<"User_Plan"> | number
    user_id?: IntFilter<"User_Plan"> | number
    is_activate?: BoolFilter<"User_Plan"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
  }, "plan_id_user_id">

  export type User_PlanOrderByWithAggregationInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
    is_activate?: SortOrder
    _count?: User_PlanCountOrderByAggregateInput
    _avg?: User_PlanAvgOrderByAggregateInput
    _max?: User_PlanMaxOrderByAggregateInput
    _min?: User_PlanMinOrderByAggregateInput
    _sum?: User_PlanSumOrderByAggregateInput
  }

  export type User_PlanScalarWhereWithAggregatesInput = {
    AND?: User_PlanScalarWhereWithAggregatesInput | User_PlanScalarWhereWithAggregatesInput[]
    OR?: User_PlanScalarWhereWithAggregatesInput[]
    NOT?: User_PlanScalarWhereWithAggregatesInput | User_PlanScalarWhereWithAggregatesInput[]
    plan_id?: IntWithAggregatesFilter<"User_Plan"> | number
    user_id?: IntWithAggregatesFilter<"User_Plan"> | number
    is_activate?: BoolWithAggregatesFilter<"User_Plan"> | boolean
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_id?: IntFilter<"Role"> | number
    role_name?: StringFilter<"Role"> | string
    user?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_name?: StringFilter<"Role"> | string
    user?: UserListRelationFilter
  }, "role_id">

  export type RoleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"Role"> | number
    role_name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type SponsorWhereInput = {
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    sponsor_id?: IntFilter<"Sponsor"> | number
    event_id?: IntFilter<"Sponsor"> | number
    title?: StringFilter<"Sponsor"> | string
    description?: StringFilter<"Sponsor"> | string
    image_url?: StringFilter<"Sponsor"> | string
    start_time?: StringFilter<"Sponsor"> | string
    end_time?: StringFilter<"Sponsor"> | string
    venue_id?: IntFilter<"Sponsor"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type SponsorOrderByWithRelationInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    venue_id?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type SponsorWhereUniqueInput = Prisma.AtLeast<{
    sponsor_id?: number
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    event_id?: IntFilter<"Sponsor"> | number
    title?: StringFilter<"Sponsor"> | string
    description?: StringFilter<"Sponsor"> | string
    image_url?: StringFilter<"Sponsor"> | string
    start_time?: StringFilter<"Sponsor"> | string
    end_time?: StringFilter<"Sponsor"> | string
    venue_id?: IntFilter<"Sponsor"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "sponsor_id">

  export type SponsorOrderByWithAggregationInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    venue_id?: SortOrder
    _count?: SponsorCountOrderByAggregateInput
    _avg?: SponsorAvgOrderByAggregateInput
    _max?: SponsorMaxOrderByAggregateInput
    _min?: SponsorMinOrderByAggregateInput
    _sum?: SponsorSumOrderByAggregateInput
  }

  export type SponsorScalarWhereWithAggregatesInput = {
    AND?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    OR?: SponsorScalarWhereWithAggregatesInput[]
    NOT?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    sponsor_id?: IntWithAggregatesFilter<"Sponsor"> | number
    event_id?: IntWithAggregatesFilter<"Sponsor"> | number
    title?: StringWithAggregatesFilter<"Sponsor"> | string
    description?: StringWithAggregatesFilter<"Sponsor"> | string
    image_url?: StringWithAggregatesFilter<"Sponsor"> | string
    start_time?: StringWithAggregatesFilter<"Sponsor"> | string
    end_time?: StringWithAggregatesFilter<"Sponsor"> | string
    venue_id?: IntWithAggregatesFilter<"Sponsor"> | number
  }

  export type AdvertisementWhereInput = {
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    advertisement_id?: IntFilter<"Advertisement"> | number
    event_id?: IntFilter<"Advertisement"> | number
    title?: StringFilter<"Advertisement"> | string
    level?: StringFilter<"Advertisement"> | string
    start_date?: DateTimeFilter<"Advertisement"> | Date | string
    end_date?: DateTimeFilter<"Advertisement"> | Date | string
    image_url?: StringFilter<"Advertisement"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type AdvertisementOrderByWithRelationInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    image_url?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type AdvertisementWhereUniqueInput = Prisma.AtLeast<{
    advertisement_id?: number
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    event_id?: IntFilter<"Advertisement"> | number
    title?: StringFilter<"Advertisement"> | string
    level?: StringFilter<"Advertisement"> | string
    start_date?: DateTimeFilter<"Advertisement"> | Date | string
    end_date?: DateTimeFilter<"Advertisement"> | Date | string
    image_url?: StringFilter<"Advertisement"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "advertisement_id">

  export type AdvertisementOrderByWithAggregationInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    image_url?: SortOrder
    _count?: AdvertisementCountOrderByAggregateInput
    _avg?: AdvertisementAvgOrderByAggregateInput
    _max?: AdvertisementMaxOrderByAggregateInput
    _min?: AdvertisementMinOrderByAggregateInput
    _sum?: AdvertisementSumOrderByAggregateInput
  }

  export type AdvertisementScalarWhereWithAggregatesInput = {
    AND?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    OR?: AdvertisementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    advertisement_id?: IntWithAggregatesFilter<"Advertisement"> | number
    event_id?: IntWithAggregatesFilter<"Advertisement"> | number
    title?: StringWithAggregatesFilter<"Advertisement"> | string
    level?: StringWithAggregatesFilter<"Advertisement"> | string
    start_date?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
    image_url?: StringWithAggregatesFilter<"Advertisement"> | string
  }

  export type LostAndFoundWhereInput = {
    AND?: LostAndFoundWhereInput | LostAndFoundWhereInput[]
    OR?: LostAndFoundWhereInput[]
    NOT?: LostAndFoundWhereInput | LostAndFoundWhereInput[]
    lost_and_found_id?: IntFilter<"LostAndFound"> | number
    event_id?: IntFilter<"LostAndFound"> | number
    item_name?: StringFilter<"LostAndFound"> | string
    description?: StringFilter<"LostAndFound"> | string
    is_claimed?: BoolFilter<"LostAndFound"> | boolean
    claim_user_id?: IntFilter<"LostAndFound"> | number
    reporting_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    claim_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    reporter_user_id?: IntFilter<"LostAndFound"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    claim_user?: XOR<UserRelationFilter, UserWhereInput>
    reporter_user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LostAndFoundOrderByWithRelationInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    is_claimed?: SortOrder
    claim_user_id?: SortOrder
    reporting_timestamp?: SortOrder
    claim_timestamp?: SortOrder
    reporter_user_id?: SortOrder
    event?: EventOrderByWithRelationInput
    claim_user?: UserOrderByWithRelationInput
    reporter_user?: UserOrderByWithRelationInput
  }

  export type LostAndFoundWhereUniqueInput = Prisma.AtLeast<{
    lost_and_found_id?: number
    AND?: LostAndFoundWhereInput | LostAndFoundWhereInput[]
    OR?: LostAndFoundWhereInput[]
    NOT?: LostAndFoundWhereInput | LostAndFoundWhereInput[]
    event_id?: IntFilter<"LostAndFound"> | number
    item_name?: StringFilter<"LostAndFound"> | string
    description?: StringFilter<"LostAndFound"> | string
    is_claimed?: BoolFilter<"LostAndFound"> | boolean
    claim_user_id?: IntFilter<"LostAndFound"> | number
    reporting_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    claim_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    reporter_user_id?: IntFilter<"LostAndFound"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    claim_user?: XOR<UserRelationFilter, UserWhereInput>
    reporter_user?: XOR<UserRelationFilter, UserWhereInput>
  }, "lost_and_found_id">

  export type LostAndFoundOrderByWithAggregationInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    is_claimed?: SortOrder
    claim_user_id?: SortOrder
    reporting_timestamp?: SortOrder
    claim_timestamp?: SortOrder
    reporter_user_id?: SortOrder
    _count?: LostAndFoundCountOrderByAggregateInput
    _avg?: LostAndFoundAvgOrderByAggregateInput
    _max?: LostAndFoundMaxOrderByAggregateInput
    _min?: LostAndFoundMinOrderByAggregateInput
    _sum?: LostAndFoundSumOrderByAggregateInput
  }

  export type LostAndFoundScalarWhereWithAggregatesInput = {
    AND?: LostAndFoundScalarWhereWithAggregatesInput | LostAndFoundScalarWhereWithAggregatesInput[]
    OR?: LostAndFoundScalarWhereWithAggregatesInput[]
    NOT?: LostAndFoundScalarWhereWithAggregatesInput | LostAndFoundScalarWhereWithAggregatesInput[]
    lost_and_found_id?: IntWithAggregatesFilter<"LostAndFound"> | number
    event_id?: IntWithAggregatesFilter<"LostAndFound"> | number
    item_name?: StringWithAggregatesFilter<"LostAndFound"> | string
    description?: StringWithAggregatesFilter<"LostAndFound"> | string
    is_claimed?: BoolWithAggregatesFilter<"LostAndFound"> | boolean
    claim_user_id?: IntWithAggregatesFilter<"LostAndFound"> | number
    reporting_timestamp?: DateTimeWithAggregatesFilter<"LostAndFound"> | Date | string
    claim_timestamp?: DateTimeWithAggregatesFilter<"LostAndFound"> | Date | string
    reporter_user_id?: IntWithAggregatesFilter<"LostAndFound"> | number
  }

  export type EventMapWhereInput = {
    AND?: EventMapWhereInput | EventMapWhereInput[]
    OR?: EventMapWhereInput[]
    NOT?: EventMapWhereInput | EventMapWhereInput[]
    event_map_id?: IntFilter<"EventMap"> | number
    map_object?: StringFilter<"EventMap"> | string
    event_id?: IntFilter<"EventMap"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type EventMapOrderByWithRelationInput = {
    event_map_id?: SortOrder
    map_object?: SortOrder
    event_id?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventMapWhereUniqueInput = Prisma.AtLeast<{
    event_map_id?: number
    AND?: EventMapWhereInput | EventMapWhereInput[]
    OR?: EventMapWhereInput[]
    NOT?: EventMapWhereInput | EventMapWhereInput[]
    map_object?: StringFilter<"EventMap"> | string
    event_id?: IntFilter<"EventMap"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "event_map_id">

  export type EventMapOrderByWithAggregationInput = {
    event_map_id?: SortOrder
    map_object?: SortOrder
    event_id?: SortOrder
    _count?: EventMapCountOrderByAggregateInput
    _avg?: EventMapAvgOrderByAggregateInput
    _max?: EventMapMaxOrderByAggregateInput
    _min?: EventMapMinOrderByAggregateInput
    _sum?: EventMapSumOrderByAggregateInput
  }

  export type EventMapScalarWhereWithAggregatesInput = {
    AND?: EventMapScalarWhereWithAggregatesInput | EventMapScalarWhereWithAggregatesInput[]
    OR?: EventMapScalarWhereWithAggregatesInput[]
    NOT?: EventMapScalarWhereWithAggregatesInput | EventMapScalarWhereWithAggregatesInput[]
    event_map_id?: IntWithAggregatesFilter<"EventMap"> | number
    map_object?: StringWithAggregatesFilter<"EventMap"> | string
    event_id?: IntWithAggregatesFilter<"EventMap"> | number
  }

  export type ShopsWhereInput = {
    AND?: ShopsWhereInput | ShopsWhereInput[]
    OR?: ShopsWhereInput[]
    NOT?: ShopsWhereInput | ShopsWhereInput[]
    shop_id?: IntFilter<"Shops"> | number
    shop_name?: StringFilter<"Shops"> | string
    event_id?: IntFilter<"Shops"> | number
    shop_type?: StringFilter<"Shops"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    shoppayment?: ShopPaymentListRelationFilter
    tokentransaction?: Token_TransactionListRelationFilter
  }

  export type ShopsOrderByWithRelationInput = {
    shop_id?: SortOrder
    shop_name?: SortOrder
    event_id?: SortOrder
    shop_type?: SortOrder
    event?: EventOrderByWithRelationInput
    shoppayment?: ShopPaymentOrderByRelationAggregateInput
    tokentransaction?: Token_TransactionOrderByRelationAggregateInput
  }

  export type ShopsWhereUniqueInput = Prisma.AtLeast<{
    shop_id?: number
    AND?: ShopsWhereInput | ShopsWhereInput[]
    OR?: ShopsWhereInput[]
    NOT?: ShopsWhereInput | ShopsWhereInput[]
    shop_name?: StringFilter<"Shops"> | string
    event_id?: IntFilter<"Shops"> | number
    shop_type?: StringFilter<"Shops"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    shoppayment?: ShopPaymentListRelationFilter
    tokentransaction?: Token_TransactionListRelationFilter
  }, "shop_id">

  export type ShopsOrderByWithAggregationInput = {
    shop_id?: SortOrder
    shop_name?: SortOrder
    event_id?: SortOrder
    shop_type?: SortOrder
    _count?: ShopsCountOrderByAggregateInput
    _avg?: ShopsAvgOrderByAggregateInput
    _max?: ShopsMaxOrderByAggregateInput
    _min?: ShopsMinOrderByAggregateInput
    _sum?: ShopsSumOrderByAggregateInput
  }

  export type ShopsScalarWhereWithAggregatesInput = {
    AND?: ShopsScalarWhereWithAggregatesInput | ShopsScalarWhereWithAggregatesInput[]
    OR?: ShopsScalarWhereWithAggregatesInput[]
    NOT?: ShopsScalarWhereWithAggregatesInput | ShopsScalarWhereWithAggregatesInput[]
    shop_id?: IntWithAggregatesFilter<"Shops"> | number
    shop_name?: StringWithAggregatesFilter<"Shops"> | string
    event_id?: IntWithAggregatesFilter<"Shops"> | number
    shop_type?: StringWithAggregatesFilter<"Shops"> | string
  }

  export type ShopPaymentWhereInput = {
    AND?: ShopPaymentWhereInput | ShopPaymentWhereInput[]
    OR?: ShopPaymentWhereInput[]
    NOT?: ShopPaymentWhereInput | ShopPaymentWhereInput[]
    payment_id?: IntFilter<"ShopPayment"> | number
    amount?: FloatFilter<"ShopPayment"> | number
    shop_id?: IntFilter<"ShopPayment"> | number
    event_id?: IntFilter<"ShopPayment"> | number
    user_id?: IntFilter<"ShopPayment"> | number
    shop?: XOR<ShopsRelationFilter, ShopsWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ShopPaymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
    shop?: ShopsOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ShopPaymentWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: number
    AND?: ShopPaymentWhereInput | ShopPaymentWhereInput[]
    OR?: ShopPaymentWhereInput[]
    NOT?: ShopPaymentWhereInput | ShopPaymentWhereInput[]
    amount?: FloatFilter<"ShopPayment"> | number
    shop_id?: IntFilter<"ShopPayment"> | number
    event_id?: IntFilter<"ShopPayment"> | number
    user_id?: IntFilter<"ShopPayment"> | number
    shop?: XOR<ShopsRelationFilter, ShopsWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "payment_id">

  export type ShopPaymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
    _count?: ShopPaymentCountOrderByAggregateInput
    _avg?: ShopPaymentAvgOrderByAggregateInput
    _max?: ShopPaymentMaxOrderByAggregateInput
    _min?: ShopPaymentMinOrderByAggregateInput
    _sum?: ShopPaymentSumOrderByAggregateInput
  }

  export type ShopPaymentScalarWhereWithAggregatesInput = {
    AND?: ShopPaymentScalarWhereWithAggregatesInput | ShopPaymentScalarWhereWithAggregatesInput[]
    OR?: ShopPaymentScalarWhereWithAggregatesInput[]
    NOT?: ShopPaymentScalarWhereWithAggregatesInput | ShopPaymentScalarWhereWithAggregatesInput[]
    payment_id?: IntWithAggregatesFilter<"ShopPayment"> | number
    amount?: FloatWithAggregatesFilter<"ShopPayment"> | number
    shop_id?: IntWithAggregatesFilter<"ShopPayment"> | number
    event_id?: IntWithAggregatesFilter<"ShopPayment"> | number
    user_id?: IntWithAggregatesFilter<"ShopPayment"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    review_id?: IntFilter<"Review"> | number
    review_title?: StringFilter<"Review"> | string
    review_desc?: StringFilter<"Review"> | string
    user_id?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    timestamp?: DateTimeFilter<"Review"> | Date | string
    event_id?: IntFilter<"Review"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    review_id?: SortOrder
    review_title?: SortOrder
    review_desc?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    timestamp?: SortOrder
    event_id?: SortOrder
    User?: UserOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    review_id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    review_title?: StringFilter<"Review"> | string
    review_desc?: StringFilter<"Review"> | string
    user_id?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    timestamp?: DateTimeFilter<"Review"> | Date | string
    event_id?: IntFilter<"Review"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "review_id">

  export type ReviewOrderByWithAggregationInput = {
    review_id?: SortOrder
    review_title?: SortOrder
    review_desc?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    timestamp?: SortOrder
    event_id?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    review_id?: IntWithAggregatesFilter<"Review"> | number
    review_title?: StringWithAggregatesFilter<"Review"> | string
    review_desc?: StringWithAggregatesFilter<"Review"> | string
    user_id?: IntWithAggregatesFilter<"Review"> | number
    rating?: IntWithAggregatesFilter<"Review"> | number
    timestamp?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    event_id?: IntWithAggregatesFilter<"Review"> | number
  }

  export type ItineraryWhereInput = {
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    itinerary_id?: IntFilter<"Itinerary"> | number
    event_id?: IntFilter<"Itinerary"> | number
    itinerary_name?: StringFilter<"Itinerary"> | string
    itinerary_description?: StringFilter<"Itinerary"> | string
    timestamp?: DateTimeFilter<"Itinerary"> | Date | string
    image_url?: StringFilter<"Itinerary"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    favourite?: FavouriteListRelationFilter
  }

  export type ItineraryOrderByWithRelationInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
    itinerary_name?: SortOrder
    itinerary_description?: SortOrder
    timestamp?: SortOrder
    image_url?: SortOrder
    event?: EventOrderByWithRelationInput
    favourite?: FavouriteOrderByRelationAggregateInput
  }

  export type ItineraryWhereUniqueInput = Prisma.AtLeast<{
    itinerary_id?: number
    AND?: ItineraryWhereInput | ItineraryWhereInput[]
    OR?: ItineraryWhereInput[]
    NOT?: ItineraryWhereInput | ItineraryWhereInput[]
    event_id?: IntFilter<"Itinerary"> | number
    itinerary_name?: StringFilter<"Itinerary"> | string
    itinerary_description?: StringFilter<"Itinerary"> | string
    timestamp?: DateTimeFilter<"Itinerary"> | Date | string
    image_url?: StringFilter<"Itinerary"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    favourite?: FavouriteListRelationFilter
  }, "itinerary_id">

  export type ItineraryOrderByWithAggregationInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
    itinerary_name?: SortOrder
    itinerary_description?: SortOrder
    timestamp?: SortOrder
    image_url?: SortOrder
    _count?: ItineraryCountOrderByAggregateInput
    _avg?: ItineraryAvgOrderByAggregateInput
    _max?: ItineraryMaxOrderByAggregateInput
    _min?: ItineraryMinOrderByAggregateInput
    _sum?: ItinerarySumOrderByAggregateInput
  }

  export type ItineraryScalarWhereWithAggregatesInput = {
    AND?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    OR?: ItineraryScalarWhereWithAggregatesInput[]
    NOT?: ItineraryScalarWhereWithAggregatesInput | ItineraryScalarWhereWithAggregatesInput[]
    itinerary_id?: IntWithAggregatesFilter<"Itinerary"> | number
    event_id?: IntWithAggregatesFilter<"Itinerary"> | number
    itinerary_name?: StringWithAggregatesFilter<"Itinerary"> | string
    itinerary_description?: StringWithAggregatesFilter<"Itinerary"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Itinerary"> | Date | string
    image_url?: StringWithAggregatesFilter<"Itinerary"> | string
  }

  export type FavouriteWhereInput = {
    AND?: FavouriteWhereInput | FavouriteWhereInput[]
    OR?: FavouriteWhereInput[]
    NOT?: FavouriteWhereInput | FavouriteWhereInput[]
    event_id?: IntFilter<"Favourite"> | number
    itinerary_id?: IntFilter<"Favourite"> | number
    user_id?: IntFilter<"Favourite"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FavouriteOrderByWithRelationInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
    event?: EventOrderByWithRelationInput
    itinerary?: ItineraryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FavouriteWhereUniqueInput = Prisma.AtLeast<{
    event_id_itinerary_id_user_id?: FavouriteEvent_idItinerary_idUser_idCompoundUniqueInput
    AND?: FavouriteWhereInput | FavouriteWhereInput[]
    OR?: FavouriteWhereInput[]
    NOT?: FavouriteWhereInput | FavouriteWhereInput[]
    event_id?: IntFilter<"Favourite"> | number
    itinerary_id?: IntFilter<"Favourite"> | number
    user_id?: IntFilter<"Favourite"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    itinerary?: XOR<ItineraryRelationFilter, ItineraryWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "event_id_itinerary_id_user_id">

  export type FavouriteOrderByWithAggregationInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
    _count?: FavouriteCountOrderByAggregateInput
    _avg?: FavouriteAvgOrderByAggregateInput
    _max?: FavouriteMaxOrderByAggregateInput
    _min?: FavouriteMinOrderByAggregateInput
    _sum?: FavouriteSumOrderByAggregateInput
  }

  export type FavouriteScalarWhereWithAggregatesInput = {
    AND?: FavouriteScalarWhereWithAggregatesInput | FavouriteScalarWhereWithAggregatesInput[]
    OR?: FavouriteScalarWhereWithAggregatesInput[]
    NOT?: FavouriteScalarWhereWithAggregatesInput | FavouriteScalarWhereWithAggregatesInput[]
    event_id?: IntWithAggregatesFilter<"Favourite"> | number
    itinerary_id?: IntWithAggregatesFilter<"Favourite"> | number
    user_id?: IntWithAggregatesFilter<"Favourite"> | number
  }

  export type Token_TransactionWhereInput = {
    AND?: Token_TransactionWhereInput | Token_TransactionWhereInput[]
    OR?: Token_TransactionWhereInput[]
    NOT?: Token_TransactionWhereInput | Token_TransactionWhereInput[]
    ID?: IntFilter<"Token_Transaction"> | number
    transaction_type?: StringFilter<"Token_Transaction"> | string
    token?: IntFilter<"Token_Transaction"> | number
    event_ID?: IntFilter<"Token_Transaction"> | number
    transaction_ID?: IntFilter<"Token_Transaction"> | number
    shop_ID?: IntFilter<"Token_Transaction"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    shop?: XOR<ShopsRelationFilter, ShopsWhereInput>
  }

  export type Token_TransactionOrderByWithRelationInput = {
    ID?: SortOrder
    transaction_type?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
    event?: EventOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    shop?: ShopsOrderByWithRelationInput
  }

  export type Token_TransactionWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Token_TransactionWhereInput | Token_TransactionWhereInput[]
    OR?: Token_TransactionWhereInput[]
    NOT?: Token_TransactionWhereInput | Token_TransactionWhereInput[]
    transaction_type?: StringFilter<"Token_Transaction"> | string
    token?: IntFilter<"Token_Transaction"> | number
    event_ID?: IntFilter<"Token_Transaction"> | number
    transaction_ID?: IntFilter<"Token_Transaction"> | number
    shop_ID?: IntFilter<"Token_Transaction"> | number
    event?: XOR<EventRelationFilter, EventWhereInput>
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
    shop?: XOR<ShopsRelationFilter, ShopsWhereInput>
  }, "ID">

  export type Token_TransactionOrderByWithAggregationInput = {
    ID?: SortOrder
    transaction_type?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
    _count?: Token_TransactionCountOrderByAggregateInput
    _avg?: Token_TransactionAvgOrderByAggregateInput
    _max?: Token_TransactionMaxOrderByAggregateInput
    _min?: Token_TransactionMinOrderByAggregateInput
    _sum?: Token_TransactionSumOrderByAggregateInput
  }

  export type Token_TransactionScalarWhereWithAggregatesInput = {
    AND?: Token_TransactionScalarWhereWithAggregatesInput | Token_TransactionScalarWhereWithAggregatesInput[]
    OR?: Token_TransactionScalarWhereWithAggregatesInput[]
    NOT?: Token_TransactionScalarWhereWithAggregatesInput | Token_TransactionScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Token_Transaction"> | number
    transaction_type?: StringWithAggregatesFilter<"Token_Transaction"> | string
    token?: IntWithAggregatesFilter<"Token_Transaction"> | number
    event_ID?: IntWithAggregatesFilter<"Token_Transaction"> | number
    transaction_ID?: IntWithAggregatesFilter<"Token_Transaction"> | number
    shop_ID?: IntWithAggregatesFilter<"Token_Transaction"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    user_id?: IntFilter<"Notification"> | number
    event_id?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    user_id?: IntFilter<"Notification"> | number
    event_id?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    user_id?: IntWithAggregatesFilter<"Notification"> | number
    event_id?: IntWithAggregatesFilter<"Notification"> | number
  }

  export type AmenitiesWhereInput = {
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    amenity_id?: IntFilter<"Amenities"> | number
    event_id?: IntFilter<"Amenities"> | number
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    latitude?: DateTimeFilter<"Amenities"> | Date | string
    longitude?: StringFilter<"Amenities"> | string
    image_url?: StringFilter<"Amenities"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type AmenitiesOrderByWithRelationInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    image_url?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type AmenitiesWhereUniqueInput = Prisma.AtLeast<{
    amenity_id?: number
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    event_id?: IntFilter<"Amenities"> | number
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    latitude?: DateTimeFilter<"Amenities"> | Date | string
    longitude?: StringFilter<"Amenities"> | string
    image_url?: StringFilter<"Amenities"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "amenity_id">

  export type AmenitiesOrderByWithAggregationInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    image_url?: SortOrder
    _count?: AmenitiesCountOrderByAggregateInput
    _avg?: AmenitiesAvgOrderByAggregateInput
    _max?: AmenitiesMaxOrderByAggregateInput
    _min?: AmenitiesMinOrderByAggregateInput
    _sum?: AmenitiesSumOrderByAggregateInput
  }

  export type AmenitiesScalarWhereWithAggregatesInput = {
    AND?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    OR?: AmenitiesScalarWhereWithAggregatesInput[]
    NOT?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    amenity_id?: IntWithAggregatesFilter<"Amenities"> | number
    event_id?: IntWithAggregatesFilter<"Amenities"> | number
    name?: StringWithAggregatesFilter<"Amenities"> | string
    description?: StringWithAggregatesFilter<"Amenities"> | string
    latitude?: DateTimeWithAggregatesFilter<"Amenities"> | Date | string
    longitude?: StringWithAggregatesFilter<"Amenities"> | string
    image_url?: StringWithAggregatesFilter<"Amenities"> | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: IntFilter<"Venue"> | number
    name?: StringFilter<"Venue"> | string
    address?: StringFilter<"Venue"> | string
    latitude?: DateTimeFilter<"Venue"> | Date | string
    longitude?: StringFilter<"Venue"> | string
    event?: EventListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    event?: EventOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    name?: StringFilter<"Venue"> | string
    address?: StringFilter<"Venue"> | string
    latitude?: DateTimeFilter<"Venue"> | Date | string
    longitude?: StringFilter<"Venue"> | string
    event?: EventListRelationFilter
  }, "id">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Venue"> | number
    name?: StringWithAggregatesFilter<"Venue"> | string
    address?: StringWithAggregatesFilter<"Venue"> | string
    latitude?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    longitude?: StringWithAggregatesFilter<"Venue"> | string
  }

  export type Emergency_ContactsWhereInput = {
    AND?: Emergency_ContactsWhereInput | Emergency_ContactsWhereInput[]
    OR?: Emergency_ContactsWhereInput[]
    NOT?: Emergency_ContactsWhereInput | Emergency_ContactsWhereInput[]
    id?: IntFilter<"Emergency_Contacts"> | number
    event_id?: IntFilter<"Emergency_Contacts"> | number
    contact_name?: StringFilter<"Emergency_Contacts"> | string
    contact_number?: StringFilter<"Emergency_Contacts"> | string
    contact_type?: StringFilter<"Emergency_Contacts"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type Emergency_ContactsOrderByWithRelationInput = {
    id?: SortOrder
    event_id?: SortOrder
    contact_name?: SortOrder
    contact_number?: SortOrder
    contact_type?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type Emergency_ContactsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Emergency_ContactsWhereInput | Emergency_ContactsWhereInput[]
    OR?: Emergency_ContactsWhereInput[]
    NOT?: Emergency_ContactsWhereInput | Emergency_ContactsWhereInput[]
    event_id?: IntFilter<"Emergency_Contacts"> | number
    contact_name?: StringFilter<"Emergency_Contacts"> | string
    contact_number?: StringFilter<"Emergency_Contacts"> | string
    contact_type?: StringFilter<"Emergency_Contacts"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "id">

  export type Emergency_ContactsOrderByWithAggregationInput = {
    id?: SortOrder
    event_id?: SortOrder
    contact_name?: SortOrder
    contact_number?: SortOrder
    contact_type?: SortOrder
    _count?: Emergency_ContactsCountOrderByAggregateInput
    _avg?: Emergency_ContactsAvgOrderByAggregateInput
    _max?: Emergency_ContactsMaxOrderByAggregateInput
    _min?: Emergency_ContactsMinOrderByAggregateInput
    _sum?: Emergency_ContactsSumOrderByAggregateInput
  }

  export type Emergency_ContactsScalarWhereWithAggregatesInput = {
    AND?: Emergency_ContactsScalarWhereWithAggregatesInput | Emergency_ContactsScalarWhereWithAggregatesInput[]
    OR?: Emergency_ContactsScalarWhereWithAggregatesInput[]
    NOT?: Emergency_ContactsScalarWhereWithAggregatesInput | Emergency_ContactsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Emergency_Contacts"> | number
    event_id?: IntWithAggregatesFilter<"Emergency_Contacts"> | number
    contact_name?: StringWithAggregatesFilter<"Emergency_Contacts"> | string
    contact_number?: StringWithAggregatesFilter<"Emergency_Contacts"> | string
    contact_type?: StringWithAggregatesFilter<"Emergency_Contacts"> | string
  }

  export type UserCreateInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
  }

  export type UserUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type RefreshTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
  }

  export type EventUpdateManyMutationInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type EventUncheckedUpdateManyInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type PlanCreateInput = {
    plan_features: string
    payment: number
    plan_name: string
    user_plan?: User_PlanCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    plan_id?: number
    plan_features: string
    payment: number
    plan_name: string
    user_plan?: User_PlanUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    user_plan?: User_PlanUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    user_plan?: User_PlanUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    plan_id?: number
    plan_features: string
    payment: number
    plan_name: string
  }

  export type PlanUpdateManyMutationInput = {
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
  }

  export type PlanUncheckedUpdateManyInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
    User: UserCreateNestedOneWithoutTransactionInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    user_id: number
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    user_id: number
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
  }

  export type TransactionUpdateManyMutationInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
  }

  export type User_PlanCreateInput = {
    is_activate: boolean
    user: UserCreateNestedOneWithoutUser_planInput
    plan: PlanCreateNestedOneWithoutUser_planInput
  }

  export type User_PlanUncheckedCreateInput = {
    plan_id: number
    user_id: number
    is_activate: boolean
  }

  export type User_PlanUpdateInput = {
    is_activate?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUser_planNestedInput
    plan?: PlanUpdateOneRequiredWithoutUser_planNestedInput
  }

  export type User_PlanUncheckedUpdateInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_PlanCreateManyInput = {
    plan_id: number
    user_id: number
    is_activate: boolean
  }

  export type User_PlanUpdateManyMutationInput = {
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_PlanUncheckedUpdateManyInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleCreateInput = {
    role_name: string
    user?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    role_id?: number
    role_name: string
    user?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    role_id?: number
    role_name: string
  }

  export type RoleUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type SponsorCreateInput = {
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
    event: EventCreateNestedOneWithoutSponsorInput
  }

  export type SponsorUncheckedCreateInput = {
    sponsor_id?: number
    event_id: number
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
  }

  export type SponsorUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
    event?: EventUpdateOneRequiredWithoutSponsorNestedInput
  }

  export type SponsorUncheckedUpdateInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type SponsorCreateManyInput = {
    sponsor_id?: number
    event_id: number
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
  }

  export type SponsorUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type SponsorUncheckedUpdateManyInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type AdvertisementCreateInput = {
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
    event: EventCreateNestedOneWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateInput = {
    advertisement_id?: number
    event_id: number
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
  }

  export type AdvertisementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateInput = {
    advertisement_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AdvertisementCreateManyInput = {
    advertisement_id?: number
    event_id: number
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
  }

  export type AdvertisementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AdvertisementUncheckedUpdateManyInput = {
    advertisement_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type LostAndFoundCreateInput = {
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    event: EventCreateNestedOneWithoutLostandfoundInput
    claim_user: UserCreateNestedOneWithoutClaim_userInput
    reporter_user: UserCreateNestedOneWithoutReporter_userInput
  }

  export type LostAndFoundUncheckedCreateInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type LostAndFoundUpdateInput = {
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutLostandfoundNestedInput
    claim_user?: UserUpdateOneRequiredWithoutClaim_userNestedInput
    reporter_user?: UserUpdateOneRequiredWithoutReporter_userNestedInput
  }

  export type LostAndFoundUncheckedUpdateInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LostAndFoundCreateManyInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type LostAndFoundUpdateManyMutationInput = {
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LostAndFoundUncheckedUpdateManyInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type EventMapCreateInput = {
    map_object: string
    event: EventCreateNestedOneWithoutEventmapInput
  }

  export type EventMapUncheckedCreateInput = {
    event_map_id?: number
    map_object: string
    event_id: number
  }

  export type EventMapUpdateInput = {
    map_object?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutEventmapNestedInput
  }

  export type EventMapUncheckedUpdateInput = {
    event_map_id?: IntFieldUpdateOperationsInput | number
    map_object?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type EventMapCreateManyInput = {
    event_map_id?: number
    map_object: string
    event_id: number
  }

  export type EventMapUpdateManyMutationInput = {
    map_object?: StringFieldUpdateOperationsInput | string
  }

  export type EventMapUncheckedUpdateManyInput = {
    event_map_id?: IntFieldUpdateOperationsInput | number
    map_object?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopsCreateInput = {
    shop_name: string
    shop_type: string
    event: EventCreateNestedOneWithoutShopInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutShopInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutShopInput
  }

  export type ShopsUncheckedCreateInput = {
    shop_id?: number
    shop_name: string
    event_id: number
    shop_type: string
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutShopInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopsUpdateInput = {
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutShopNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutShopNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutShopNestedInput
  }

  export type ShopsUncheckedUpdateInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    shop_type?: StringFieldUpdateOperationsInput | string
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutShopNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopsCreateManyInput = {
    shop_id?: number
    shop_name: string
    event_id: number
    shop_type: string
  }

  export type ShopsUpdateManyMutationInput = {
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
  }

  export type ShopsUncheckedUpdateManyInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    shop_type?: StringFieldUpdateOperationsInput | string
  }

  export type ShopPaymentCreateInput = {
    amount: number
    shop: ShopsCreateNestedOneWithoutShoppaymentInput
    event: EventCreateNestedOneWithoutShoppaymentInput
    User: UserCreateNestedOneWithoutShoppaymentInput
  }

  export type ShopPaymentUncheckedCreateInput = {
    payment_id?: number
    amount: number
    shop_id: number
    event_id: number
    user_id: number
  }

  export type ShopPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    shop?: ShopsUpdateOneRequiredWithoutShoppaymentNestedInput
    event?: EventUpdateOneRequiredWithoutShoppaymentNestedInput
    User?: UserUpdateOneRequiredWithoutShoppaymentNestedInput
  }

  export type ShopPaymentUncheckedUpdateInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentCreateManyInput = {
    payment_id?: number
    amount: number
    shop_id: number
    event_id: number
    user_id: number
  }

  export type ShopPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ShopPaymentUncheckedUpdateManyInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    review_title: string
    review_desc: string
    rating: number
    timestamp: Date | string
    User: UserCreateNestedOneWithoutReviewInput
    event: EventCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    review_id?: number
    review_title: string
    review_desc: string
    user_id: number
    rating: number
    timestamp: Date | string
    event_id: number
  }

  export type ReviewUpdateInput = {
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutReviewNestedInput
    event?: EventUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateManyInput = {
    review_id?: number
    review_title: string
    review_desc: string
    user_id: number
    rating: number
    timestamp: Date | string
    event_id: number
  }

  export type ReviewUpdateManyMutationInput = {
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ItineraryCreateInput = {
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
    event: EventCreateNestedOneWithoutItineraryInput
    favourite?: FavouriteCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateInput = {
    itinerary_id?: number
    event_id: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
    favourite?: FavouriteUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUpdateInput = {
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutItineraryNestedInput
    favourite?: FavouriteUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    favourite?: FavouriteUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryCreateManyInput = {
    itinerary_id?: number
    event_id: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
  }

  export type ItineraryUpdateManyMutationInput = {
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type ItineraryUncheckedUpdateManyInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type FavouriteCreateInput = {
    event: EventCreateNestedOneWithoutFavouriteInput
    itinerary: ItineraryCreateNestedOneWithoutFavouriteInput
    user: UserCreateNestedOneWithoutFavouriteInput
  }

  export type FavouriteUncheckedCreateInput = {
    event_id: number
    itinerary_id: number
    user_id: number
  }

  export type FavouriteUpdateInput = {
    event?: EventUpdateOneRequiredWithoutFavouriteNestedInput
    itinerary?: ItineraryUpdateOneRequiredWithoutFavouriteNestedInput
    user?: UserUpdateOneRequiredWithoutFavouriteNestedInput
  }

  export type FavouriteUncheckedUpdateInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteCreateManyInput = {
    event_id: number
    itinerary_id: number
    user_id: number
  }

  export type FavouriteUpdateManyMutationInput = {

  }

  export type FavouriteUncheckedUpdateManyInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionCreateInput = {
    transaction_type: string
    token: number
    event: EventCreateNestedOneWithoutTokentransactionInput
    transaction: TransactionCreateNestedOneWithoutTokentransactionInput
    shop: ShopsCreateNestedOneWithoutTokentransactionInput
  }

  export type Token_TransactionUncheckedCreateInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    transaction_ID: number
    shop_ID: number
  }

  export type Token_TransactionUpdateInput = {
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event?: EventUpdateOneRequiredWithoutTokentransactionNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutTokentransactionNestedInput
    shop?: ShopsUpdateOneRequiredWithoutTokentransactionNestedInput
  }

  export type Token_TransactionUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionCreateManyInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    transaction_ID: number
    shop_ID: number
  }

  export type Token_TransactionUpdateManyMutationInput = {
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    title: string
    body: string
    type: string
    timestamp: Date | string
    event_id: number
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    title: string
    body: string
    type: string
    timestamp: Date | string
    user_id: number
    event_id: number
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateManyInput = {
    id?: number
    title: string
    body: string
    type: string
    timestamp: Date | string
    user_id: number
    event_id: number
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type AmenitiesCreateInput = {
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
    event: EventCreateNestedOneWithoutAmenitiesInput
  }

  export type AmenitiesUncheckedCreateInput = {
    amenity_id?: number
    event_id: number
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
  }

  export type AmenitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type AmenitiesUncheckedUpdateInput = {
    amenity_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AmenitiesCreateManyInput = {
    amenity_id?: number
    event_id: number
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
  }

  export type AmenitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AmenitiesUncheckedUpdateManyInput = {
    amenity_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type VenueCreateInput = {
    name: string
    address: string
    latitude: Date | string
    longitude: string
    event?: EventCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    latitude: Date | string
    longitude: string
    event?: EventUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    event?: EventUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: number
    name: string
    address: string
    latitude: Date | string
    longitude: string
  }

  export type VenueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsCreateInput = {
    contact_name: string
    contact_number: string
    contact_type: string
    event: EventCreateNestedOneWithoutEmergency_contactsInput
  }

  export type Emergency_ContactsUncheckedCreateInput = {
    id?: number
    event_id: number
    contact_name: string
    contact_number: string
    contact_type: string
  }

  export type Emergency_ContactsUpdateInput = {
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutEmergency_contactsNestedInput
  }

  export type Emergency_ContactsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsCreateManyInput = {
    id?: number
    event_id: number
    contact_name: string
    contact_number: string
    contact_type: string
  }

  export type Emergency_ContactsUpdateManyMutationInput = {
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type User_PlanListRelationFilter = {
    every?: User_PlanWhereInput
    some?: User_PlanWhereInput
    none?: User_PlanWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type ShopPaymentListRelationFilter = {
    every?: ShopPaymentWhereInput
    some?: ShopPaymentWhereInput
    none?: ShopPaymentWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type FavouriteListRelationFilter = {
    every?: FavouriteWhereInput
    some?: FavouriteWhereInput
    none?: FavouriteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type LostAndFoundListRelationFilter = {
    every?: LostAndFoundWhereInput
    some?: LostAndFoundWhereInput
    none?: LostAndFoundWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type User_PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavouriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LostAndFoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact_number?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    user_id?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact_number?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact_number?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    user_id?: SortOrder
    token?: SortOrder
    role_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SponsorListRelationFilter = {
    every?: SponsorWhereInput
    some?: SponsorWhereInput
    none?: SponsorWhereInput
  }

  export type AdvertisementListRelationFilter = {
    every?: AdvertisementWhereInput
    some?: AdvertisementWhereInput
    none?: AdvertisementWhereInput
  }

  export type EventMapListRelationFilter = {
    every?: EventMapWhereInput
    some?: EventMapWhereInput
    none?: EventMapWhereInput
  }

  export type ShopsListRelationFilter = {
    every?: ShopsWhereInput
    some?: ShopsWhereInput
    none?: ShopsWhereInput
  }

  export type ItineraryListRelationFilter = {
    every?: ItineraryWhereInput
    some?: ItineraryWhereInput
    none?: ItineraryWhereInput
  }

  export type Token_TransactionListRelationFilter = {
    every?: Token_TransactionWhereInput
    some?: Token_TransactionWhereInput
    none?: Token_TransactionWhereInput
  }

  export type AmenitiesListRelationFilter = {
    every?: AmenitiesWhereInput
    some?: AmenitiesWhereInput
    none?: AmenitiesWhereInput
  }

  export type Emergency_ContactsListRelationFilter = {
    every?: Emergency_ContactsWhereInput
    some?: Emergency_ContactsWhereInput
    none?: Emergency_ContactsWhereInput
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type SponsorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItineraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Token_TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Emergency_ContactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    event_tags?: SortOrder
    creator_id?: SortOrder
    approval?: SortOrder
    status?: SortOrder
    entry_fee?: SortOrder
    thumbnail_link?: SortOrder
    banner_link?: SortOrder
    video_link?: SortOrder
    venue_id?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    event_id?: SortOrder
    creator_id?: SortOrder
    entry_fee?: SortOrder
    venue_id?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    event_tags?: SortOrder
    creator_id?: SortOrder
    approval?: SortOrder
    status?: SortOrder
    entry_fee?: SortOrder
    thumbnail_link?: SortOrder
    banner_link?: SortOrder
    video_link?: SortOrder
    venue_id?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    event_tags?: SortOrder
    creator_id?: SortOrder
    approval?: SortOrder
    status?: SortOrder
    entry_fee?: SortOrder
    thumbnail_link?: SortOrder
    banner_link?: SortOrder
    video_link?: SortOrder
    venue_id?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    event_id?: SortOrder
    creator_id?: SortOrder
    entry_fee?: SortOrder
    venue_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PlanCountOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_features?: SortOrder
    payment?: SortOrder
    plan_name?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    plan_id?: SortOrder
    payment?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_features?: SortOrder
    payment?: SortOrder
    plan_name?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    plan_id?: SortOrder
    plan_features?: SortOrder
    payment?: SortOrder
    plan_name?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    plan_id?: SortOrder
    payment?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
    transaction_id?: SortOrder
    transaction_type?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
    transaction_id?: SortOrder
    transaction_type?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
    transaction_id?: SortOrder
    transaction_type?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    amount?: SortOrder
    GST?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type User_PlanPlan_idUser_idCompoundUniqueInput = {
    plan_id: number
    user_id: number
  }

  export type User_PlanCountOrderByAggregateInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
    is_activate?: SortOrder
  }

  export type User_PlanAvgOrderByAggregateInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
  }

  export type User_PlanMaxOrderByAggregateInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
    is_activate?: SortOrder
  }

  export type User_PlanMinOrderByAggregateInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
    is_activate?: SortOrder
  }

  export type User_PlanSumOrderByAggregateInput = {
    plan_id?: SortOrder
    user_id?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type SponsorCountOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    venue_id?: SortOrder
  }

  export type SponsorAvgOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    venue_id?: SortOrder
  }

  export type SponsorMaxOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    venue_id?: SortOrder
  }

  export type SponsorMinOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    venue_id?: SortOrder
  }

  export type SponsorSumOrderByAggregateInput = {
    sponsor_id?: SortOrder
    event_id?: SortOrder
    venue_id?: SortOrder
  }

  export type AdvertisementCountOrderByAggregateInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    image_url?: SortOrder
  }

  export type AdvertisementAvgOrderByAggregateInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
  }

  export type AdvertisementMaxOrderByAggregateInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    image_url?: SortOrder
  }

  export type AdvertisementMinOrderByAggregateInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
    title?: SortOrder
    level?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    image_url?: SortOrder
  }

  export type AdvertisementSumOrderByAggregateInput = {
    advertisement_id?: SortOrder
    event_id?: SortOrder
  }

  export type LostAndFoundCountOrderByAggregateInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    is_claimed?: SortOrder
    claim_user_id?: SortOrder
    reporting_timestamp?: SortOrder
    claim_timestamp?: SortOrder
    reporter_user_id?: SortOrder
  }

  export type LostAndFoundAvgOrderByAggregateInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    claim_user_id?: SortOrder
    reporter_user_id?: SortOrder
  }

  export type LostAndFoundMaxOrderByAggregateInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    is_claimed?: SortOrder
    claim_user_id?: SortOrder
    reporting_timestamp?: SortOrder
    claim_timestamp?: SortOrder
    reporter_user_id?: SortOrder
  }

  export type LostAndFoundMinOrderByAggregateInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    is_claimed?: SortOrder
    claim_user_id?: SortOrder
    reporting_timestamp?: SortOrder
    claim_timestamp?: SortOrder
    reporter_user_id?: SortOrder
  }

  export type LostAndFoundSumOrderByAggregateInput = {
    lost_and_found_id?: SortOrder
    event_id?: SortOrder
    claim_user_id?: SortOrder
    reporter_user_id?: SortOrder
  }

  export type EventMapCountOrderByAggregateInput = {
    event_map_id?: SortOrder
    map_object?: SortOrder
    event_id?: SortOrder
  }

  export type EventMapAvgOrderByAggregateInput = {
    event_map_id?: SortOrder
    event_id?: SortOrder
  }

  export type EventMapMaxOrderByAggregateInput = {
    event_map_id?: SortOrder
    map_object?: SortOrder
    event_id?: SortOrder
  }

  export type EventMapMinOrderByAggregateInput = {
    event_map_id?: SortOrder
    map_object?: SortOrder
    event_id?: SortOrder
  }

  export type EventMapSumOrderByAggregateInput = {
    event_map_id?: SortOrder
    event_id?: SortOrder
  }

  export type ShopsCountOrderByAggregateInput = {
    shop_id?: SortOrder
    shop_name?: SortOrder
    event_id?: SortOrder
    shop_type?: SortOrder
  }

  export type ShopsAvgOrderByAggregateInput = {
    shop_id?: SortOrder
    event_id?: SortOrder
  }

  export type ShopsMaxOrderByAggregateInput = {
    shop_id?: SortOrder
    shop_name?: SortOrder
    event_id?: SortOrder
    shop_type?: SortOrder
  }

  export type ShopsMinOrderByAggregateInput = {
    shop_id?: SortOrder
    shop_name?: SortOrder
    event_id?: SortOrder
    shop_type?: SortOrder
  }

  export type ShopsSumOrderByAggregateInput = {
    shop_id?: SortOrder
    event_id?: SortOrder
  }

  export type ShopsRelationFilter = {
    is?: ShopsWhereInput
    isNot?: ShopsWhereInput
  }

  export type ShopPaymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
  }

  export type ShopPaymentAvgOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
  }

  export type ShopPaymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
  }

  export type ShopPaymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
  }

  export type ShopPaymentSumOrderByAggregateInput = {
    payment_id?: SortOrder
    amount?: SortOrder
    shop_id?: SortOrder
    event_id?: SortOrder
    user_id?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    review_id?: SortOrder
    review_title?: SortOrder
    review_desc?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    timestamp?: SortOrder
    event_id?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    event_id?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    review_id?: SortOrder
    review_title?: SortOrder
    review_desc?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    timestamp?: SortOrder
    event_id?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    review_id?: SortOrder
    review_title?: SortOrder
    review_desc?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    timestamp?: SortOrder
    event_id?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    event_id?: SortOrder
  }

  export type ItineraryCountOrderByAggregateInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
    itinerary_name?: SortOrder
    itinerary_description?: SortOrder
    timestamp?: SortOrder
    image_url?: SortOrder
  }

  export type ItineraryAvgOrderByAggregateInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
  }

  export type ItineraryMaxOrderByAggregateInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
    itinerary_name?: SortOrder
    itinerary_description?: SortOrder
    timestamp?: SortOrder
    image_url?: SortOrder
  }

  export type ItineraryMinOrderByAggregateInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
    itinerary_name?: SortOrder
    itinerary_description?: SortOrder
    timestamp?: SortOrder
    image_url?: SortOrder
  }

  export type ItinerarySumOrderByAggregateInput = {
    itinerary_id?: SortOrder
    event_id?: SortOrder
  }

  export type ItineraryRelationFilter = {
    is?: ItineraryWhereInput
    isNot?: ItineraryWhereInput
  }

  export type FavouriteEvent_idItinerary_idUser_idCompoundUniqueInput = {
    event_id: number
    itinerary_id: number
    user_id: number
  }

  export type FavouriteCountOrderByAggregateInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
  }

  export type FavouriteAvgOrderByAggregateInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
  }

  export type FavouriteMaxOrderByAggregateInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
  }

  export type FavouriteMinOrderByAggregateInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
  }

  export type FavouriteSumOrderByAggregateInput = {
    event_id?: SortOrder
    itinerary_id?: SortOrder
    user_id?: SortOrder
  }

  export type TransactionRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type Token_TransactionCountOrderByAggregateInput = {
    ID?: SortOrder
    transaction_type?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
  }

  export type Token_TransactionAvgOrderByAggregateInput = {
    ID?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
  }

  export type Token_TransactionMaxOrderByAggregateInput = {
    ID?: SortOrder
    transaction_type?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
  }

  export type Token_TransactionMinOrderByAggregateInput = {
    ID?: SortOrder
    transaction_type?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
  }

  export type Token_TransactionSumOrderByAggregateInput = {
    ID?: SortOrder
    token?: SortOrder
    event_ID?: SortOrder
    transaction_ID?: SortOrder
    shop_ID?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    event_id?: SortOrder
  }

  export type AmenitiesCountOrderByAggregateInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    image_url?: SortOrder
  }

  export type AmenitiesAvgOrderByAggregateInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
  }

  export type AmenitiesMaxOrderByAggregateInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    image_url?: SortOrder
  }

  export type AmenitiesMinOrderByAggregateInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    image_url?: SortOrder
  }

  export type AmenitiesSumOrderByAggregateInput = {
    amenity_id?: SortOrder
    event_id?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Emergency_ContactsCountOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    contact_name?: SortOrder
    contact_number?: SortOrder
    contact_type?: SortOrder
  }

  export type Emergency_ContactsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
  }

  export type Emergency_ContactsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    contact_name?: SortOrder
    contact_number?: SortOrder
    contact_type?: SortOrder
  }

  export type Emergency_ContactsMinOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
    contact_name?: SortOrder
    contact_number?: SortOrder
    contact_type?: SortOrder
  }

  export type Emergency_ContactsSumOrderByAggregateInput = {
    id?: SortOrder
    event_id?: SortOrder
  }

  export type RoleCreateNestedOneWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    connect?: RoleWhereUniqueInput
  }

  export type User_PlanCreateNestedManyWithoutUserInput = {
    create?: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput> | User_PlanCreateWithoutUserInput[] | User_PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutUserInput | User_PlanCreateOrConnectWithoutUserInput[]
    createMany?: User_PlanCreateManyUserInputEnvelope
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ShopPaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput> | ShopPaymentCreateWithoutUserInput[] | ShopPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutUserInput | ShopPaymentCreateOrConnectWithoutUserInput[]
    createMany?: ShopPaymentCreateManyUserInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type FavouriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput> | FavouriteCreateWithoutUserInput[] | FavouriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutUserInput | FavouriteCreateOrConnectWithoutUserInput[]
    createMany?: FavouriteCreateManyUserInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LostAndFoundCreateNestedManyWithoutClaim_userInput = {
    create?: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput> | LostAndFoundCreateWithoutClaim_userInput[] | LostAndFoundUncheckedCreateWithoutClaim_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutClaim_userInput | LostAndFoundCreateOrConnectWithoutClaim_userInput[]
    createMany?: LostAndFoundCreateManyClaim_userInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type LostAndFoundCreateNestedManyWithoutReporter_userInput = {
    create?: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput> | LostAndFoundCreateWithoutReporter_userInput[] | LostAndFoundUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutReporter_userInput | LostAndFoundCreateOrConnectWithoutReporter_userInput[]
    createMany?: LostAndFoundCreateManyReporter_userInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type User_PlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput> | User_PlanCreateWithoutUserInput[] | User_PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutUserInput | User_PlanCreateOrConnectWithoutUserInput[]
    createMany?: User_PlanCreateManyUserInputEnvelope
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ShopPaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput> | ShopPaymentCreateWithoutUserInput[] | ShopPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutUserInput | ShopPaymentCreateOrConnectWithoutUserInput[]
    createMany?: ShopPaymentCreateManyUserInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type FavouriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput> | FavouriteCreateWithoutUserInput[] | FavouriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutUserInput | FavouriteCreateOrConnectWithoutUserInput[]
    createMany?: FavouriteCreateManyUserInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput = {
    create?: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput> | LostAndFoundCreateWithoutClaim_userInput[] | LostAndFoundUncheckedCreateWithoutClaim_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutClaim_userInput | LostAndFoundCreateOrConnectWithoutClaim_userInput[]
    createMany?: LostAndFoundCreateManyClaim_userInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput = {
    create?: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput> | LostAndFoundCreateWithoutReporter_userInput[] | LostAndFoundUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutReporter_userInput | LostAndFoundCreateOrConnectWithoutReporter_userInput[]
    createMany?: LostAndFoundCreateManyReporter_userInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoleUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    upsert?: RoleUpsertWithoutUserInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserInput, RoleUpdateWithoutUserInput>, RoleUncheckedUpdateWithoutUserInput>
  }

  export type User_PlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput> | User_PlanCreateWithoutUserInput[] | User_PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutUserInput | User_PlanCreateOrConnectWithoutUserInput[]
    upsert?: User_PlanUpsertWithWhereUniqueWithoutUserInput | User_PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: User_PlanCreateManyUserInputEnvelope
    set?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    disconnect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    delete?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    update?: User_PlanUpdateWithWhereUniqueWithoutUserInput | User_PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: User_PlanUpdateManyWithWhereWithoutUserInput | User_PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ShopPaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput> | ShopPaymentCreateWithoutUserInput[] | ShopPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutUserInput | ShopPaymentCreateOrConnectWithoutUserInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutUserInput | ShopPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopPaymentCreateManyUserInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutUserInput | ShopPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutUserInput | ShopPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type FavouriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput> | FavouriteCreateWithoutUserInput[] | FavouriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutUserInput | FavouriteCreateOrConnectWithoutUserInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutUserInput | FavouriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavouriteCreateManyUserInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutUserInput | FavouriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutUserInput | FavouriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LostAndFoundUpdateManyWithoutClaim_userNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput> | LostAndFoundCreateWithoutClaim_userInput[] | LostAndFoundUncheckedCreateWithoutClaim_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutClaim_userInput | LostAndFoundCreateOrConnectWithoutClaim_userInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutClaim_userInput | LostAndFoundUpsertWithWhereUniqueWithoutClaim_userInput[]
    createMany?: LostAndFoundCreateManyClaim_userInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutClaim_userInput | LostAndFoundUpdateWithWhereUniqueWithoutClaim_userInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutClaim_userInput | LostAndFoundUpdateManyWithWhereWithoutClaim_userInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type LostAndFoundUpdateManyWithoutReporter_userNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput> | LostAndFoundCreateWithoutReporter_userInput[] | LostAndFoundUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutReporter_userInput | LostAndFoundCreateOrConnectWithoutReporter_userInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutReporter_userInput | LostAndFoundUpsertWithWhereUniqueWithoutReporter_userInput[]
    createMany?: LostAndFoundCreateManyReporter_userInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutReporter_userInput | LostAndFoundUpdateWithWhereUniqueWithoutReporter_userInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutReporter_userInput | LostAndFoundUpdateManyWithWhereWithoutReporter_userInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type User_PlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput> | User_PlanCreateWithoutUserInput[] | User_PlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutUserInput | User_PlanCreateOrConnectWithoutUserInput[]
    upsert?: User_PlanUpsertWithWhereUniqueWithoutUserInput | User_PlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: User_PlanCreateManyUserInputEnvelope
    set?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    disconnect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    delete?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    update?: User_PlanUpdateWithWhereUniqueWithoutUserInput | User_PlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: User_PlanUpdateManyWithWhereWithoutUserInput | User_PlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ShopPaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput> | ShopPaymentCreateWithoutUserInput[] | ShopPaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutUserInput | ShopPaymentCreateOrConnectWithoutUserInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutUserInput | ShopPaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopPaymentCreateManyUserInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutUserInput | ShopPaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutUserInput | ShopPaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type FavouriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput> | FavouriteCreateWithoutUserInput[] | FavouriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutUserInput | FavouriteCreateOrConnectWithoutUserInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutUserInput | FavouriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavouriteCreateManyUserInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutUserInput | FavouriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutUserInput | FavouriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput> | LostAndFoundCreateWithoutClaim_userInput[] | LostAndFoundUncheckedCreateWithoutClaim_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutClaim_userInput | LostAndFoundCreateOrConnectWithoutClaim_userInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutClaim_userInput | LostAndFoundUpsertWithWhereUniqueWithoutClaim_userInput[]
    createMany?: LostAndFoundCreateManyClaim_userInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutClaim_userInput | LostAndFoundUpdateWithWhereUniqueWithoutClaim_userInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutClaim_userInput | LostAndFoundUpdateManyWithWhereWithoutClaim_userInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput> | LostAndFoundCreateWithoutReporter_userInput[] | LostAndFoundUncheckedCreateWithoutReporter_userInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutReporter_userInput | LostAndFoundCreateOrConnectWithoutReporter_userInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutReporter_userInput | LostAndFoundUpsertWithWhereUniqueWithoutReporter_userInput[]
    createMany?: LostAndFoundCreateManyReporter_userInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutReporter_userInput | LostAndFoundUpdateWithWhereUniqueWithoutReporter_userInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutReporter_userInput | LostAndFoundUpdateManyWithWhereWithoutReporter_userInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutEventInput = {
    create?: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventInput
    connect?: UserWhereUniqueInput
  }

  export type LostAndFoundCreateNestedManyWithoutEventInput = {
    create?: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput> | LostAndFoundCreateWithoutEventInput[] | LostAndFoundUncheckedCreateWithoutEventInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutEventInput | LostAndFoundCreateOrConnectWithoutEventInput[]
    createMany?: LostAndFoundCreateManyEventInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type SponsorCreateNestedManyWithoutEventInput = {
    create?: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput> | SponsorCreateWithoutEventInput[] | SponsorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutEventInput | SponsorCreateOrConnectWithoutEventInput[]
    createMany?: SponsorCreateManyEventInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type AdvertisementCreateNestedManyWithoutEventInput = {
    create?: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput> | AdvertisementCreateWithoutEventInput[] | AdvertisementUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutEventInput | AdvertisementCreateOrConnectWithoutEventInput[]
    createMany?: AdvertisementCreateManyEventInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type EventMapCreateNestedManyWithoutEventInput = {
    create?: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput> | EventMapCreateWithoutEventInput[] | EventMapUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventMapCreateOrConnectWithoutEventInput | EventMapCreateOrConnectWithoutEventInput[]
    createMany?: EventMapCreateManyEventInputEnvelope
    connect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
  }

  export type ShopsCreateNestedManyWithoutEventInput = {
    create?: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput> | ShopsCreateWithoutEventInput[] | ShopsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopsCreateOrConnectWithoutEventInput | ShopsCreateOrConnectWithoutEventInput[]
    createMany?: ShopsCreateManyEventInputEnvelope
    connect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
  }

  export type ShopPaymentCreateNestedManyWithoutEventInput = {
    create?: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput> | ShopPaymentCreateWithoutEventInput[] | ShopPaymentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutEventInput | ShopPaymentCreateOrConnectWithoutEventInput[]
    createMany?: ShopPaymentCreateManyEventInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutEventInput = {
    create?: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput> | ReviewCreateWithoutEventInput[] | ReviewUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutEventInput | ReviewCreateOrConnectWithoutEventInput[]
    createMany?: ReviewCreateManyEventInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ItineraryCreateNestedManyWithoutEventInput = {
    create?: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput> | ItineraryCreateWithoutEventInput[] | ItineraryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEventInput | ItineraryCreateOrConnectWithoutEventInput[]
    createMany?: ItineraryCreateManyEventInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type FavouriteCreateNestedManyWithoutEventInput = {
    create?: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput> | FavouriteCreateWithoutEventInput[] | FavouriteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutEventInput | FavouriteCreateOrConnectWithoutEventInput[]
    createMany?: FavouriteCreateManyEventInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type Token_TransactionCreateNestedManyWithoutEventInput = {
    create?: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput> | Token_TransactionCreateWithoutEventInput[] | Token_TransactionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutEventInput | Token_TransactionCreateOrConnectWithoutEventInput[]
    createMany?: Token_TransactionCreateManyEventInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type AmenitiesCreateNestedManyWithoutEventInput = {
    create?: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput> | AmenitiesCreateWithoutEventInput[] | AmenitiesUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutEventInput | AmenitiesCreateOrConnectWithoutEventInput[]
    createMany?: AmenitiesCreateManyEventInputEnvelope
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type Emergency_ContactsCreateNestedManyWithoutEventInput = {
    create?: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput> | Emergency_ContactsCreateWithoutEventInput[] | Emergency_ContactsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Emergency_ContactsCreateOrConnectWithoutEventInput | Emergency_ContactsCreateOrConnectWithoutEventInput[]
    createMany?: Emergency_ContactsCreateManyEventInputEnvelope
    connect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
  }

  export type VenueCreateNestedManyWithoutEventInput = {
    create?: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput> | VenueCreateWithoutEventInput[] | VenueUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutEventInput | VenueCreateOrConnectWithoutEventInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type LostAndFoundUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput> | LostAndFoundCreateWithoutEventInput[] | LostAndFoundUncheckedCreateWithoutEventInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutEventInput | LostAndFoundCreateOrConnectWithoutEventInput[]
    createMany?: LostAndFoundCreateManyEventInputEnvelope
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
  }

  export type SponsorUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput> | SponsorCreateWithoutEventInput[] | SponsorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutEventInput | SponsorCreateOrConnectWithoutEventInput[]
    createMany?: SponsorCreateManyEventInputEnvelope
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
  }

  export type AdvertisementUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput> | AdvertisementCreateWithoutEventInput[] | AdvertisementUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutEventInput | AdvertisementCreateOrConnectWithoutEventInput[]
    createMany?: AdvertisementCreateManyEventInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type EventMapUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput> | EventMapCreateWithoutEventInput[] | EventMapUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventMapCreateOrConnectWithoutEventInput | EventMapCreateOrConnectWithoutEventInput[]
    createMany?: EventMapCreateManyEventInputEnvelope
    connect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
  }

  export type ShopsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput> | ShopsCreateWithoutEventInput[] | ShopsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopsCreateOrConnectWithoutEventInput | ShopsCreateOrConnectWithoutEventInput[]
    createMany?: ShopsCreateManyEventInputEnvelope
    connect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
  }

  export type ShopPaymentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput> | ShopPaymentCreateWithoutEventInput[] | ShopPaymentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutEventInput | ShopPaymentCreateOrConnectWithoutEventInput[]
    createMany?: ShopPaymentCreateManyEventInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput> | ReviewCreateWithoutEventInput[] | ReviewUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutEventInput | ReviewCreateOrConnectWithoutEventInput[]
    createMany?: ReviewCreateManyEventInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ItineraryUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput> | ItineraryCreateWithoutEventInput[] | ItineraryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEventInput | ItineraryCreateOrConnectWithoutEventInput[]
    createMany?: ItineraryCreateManyEventInputEnvelope
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
  }

  export type FavouriteUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput> | FavouriteCreateWithoutEventInput[] | FavouriteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutEventInput | FavouriteCreateOrConnectWithoutEventInput[]
    createMany?: FavouriteCreateManyEventInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type Token_TransactionUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput> | Token_TransactionCreateWithoutEventInput[] | Token_TransactionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutEventInput | Token_TransactionCreateOrConnectWithoutEventInput[]
    createMany?: Token_TransactionCreateManyEventInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type AmenitiesUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput> | AmenitiesCreateWithoutEventInput[] | AmenitiesUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutEventInput | AmenitiesCreateOrConnectWithoutEventInput[]
    createMany?: AmenitiesCreateManyEventInputEnvelope
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput> | Emergency_ContactsCreateWithoutEventInput[] | Emergency_ContactsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Emergency_ContactsCreateOrConnectWithoutEventInput | Emergency_ContactsCreateOrConnectWithoutEventInput[]
    createMany?: Emergency_ContactsCreateManyEventInputEnvelope
    connect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput> | VenueCreateWithoutEventInput[] | VenueUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutEventInput | VenueCreateOrConnectWithoutEventInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventInput
    upsert?: UserUpsertWithoutEventInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventInput, UserUpdateWithoutEventInput>, UserUncheckedUpdateWithoutEventInput>
  }

  export type LostAndFoundUpdateManyWithoutEventNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput> | LostAndFoundCreateWithoutEventInput[] | LostAndFoundUncheckedCreateWithoutEventInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutEventInput | LostAndFoundCreateOrConnectWithoutEventInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutEventInput | LostAndFoundUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: LostAndFoundCreateManyEventInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutEventInput | LostAndFoundUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutEventInput | LostAndFoundUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type SponsorUpdateManyWithoutEventNestedInput = {
    create?: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput> | SponsorCreateWithoutEventInput[] | SponsorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutEventInput | SponsorCreateOrConnectWithoutEventInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutEventInput | SponsorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SponsorCreateManyEventInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutEventInput | SponsorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutEventInput | SponsorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type AdvertisementUpdateManyWithoutEventNestedInput = {
    create?: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput> | AdvertisementCreateWithoutEventInput[] | AdvertisementUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutEventInput | AdvertisementCreateOrConnectWithoutEventInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutEventInput | AdvertisementUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AdvertisementCreateManyEventInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutEventInput | AdvertisementUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutEventInput | AdvertisementUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type EventMapUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput> | EventMapCreateWithoutEventInput[] | EventMapUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventMapCreateOrConnectWithoutEventInput | EventMapCreateOrConnectWithoutEventInput[]
    upsert?: EventMapUpsertWithWhereUniqueWithoutEventInput | EventMapUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventMapCreateManyEventInputEnvelope
    set?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    disconnect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    delete?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    connect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    update?: EventMapUpdateWithWhereUniqueWithoutEventInput | EventMapUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventMapUpdateManyWithWhereWithoutEventInput | EventMapUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventMapScalarWhereInput | EventMapScalarWhereInput[]
  }

  export type ShopsUpdateManyWithoutEventNestedInput = {
    create?: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput> | ShopsCreateWithoutEventInput[] | ShopsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopsCreateOrConnectWithoutEventInput | ShopsCreateOrConnectWithoutEventInput[]
    upsert?: ShopsUpsertWithWhereUniqueWithoutEventInput | ShopsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ShopsCreateManyEventInputEnvelope
    set?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    disconnect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    delete?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    connect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    update?: ShopsUpdateWithWhereUniqueWithoutEventInput | ShopsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ShopsUpdateManyWithWhereWithoutEventInput | ShopsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ShopsScalarWhereInput | ShopsScalarWhereInput[]
  }

  export type ShopPaymentUpdateManyWithoutEventNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput> | ShopPaymentCreateWithoutEventInput[] | ShopPaymentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutEventInput | ShopPaymentCreateOrConnectWithoutEventInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutEventInput | ShopPaymentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ShopPaymentCreateManyEventInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutEventInput | ShopPaymentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutEventInput | ShopPaymentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutEventNestedInput = {
    create?: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput> | ReviewCreateWithoutEventInput[] | ReviewUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutEventInput | ReviewCreateOrConnectWithoutEventInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutEventInput | ReviewUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ReviewCreateManyEventInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutEventInput | ReviewUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutEventInput | ReviewUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ItineraryUpdateManyWithoutEventNestedInput = {
    create?: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput> | ItineraryCreateWithoutEventInput[] | ItineraryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEventInput | ItineraryCreateOrConnectWithoutEventInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutEventInput | ItineraryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ItineraryCreateManyEventInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutEventInput | ItineraryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutEventInput | ItineraryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type FavouriteUpdateManyWithoutEventNestedInput = {
    create?: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput> | FavouriteCreateWithoutEventInput[] | FavouriteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutEventInput | FavouriteCreateOrConnectWithoutEventInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutEventInput | FavouriteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: FavouriteCreateManyEventInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutEventInput | FavouriteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutEventInput | FavouriteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type Token_TransactionUpdateManyWithoutEventNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput> | Token_TransactionCreateWithoutEventInput[] | Token_TransactionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutEventInput | Token_TransactionCreateOrConnectWithoutEventInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutEventInput | Token_TransactionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: Token_TransactionCreateManyEventInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutEventInput | Token_TransactionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutEventInput | Token_TransactionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type AmenitiesUpdateManyWithoutEventNestedInput = {
    create?: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput> | AmenitiesCreateWithoutEventInput[] | AmenitiesUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutEventInput | AmenitiesCreateOrConnectWithoutEventInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutEventInput | AmenitiesUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AmenitiesCreateManyEventInputEnvelope
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutEventInput | AmenitiesUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutEventInput | AmenitiesUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type Emergency_ContactsUpdateManyWithoutEventNestedInput = {
    create?: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput> | Emergency_ContactsCreateWithoutEventInput[] | Emergency_ContactsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Emergency_ContactsCreateOrConnectWithoutEventInput | Emergency_ContactsCreateOrConnectWithoutEventInput[]
    upsert?: Emergency_ContactsUpsertWithWhereUniqueWithoutEventInput | Emergency_ContactsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: Emergency_ContactsCreateManyEventInputEnvelope
    set?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    disconnect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    delete?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    connect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    update?: Emergency_ContactsUpdateWithWhereUniqueWithoutEventInput | Emergency_ContactsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: Emergency_ContactsUpdateManyWithWhereWithoutEventInput | Emergency_ContactsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: Emergency_ContactsScalarWhereInput | Emergency_ContactsScalarWhereInput[]
  }

  export type VenueUpdateManyWithoutEventNestedInput = {
    create?: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput> | VenueCreateWithoutEventInput[] | VenueUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutEventInput | VenueCreateOrConnectWithoutEventInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutEventInput | VenueUpsertWithWhereUniqueWithoutEventInput[]
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutEventInput | VenueUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutEventInput | VenueUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type LostAndFoundUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput> | LostAndFoundCreateWithoutEventInput[] | LostAndFoundUncheckedCreateWithoutEventInput[]
    connectOrCreate?: LostAndFoundCreateOrConnectWithoutEventInput | LostAndFoundCreateOrConnectWithoutEventInput[]
    upsert?: LostAndFoundUpsertWithWhereUniqueWithoutEventInput | LostAndFoundUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: LostAndFoundCreateManyEventInputEnvelope
    set?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    disconnect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    delete?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    connect?: LostAndFoundWhereUniqueInput | LostAndFoundWhereUniqueInput[]
    update?: LostAndFoundUpdateWithWhereUniqueWithoutEventInput | LostAndFoundUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: LostAndFoundUpdateManyWithWhereWithoutEventInput | LostAndFoundUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
  }

  export type SponsorUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput> | SponsorCreateWithoutEventInput[] | SponsorUncheckedCreateWithoutEventInput[]
    connectOrCreate?: SponsorCreateOrConnectWithoutEventInput | SponsorCreateOrConnectWithoutEventInput[]
    upsert?: SponsorUpsertWithWhereUniqueWithoutEventInput | SponsorUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: SponsorCreateManyEventInputEnvelope
    set?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    disconnect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    delete?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    connect?: SponsorWhereUniqueInput | SponsorWhereUniqueInput[]
    update?: SponsorUpdateWithWhereUniqueWithoutEventInput | SponsorUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: SponsorUpdateManyWithWhereWithoutEventInput | SponsorUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
  }

  export type AdvertisementUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput> | AdvertisementCreateWithoutEventInput[] | AdvertisementUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutEventInput | AdvertisementCreateOrConnectWithoutEventInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutEventInput | AdvertisementUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AdvertisementCreateManyEventInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutEventInput | AdvertisementUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutEventInput | AdvertisementUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type EventMapUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput> | EventMapCreateWithoutEventInput[] | EventMapUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventMapCreateOrConnectWithoutEventInput | EventMapCreateOrConnectWithoutEventInput[]
    upsert?: EventMapUpsertWithWhereUniqueWithoutEventInput | EventMapUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventMapCreateManyEventInputEnvelope
    set?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    disconnect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    delete?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    connect?: EventMapWhereUniqueInput | EventMapWhereUniqueInput[]
    update?: EventMapUpdateWithWhereUniqueWithoutEventInput | EventMapUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventMapUpdateManyWithWhereWithoutEventInput | EventMapUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventMapScalarWhereInput | EventMapScalarWhereInput[]
  }

  export type ShopsUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput> | ShopsCreateWithoutEventInput[] | ShopsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopsCreateOrConnectWithoutEventInput | ShopsCreateOrConnectWithoutEventInput[]
    upsert?: ShopsUpsertWithWhereUniqueWithoutEventInput | ShopsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ShopsCreateManyEventInputEnvelope
    set?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    disconnect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    delete?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    connect?: ShopsWhereUniqueInput | ShopsWhereUniqueInput[]
    update?: ShopsUpdateWithWhereUniqueWithoutEventInput | ShopsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ShopsUpdateManyWithWhereWithoutEventInput | ShopsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ShopsScalarWhereInput | ShopsScalarWhereInput[]
  }

  export type ShopPaymentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput> | ShopPaymentCreateWithoutEventInput[] | ShopPaymentUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutEventInput | ShopPaymentCreateOrConnectWithoutEventInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutEventInput | ShopPaymentUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ShopPaymentCreateManyEventInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutEventInput | ShopPaymentUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutEventInput | ShopPaymentUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput> | ReviewCreateWithoutEventInput[] | ReviewUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutEventInput | ReviewCreateOrConnectWithoutEventInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutEventInput | ReviewUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ReviewCreateManyEventInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutEventInput | ReviewUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutEventInput | ReviewUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ItineraryUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput> | ItineraryCreateWithoutEventInput[] | ItineraryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ItineraryCreateOrConnectWithoutEventInput | ItineraryCreateOrConnectWithoutEventInput[]
    upsert?: ItineraryUpsertWithWhereUniqueWithoutEventInput | ItineraryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ItineraryCreateManyEventInputEnvelope
    set?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    disconnect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    delete?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    connect?: ItineraryWhereUniqueInput | ItineraryWhereUniqueInput[]
    update?: ItineraryUpdateWithWhereUniqueWithoutEventInput | ItineraryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ItineraryUpdateManyWithWhereWithoutEventInput | ItineraryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
  }

  export type FavouriteUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput> | FavouriteCreateWithoutEventInput[] | FavouriteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutEventInput | FavouriteCreateOrConnectWithoutEventInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutEventInput | FavouriteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: FavouriteCreateManyEventInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutEventInput | FavouriteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutEventInput | FavouriteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type Token_TransactionUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput> | Token_TransactionCreateWithoutEventInput[] | Token_TransactionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutEventInput | Token_TransactionCreateOrConnectWithoutEventInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutEventInput | Token_TransactionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: Token_TransactionCreateManyEventInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutEventInput | Token_TransactionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutEventInput | Token_TransactionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type AmenitiesUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput> | AmenitiesCreateWithoutEventInput[] | AmenitiesUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutEventInput | AmenitiesCreateOrConnectWithoutEventInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutEventInput | AmenitiesUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AmenitiesCreateManyEventInputEnvelope
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutEventInput | AmenitiesUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutEventInput | AmenitiesUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput> | Emergency_ContactsCreateWithoutEventInput[] | Emergency_ContactsUncheckedCreateWithoutEventInput[]
    connectOrCreate?: Emergency_ContactsCreateOrConnectWithoutEventInput | Emergency_ContactsCreateOrConnectWithoutEventInput[]
    upsert?: Emergency_ContactsUpsertWithWhereUniqueWithoutEventInput | Emergency_ContactsUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: Emergency_ContactsCreateManyEventInputEnvelope
    set?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    disconnect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    delete?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    connect?: Emergency_ContactsWhereUniqueInput | Emergency_ContactsWhereUniqueInput[]
    update?: Emergency_ContactsUpdateWithWhereUniqueWithoutEventInput | Emergency_ContactsUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: Emergency_ContactsUpdateManyWithWhereWithoutEventInput | Emergency_ContactsUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: Emergency_ContactsScalarWhereInput | Emergency_ContactsScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput> | VenueCreateWithoutEventInput[] | VenueUncheckedCreateWithoutEventInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutEventInput | VenueCreateOrConnectWithoutEventInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutEventInput | VenueUpsertWithWhereUniqueWithoutEventInput[]
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutEventInput | VenueUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutEventInput | VenueUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type User_PlanCreateNestedManyWithoutPlanInput = {
    create?: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput> | User_PlanCreateWithoutPlanInput[] | User_PlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutPlanInput | User_PlanCreateOrConnectWithoutPlanInput[]
    createMany?: User_PlanCreateManyPlanInputEnvelope
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
  }

  export type User_PlanUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput> | User_PlanCreateWithoutPlanInput[] | User_PlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutPlanInput | User_PlanCreateOrConnectWithoutPlanInput[]
    createMany?: User_PlanCreateManyPlanInputEnvelope
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
  }

  export type User_PlanUpdateManyWithoutPlanNestedInput = {
    create?: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput> | User_PlanCreateWithoutPlanInput[] | User_PlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutPlanInput | User_PlanCreateOrConnectWithoutPlanInput[]
    upsert?: User_PlanUpsertWithWhereUniqueWithoutPlanInput | User_PlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: User_PlanCreateManyPlanInputEnvelope
    set?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    disconnect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    delete?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    update?: User_PlanUpdateWithWhereUniqueWithoutPlanInput | User_PlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: User_PlanUpdateManyWithWhereWithoutPlanInput | User_PlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
  }

  export type User_PlanUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput> | User_PlanCreateWithoutPlanInput[] | User_PlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: User_PlanCreateOrConnectWithoutPlanInput | User_PlanCreateOrConnectWithoutPlanInput[]
    upsert?: User_PlanUpsertWithWhereUniqueWithoutPlanInput | User_PlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: User_PlanCreateManyPlanInputEnvelope
    set?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    disconnect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    delete?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    connect?: User_PlanWhereUniqueInput | User_PlanWhereUniqueInput[]
    update?: User_PlanUpdateWithWhereUniqueWithoutPlanInput | User_PlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: User_PlanUpdateManyWithWhereWithoutPlanInput | User_PlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type Token_TransactionCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput> | Token_TransactionCreateWithoutTransactionInput[] | Token_TransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutTransactionInput | Token_TransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: Token_TransactionCreateManyTransactionInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type Token_TransactionUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput> | Token_TransactionCreateWithoutTransactionInput[] | Token_TransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutTransactionInput | Token_TransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: Token_TransactionCreateManyTransactionInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type Token_TransactionUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput> | Token_TransactionCreateWithoutTransactionInput[] | Token_TransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutTransactionInput | Token_TransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutTransactionInput | Token_TransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Token_TransactionCreateManyTransactionInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutTransactionInput | Token_TransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutTransactionInput | Token_TransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type Token_TransactionUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput> | Token_TransactionCreateWithoutTransactionInput[] | Token_TransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutTransactionInput | Token_TransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutTransactionInput | Token_TransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: Token_TransactionCreateManyTransactionInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutTransactionInput | Token_TransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutTransactionInput | Token_TransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUser_planInput = {
    create?: XOR<UserCreateWithoutUser_planInput, UserUncheckedCreateWithoutUser_planInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_planInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutUser_planInput = {
    create?: XOR<PlanCreateWithoutUser_planInput, PlanUncheckedCreateWithoutUser_planInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUser_planInput
    connect?: PlanWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_planNestedInput = {
    create?: XOR<UserCreateWithoutUser_planInput, UserUncheckedCreateWithoutUser_planInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_planInput
    upsert?: UserUpsertWithoutUser_planInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_planInput, UserUpdateWithoutUser_planInput>, UserUncheckedUpdateWithoutUser_planInput>
  }

  export type PlanUpdateOneRequiredWithoutUser_planNestedInput = {
    create?: XOR<PlanCreateWithoutUser_planInput, PlanUncheckedCreateWithoutUser_planInput>
    connectOrCreate?: PlanCreateOrConnectWithoutUser_planInput
    upsert?: PlanUpsertWithoutUser_planInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutUser_planInput, PlanUpdateWithoutUser_planInput>, PlanUncheckedUpdateWithoutUser_planInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutSponsorInput = {
    create?: XOR<EventCreateWithoutSponsorInput, EventUncheckedCreateWithoutSponsorInput>
    connectOrCreate?: EventCreateOrConnectWithoutSponsorInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutSponsorNestedInput = {
    create?: XOR<EventCreateWithoutSponsorInput, EventUncheckedCreateWithoutSponsorInput>
    connectOrCreate?: EventCreateOrConnectWithoutSponsorInput
    upsert?: EventUpsertWithoutSponsorInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutSponsorInput, EventUpdateWithoutSponsorInput>, EventUncheckedUpdateWithoutSponsorInput>
  }

  export type EventCreateNestedOneWithoutAdvertisementInput = {
    create?: XOR<EventCreateWithoutAdvertisementInput, EventUncheckedCreateWithoutAdvertisementInput>
    connectOrCreate?: EventCreateOrConnectWithoutAdvertisementInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutAdvertisementNestedInput = {
    create?: XOR<EventCreateWithoutAdvertisementInput, EventUncheckedCreateWithoutAdvertisementInput>
    connectOrCreate?: EventCreateOrConnectWithoutAdvertisementInput
    upsert?: EventUpsertWithoutAdvertisementInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutAdvertisementInput, EventUpdateWithoutAdvertisementInput>, EventUncheckedUpdateWithoutAdvertisementInput>
  }

  export type EventCreateNestedOneWithoutLostandfoundInput = {
    create?: XOR<EventCreateWithoutLostandfoundInput, EventUncheckedCreateWithoutLostandfoundInput>
    connectOrCreate?: EventCreateOrConnectWithoutLostandfoundInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClaim_userInput = {
    create?: XOR<UserCreateWithoutClaim_userInput, UserUncheckedCreateWithoutClaim_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaim_userInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReporter_userInput = {
    create?: XOR<UserCreateWithoutReporter_userInput, UserUncheckedCreateWithoutReporter_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutReporter_userInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutLostandfoundNestedInput = {
    create?: XOR<EventCreateWithoutLostandfoundInput, EventUncheckedCreateWithoutLostandfoundInput>
    connectOrCreate?: EventCreateOrConnectWithoutLostandfoundInput
    upsert?: EventUpsertWithoutLostandfoundInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutLostandfoundInput, EventUpdateWithoutLostandfoundInput>, EventUncheckedUpdateWithoutLostandfoundInput>
  }

  export type UserUpdateOneRequiredWithoutClaim_userNestedInput = {
    create?: XOR<UserCreateWithoutClaim_userInput, UserUncheckedCreateWithoutClaim_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaim_userInput
    upsert?: UserUpsertWithoutClaim_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaim_userInput, UserUpdateWithoutClaim_userInput>, UserUncheckedUpdateWithoutClaim_userInput>
  }

  export type UserUpdateOneRequiredWithoutReporter_userNestedInput = {
    create?: XOR<UserCreateWithoutReporter_userInput, UserUncheckedCreateWithoutReporter_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutReporter_userInput
    upsert?: UserUpsertWithoutReporter_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReporter_userInput, UserUpdateWithoutReporter_userInput>, UserUncheckedUpdateWithoutReporter_userInput>
  }

  export type EventCreateNestedOneWithoutEventmapInput = {
    create?: XOR<EventCreateWithoutEventmapInput, EventUncheckedCreateWithoutEventmapInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventmapInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventmapNestedInput = {
    create?: XOR<EventCreateWithoutEventmapInput, EventUncheckedCreateWithoutEventmapInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventmapInput
    upsert?: EventUpsertWithoutEventmapInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventmapInput, EventUpdateWithoutEventmapInput>, EventUncheckedUpdateWithoutEventmapInput>
  }

  export type EventCreateNestedOneWithoutShopInput = {
    create?: XOR<EventCreateWithoutShopInput, EventUncheckedCreateWithoutShopInput>
    connectOrCreate?: EventCreateOrConnectWithoutShopInput
    connect?: EventWhereUniqueInput
  }

  export type ShopPaymentCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput> | ShopPaymentCreateWithoutShopInput[] | ShopPaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutShopInput | ShopPaymentCreateOrConnectWithoutShopInput[]
    createMany?: ShopPaymentCreateManyShopInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type Token_TransactionCreateNestedManyWithoutShopInput = {
    create?: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput> | Token_TransactionCreateWithoutShopInput[] | Token_TransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutShopInput | Token_TransactionCreateOrConnectWithoutShopInput[]
    createMany?: Token_TransactionCreateManyShopInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type ShopPaymentUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput> | ShopPaymentCreateWithoutShopInput[] | ShopPaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutShopInput | ShopPaymentCreateOrConnectWithoutShopInput[]
    createMany?: ShopPaymentCreateManyShopInputEnvelope
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
  }

  export type Token_TransactionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput> | Token_TransactionCreateWithoutShopInput[] | Token_TransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutShopInput | Token_TransactionCreateOrConnectWithoutShopInput[]
    createMany?: Token_TransactionCreateManyShopInputEnvelope
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
  }

  export type EventUpdateOneRequiredWithoutShopNestedInput = {
    create?: XOR<EventCreateWithoutShopInput, EventUncheckedCreateWithoutShopInput>
    connectOrCreate?: EventCreateOrConnectWithoutShopInput
    upsert?: EventUpsertWithoutShopInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutShopInput, EventUpdateWithoutShopInput>, EventUncheckedUpdateWithoutShopInput>
  }

  export type ShopPaymentUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput> | ShopPaymentCreateWithoutShopInput[] | ShopPaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutShopInput | ShopPaymentCreateOrConnectWithoutShopInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutShopInput | ShopPaymentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopPaymentCreateManyShopInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutShopInput | ShopPaymentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutShopInput | ShopPaymentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type Token_TransactionUpdateManyWithoutShopNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput> | Token_TransactionCreateWithoutShopInput[] | Token_TransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutShopInput | Token_TransactionCreateOrConnectWithoutShopInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutShopInput | Token_TransactionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: Token_TransactionCreateManyShopInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutShopInput | Token_TransactionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutShopInput | Token_TransactionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type ShopPaymentUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput> | ShopPaymentCreateWithoutShopInput[] | ShopPaymentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ShopPaymentCreateOrConnectWithoutShopInput | ShopPaymentCreateOrConnectWithoutShopInput[]
    upsert?: ShopPaymentUpsertWithWhereUniqueWithoutShopInput | ShopPaymentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ShopPaymentCreateManyShopInputEnvelope
    set?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    disconnect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    delete?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    connect?: ShopPaymentWhereUniqueInput | ShopPaymentWhereUniqueInput[]
    update?: ShopPaymentUpdateWithWhereUniqueWithoutShopInput | ShopPaymentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ShopPaymentUpdateManyWithWhereWithoutShopInput | ShopPaymentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
  }

  export type Token_TransactionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput> | Token_TransactionCreateWithoutShopInput[] | Token_TransactionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: Token_TransactionCreateOrConnectWithoutShopInput | Token_TransactionCreateOrConnectWithoutShopInput[]
    upsert?: Token_TransactionUpsertWithWhereUniqueWithoutShopInput | Token_TransactionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: Token_TransactionCreateManyShopInputEnvelope
    set?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    disconnect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    delete?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    connect?: Token_TransactionWhereUniqueInput | Token_TransactionWhereUniqueInput[]
    update?: Token_TransactionUpdateWithWhereUniqueWithoutShopInput | Token_TransactionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: Token_TransactionUpdateManyWithWhereWithoutShopInput | Token_TransactionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
  }

  export type ShopsCreateNestedOneWithoutShoppaymentInput = {
    create?: XOR<ShopsCreateWithoutShoppaymentInput, ShopsUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: ShopsCreateOrConnectWithoutShoppaymentInput
    connect?: ShopsWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutShoppaymentInput = {
    create?: XOR<EventCreateWithoutShoppaymentInput, EventUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: EventCreateOrConnectWithoutShoppaymentInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShoppaymentInput = {
    create?: XOR<UserCreateWithoutShoppaymentInput, UserUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppaymentInput
    connect?: UserWhereUniqueInput
  }

  export type ShopsUpdateOneRequiredWithoutShoppaymentNestedInput = {
    create?: XOR<ShopsCreateWithoutShoppaymentInput, ShopsUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: ShopsCreateOrConnectWithoutShoppaymentInput
    upsert?: ShopsUpsertWithoutShoppaymentInput
    connect?: ShopsWhereUniqueInput
    update?: XOR<XOR<ShopsUpdateToOneWithWhereWithoutShoppaymentInput, ShopsUpdateWithoutShoppaymentInput>, ShopsUncheckedUpdateWithoutShoppaymentInput>
  }

  export type EventUpdateOneRequiredWithoutShoppaymentNestedInput = {
    create?: XOR<EventCreateWithoutShoppaymentInput, EventUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: EventCreateOrConnectWithoutShoppaymentInput
    upsert?: EventUpsertWithoutShoppaymentInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutShoppaymentInput, EventUpdateWithoutShoppaymentInput>, EventUncheckedUpdateWithoutShoppaymentInput>
  }

  export type UserUpdateOneRequiredWithoutShoppaymentNestedInput = {
    create?: XOR<UserCreateWithoutShoppaymentInput, UserUncheckedCreateWithoutShoppaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppaymentInput
    upsert?: UserUpsertWithoutShoppaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShoppaymentInput, UserUpdateWithoutShoppaymentInput>, UserUncheckedUpdateWithoutShoppaymentInput>
  }

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    connect?: UserWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutReviewInput = {
    create?: XOR<EventCreateWithoutReviewInput, EventUncheckedCreateWithoutReviewInput>
    connectOrCreate?: EventCreateOrConnectWithoutReviewInput
    connect?: EventWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    upsert?: UserUpsertWithoutReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>
  }

  export type EventUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<EventCreateWithoutReviewInput, EventUncheckedCreateWithoutReviewInput>
    connectOrCreate?: EventCreateOrConnectWithoutReviewInput
    upsert?: EventUpsertWithoutReviewInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutReviewInput, EventUpdateWithoutReviewInput>, EventUncheckedUpdateWithoutReviewInput>
  }

  export type EventCreateNestedOneWithoutItineraryInput = {
    create?: XOR<EventCreateWithoutItineraryInput, EventUncheckedCreateWithoutItineraryInput>
    connectOrCreate?: EventCreateOrConnectWithoutItineraryInput
    connect?: EventWhereUniqueInput
  }

  export type FavouriteCreateNestedManyWithoutItineraryInput = {
    create?: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput> | FavouriteCreateWithoutItineraryInput[] | FavouriteUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutItineraryInput | FavouriteCreateOrConnectWithoutItineraryInput[]
    createMany?: FavouriteCreateManyItineraryInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type FavouriteUncheckedCreateNestedManyWithoutItineraryInput = {
    create?: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput> | FavouriteCreateWithoutItineraryInput[] | FavouriteUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutItineraryInput | FavouriteCreateOrConnectWithoutItineraryInput[]
    createMany?: FavouriteCreateManyItineraryInputEnvelope
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
  }

  export type EventUpdateOneRequiredWithoutItineraryNestedInput = {
    create?: XOR<EventCreateWithoutItineraryInput, EventUncheckedCreateWithoutItineraryInput>
    connectOrCreate?: EventCreateOrConnectWithoutItineraryInput
    upsert?: EventUpsertWithoutItineraryInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutItineraryInput, EventUpdateWithoutItineraryInput>, EventUncheckedUpdateWithoutItineraryInput>
  }

  export type FavouriteUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput> | FavouriteCreateWithoutItineraryInput[] | FavouriteUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutItineraryInput | FavouriteCreateOrConnectWithoutItineraryInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutItineraryInput | FavouriteUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: FavouriteCreateManyItineraryInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutItineraryInput | FavouriteUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutItineraryInput | FavouriteUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type FavouriteUncheckedUpdateManyWithoutItineraryNestedInput = {
    create?: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput> | FavouriteCreateWithoutItineraryInput[] | FavouriteUncheckedCreateWithoutItineraryInput[]
    connectOrCreate?: FavouriteCreateOrConnectWithoutItineraryInput | FavouriteCreateOrConnectWithoutItineraryInput[]
    upsert?: FavouriteUpsertWithWhereUniqueWithoutItineraryInput | FavouriteUpsertWithWhereUniqueWithoutItineraryInput[]
    createMany?: FavouriteCreateManyItineraryInputEnvelope
    set?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    disconnect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    delete?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    connect?: FavouriteWhereUniqueInput | FavouriteWhereUniqueInput[]
    update?: FavouriteUpdateWithWhereUniqueWithoutItineraryInput | FavouriteUpdateWithWhereUniqueWithoutItineraryInput[]
    updateMany?: FavouriteUpdateManyWithWhereWithoutItineraryInput | FavouriteUpdateManyWithWhereWithoutItineraryInput[]
    deleteMany?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutFavouriteInput = {
    create?: XOR<EventCreateWithoutFavouriteInput, EventUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: EventCreateOrConnectWithoutFavouriteInput
    connect?: EventWhereUniqueInput
  }

  export type ItineraryCreateNestedOneWithoutFavouriteInput = {
    create?: XOR<ItineraryCreateWithoutFavouriteInput, ItineraryUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutFavouriteInput
    connect?: ItineraryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavouriteInput = {
    create?: XOR<UserCreateWithoutFavouriteInput, UserUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavouriteInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutFavouriteNestedInput = {
    create?: XOR<EventCreateWithoutFavouriteInput, EventUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: EventCreateOrConnectWithoutFavouriteInput
    upsert?: EventUpsertWithoutFavouriteInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutFavouriteInput, EventUpdateWithoutFavouriteInput>, EventUncheckedUpdateWithoutFavouriteInput>
  }

  export type ItineraryUpdateOneRequiredWithoutFavouriteNestedInput = {
    create?: XOR<ItineraryCreateWithoutFavouriteInput, ItineraryUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: ItineraryCreateOrConnectWithoutFavouriteInput
    upsert?: ItineraryUpsertWithoutFavouriteInput
    connect?: ItineraryWhereUniqueInput
    update?: XOR<XOR<ItineraryUpdateToOneWithWhereWithoutFavouriteInput, ItineraryUpdateWithoutFavouriteInput>, ItineraryUncheckedUpdateWithoutFavouriteInput>
  }

  export type UserUpdateOneRequiredWithoutFavouriteNestedInput = {
    create?: XOR<UserCreateWithoutFavouriteInput, UserUncheckedCreateWithoutFavouriteInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavouriteInput
    upsert?: UserUpsertWithoutFavouriteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavouriteInput, UserUpdateWithoutFavouriteInput>, UserUncheckedUpdateWithoutFavouriteInput>
  }

  export type EventCreateNestedOneWithoutTokentransactionInput = {
    create?: XOR<EventCreateWithoutTokentransactionInput, EventUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: EventCreateOrConnectWithoutTokentransactionInput
    connect?: EventWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutTokentransactionInput = {
    create?: XOR<TransactionCreateWithoutTokentransactionInput, TransactionUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTokentransactionInput
    connect?: TransactionWhereUniqueInput
  }

  export type ShopsCreateNestedOneWithoutTokentransactionInput = {
    create?: XOR<ShopsCreateWithoutTokentransactionInput, ShopsUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: ShopsCreateOrConnectWithoutTokentransactionInput
    connect?: ShopsWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutTokentransactionNestedInput = {
    create?: XOR<EventCreateWithoutTokentransactionInput, EventUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: EventCreateOrConnectWithoutTokentransactionInput
    upsert?: EventUpsertWithoutTokentransactionInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTokentransactionInput, EventUpdateWithoutTokentransactionInput>, EventUncheckedUpdateWithoutTokentransactionInput>
  }

  export type TransactionUpdateOneRequiredWithoutTokentransactionNestedInput = {
    create?: XOR<TransactionCreateWithoutTokentransactionInput, TransactionUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTokentransactionInput
    upsert?: TransactionUpsertWithoutTokentransactionInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutTokentransactionInput, TransactionUpdateWithoutTokentransactionInput>, TransactionUncheckedUpdateWithoutTokentransactionInput>
  }

  export type ShopsUpdateOneRequiredWithoutTokentransactionNestedInput = {
    create?: XOR<ShopsCreateWithoutTokentransactionInput, ShopsUncheckedCreateWithoutTokentransactionInput>
    connectOrCreate?: ShopsCreateOrConnectWithoutTokentransactionInput
    upsert?: ShopsUpsertWithoutTokentransactionInput
    connect?: ShopsWhereUniqueInput
    update?: XOR<XOR<ShopsUpdateToOneWithWhereWithoutTokentransactionInput, ShopsUpdateWithoutTokentransactionInput>, ShopsUncheckedUpdateWithoutTokentransactionInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type EventCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<EventCreateWithoutAmenitiesInput, EventUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: EventCreateOrConnectWithoutAmenitiesInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<EventCreateWithoutAmenitiesInput, EventUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: EventCreateOrConnectWithoutAmenitiesInput
    upsert?: EventUpsertWithoutAmenitiesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutAmenitiesInput, EventUpdateWithoutAmenitiesInput>, EventUncheckedUpdateWithoutAmenitiesInput>
  }

  export type EventCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutEmergency_contactsInput = {
    create?: XOR<EventCreateWithoutEmergency_contactsInput, EventUncheckedCreateWithoutEmergency_contactsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEmergency_contactsInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEmergency_contactsNestedInput = {
    create?: XOR<EventCreateWithoutEmergency_contactsInput, EventUncheckedCreateWithoutEmergency_contactsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEmergency_contactsInput
    upsert?: EventUpsertWithoutEmergency_contactsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEmergency_contactsInput, EventUpdateWithoutEmergency_contactsInput>, EventUncheckedUpdateWithoutEmergency_contactsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUserInput = {
    role_name: string
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    role_id?: number
    role_name: string
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type User_PlanCreateWithoutUserInput = {
    is_activate: boolean
    plan: PlanCreateNestedOneWithoutUser_planInput
  }

  export type User_PlanUncheckedCreateWithoutUserInput = {
    plan_id: number
    is_activate: boolean
  }

  export type User_PlanCreateOrConnectWithoutUserInput = {
    where: User_PlanWhereUniqueInput
    create: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput>
  }

  export type User_PlanCreateManyUserInputEnvelope = {
    data: User_PlanCreateManyUserInput | User_PlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
    tokentransaction?: Token_TransactionCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatorInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatorInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventCreateManyCreatorInputEnvelope = {
    data: EventCreateManyCreatorInput | EventCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ShopPaymentCreateWithoutUserInput = {
    amount: number
    shop: ShopsCreateNestedOneWithoutShoppaymentInput
    event: EventCreateNestedOneWithoutShoppaymentInput
  }

  export type ShopPaymentUncheckedCreateWithoutUserInput = {
    payment_id?: number
    amount: number
    shop_id: number
    event_id: number
  }

  export type ShopPaymentCreateOrConnectWithoutUserInput = {
    where: ShopPaymentWhereUniqueInput
    create: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput>
  }

  export type ShopPaymentCreateManyUserInputEnvelope = {
    data: ShopPaymentCreateManyUserInput | ShopPaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    review_title: string
    review_desc: string
    rating: number
    timestamp: Date | string
    event: EventCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    review_id?: number
    review_title: string
    review_desc: string
    rating: number
    timestamp: Date | string
    event_id: number
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavouriteCreateWithoutUserInput = {
    event: EventCreateNestedOneWithoutFavouriteInput
    itinerary: ItineraryCreateNestedOneWithoutFavouriteInput
  }

  export type FavouriteUncheckedCreateWithoutUserInput = {
    event_id: number
    itinerary_id: number
  }

  export type FavouriteCreateOrConnectWithoutUserInput = {
    where: FavouriteWhereUniqueInput
    create: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput>
  }

  export type FavouriteCreateManyUserInputEnvelope = {
    data: FavouriteCreateManyUserInput | FavouriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    body: string
    type: string
    timestamp: Date | string
    event_id: number
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    body: string
    type: string
    timestamp: Date | string
    event_id: number
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LostAndFoundCreateWithoutClaim_userInput = {
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    event: EventCreateNestedOneWithoutLostandfoundInput
    reporter_user: UserCreateNestedOneWithoutReporter_userInput
  }

  export type LostAndFoundUncheckedCreateWithoutClaim_userInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type LostAndFoundCreateOrConnectWithoutClaim_userInput = {
    where: LostAndFoundWhereUniqueInput
    create: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput>
  }

  export type LostAndFoundCreateManyClaim_userInputEnvelope = {
    data: LostAndFoundCreateManyClaim_userInput | LostAndFoundCreateManyClaim_userInput[]
    skipDuplicates?: boolean
  }

  export type LostAndFoundCreateWithoutReporter_userInput = {
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    event: EventCreateNestedOneWithoutLostandfoundInput
    claim_user: UserCreateNestedOneWithoutClaim_userInput
  }

  export type LostAndFoundUncheckedCreateWithoutReporter_userInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
  }

  export type LostAndFoundCreateOrConnectWithoutReporter_userInput = {
    where: LostAndFoundWhereUniqueInput
    create: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput>
  }

  export type LostAndFoundCreateManyReporter_userInputEnvelope = {
    data: LostAndFoundCreateManyReporter_userInput | LostAndFoundCreateManyReporter_userInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUserInput = {
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateWithoutUserInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type User_PlanUpsertWithWhereUniqueWithoutUserInput = {
    where: User_PlanWhereUniqueInput
    update: XOR<User_PlanUpdateWithoutUserInput, User_PlanUncheckedUpdateWithoutUserInput>
    create: XOR<User_PlanCreateWithoutUserInput, User_PlanUncheckedCreateWithoutUserInput>
  }

  export type User_PlanUpdateWithWhereUniqueWithoutUserInput = {
    where: User_PlanWhereUniqueInput
    data: XOR<User_PlanUpdateWithoutUserInput, User_PlanUncheckedUpdateWithoutUserInput>
  }

  export type User_PlanUpdateManyWithWhereWithoutUserInput = {
    where: User_PlanScalarWhereInput
    data: XOR<User_PlanUpdateManyMutationInput, User_PlanUncheckedUpdateManyWithoutUserInput>
  }

  export type User_PlanScalarWhereInput = {
    AND?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
    OR?: User_PlanScalarWhereInput[]
    NOT?: User_PlanScalarWhereInput | User_PlanScalarWhereInput[]
    plan_id?: IntFilter<"User_Plan"> | number
    user_id?: IntFilter<"User_Plan"> | number
    is_activate?: BoolFilter<"User_Plan"> | boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    user_id?: IntFilter<"Transaction"> | number
    plan_id?: IntFilter<"Transaction"> | number
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    GST?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFilter<"Transaction"> | string
    transaction_type?: StringFilter<"Transaction"> | string
  }

  export type EventUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    event_id?: IntFilter<"Event"> | number
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    location?: StringFilter<"Event"> | string
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    event_tags?: StringFilter<"Event"> | string
    creator_id?: IntFilter<"Event"> | number
    approval?: BoolFilter<"Event"> | boolean
    status?: StringFilter<"Event"> | string
    entry_fee?: FloatFilter<"Event"> | number
    thumbnail_link?: StringFilter<"Event"> | string
    banner_link?: DateTimeFilter<"Event"> | Date | string
    video_link?: DateTimeFilter<"Event"> | Date | string
    venue_id?: IntFilter<"Event"> | number
  }

  export type ShopPaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: ShopPaymentWhereUniqueInput
    update: XOR<ShopPaymentUpdateWithoutUserInput, ShopPaymentUncheckedUpdateWithoutUserInput>
    create: XOR<ShopPaymentCreateWithoutUserInput, ShopPaymentUncheckedCreateWithoutUserInput>
  }

  export type ShopPaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: ShopPaymentWhereUniqueInput
    data: XOR<ShopPaymentUpdateWithoutUserInput, ShopPaymentUncheckedUpdateWithoutUserInput>
  }

  export type ShopPaymentUpdateManyWithWhereWithoutUserInput = {
    where: ShopPaymentScalarWhereInput
    data: XOR<ShopPaymentUpdateManyMutationInput, ShopPaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type ShopPaymentScalarWhereInput = {
    AND?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
    OR?: ShopPaymentScalarWhereInput[]
    NOT?: ShopPaymentScalarWhereInput | ShopPaymentScalarWhereInput[]
    payment_id?: IntFilter<"ShopPayment"> | number
    amount?: FloatFilter<"ShopPayment"> | number
    shop_id?: IntFilter<"ShopPayment"> | number
    event_id?: IntFilter<"ShopPayment"> | number
    user_id?: IntFilter<"ShopPayment"> | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    review_id?: IntFilter<"Review"> | number
    review_title?: StringFilter<"Review"> | string
    review_desc?: StringFilter<"Review"> | string
    user_id?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    timestamp?: DateTimeFilter<"Review"> | Date | string
    event_id?: IntFilter<"Review"> | number
  }

  export type FavouriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavouriteWhereUniqueInput
    update: XOR<FavouriteUpdateWithoutUserInput, FavouriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavouriteCreateWithoutUserInput, FavouriteUncheckedCreateWithoutUserInput>
  }

  export type FavouriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavouriteWhereUniqueInput
    data: XOR<FavouriteUpdateWithoutUserInput, FavouriteUncheckedUpdateWithoutUserInput>
  }

  export type FavouriteUpdateManyWithWhereWithoutUserInput = {
    where: FavouriteScalarWhereInput
    data: XOR<FavouriteUpdateManyMutationInput, FavouriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavouriteScalarWhereInput = {
    AND?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
    OR?: FavouriteScalarWhereInput[]
    NOT?: FavouriteScalarWhereInput | FavouriteScalarWhereInput[]
    event_id?: IntFilter<"Favourite"> | number
    itinerary_id?: IntFilter<"Favourite"> | number
    user_id?: IntFilter<"Favourite"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    user_id?: IntFilter<"Notification"> | number
    event_id?: IntFilter<"Notification"> | number
  }

  export type LostAndFoundUpsertWithWhereUniqueWithoutClaim_userInput = {
    where: LostAndFoundWhereUniqueInput
    update: XOR<LostAndFoundUpdateWithoutClaim_userInput, LostAndFoundUncheckedUpdateWithoutClaim_userInput>
    create: XOR<LostAndFoundCreateWithoutClaim_userInput, LostAndFoundUncheckedCreateWithoutClaim_userInput>
  }

  export type LostAndFoundUpdateWithWhereUniqueWithoutClaim_userInput = {
    where: LostAndFoundWhereUniqueInput
    data: XOR<LostAndFoundUpdateWithoutClaim_userInput, LostAndFoundUncheckedUpdateWithoutClaim_userInput>
  }

  export type LostAndFoundUpdateManyWithWhereWithoutClaim_userInput = {
    where: LostAndFoundScalarWhereInput
    data: XOR<LostAndFoundUpdateManyMutationInput, LostAndFoundUncheckedUpdateManyWithoutClaim_userInput>
  }

  export type LostAndFoundScalarWhereInput = {
    AND?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
    OR?: LostAndFoundScalarWhereInput[]
    NOT?: LostAndFoundScalarWhereInput | LostAndFoundScalarWhereInput[]
    lost_and_found_id?: IntFilter<"LostAndFound"> | number
    event_id?: IntFilter<"LostAndFound"> | number
    item_name?: StringFilter<"LostAndFound"> | string
    description?: StringFilter<"LostAndFound"> | string
    is_claimed?: BoolFilter<"LostAndFound"> | boolean
    claim_user_id?: IntFilter<"LostAndFound"> | number
    reporting_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    claim_timestamp?: DateTimeFilter<"LostAndFound"> | Date | string
    reporter_user_id?: IntFilter<"LostAndFound"> | number
  }

  export type LostAndFoundUpsertWithWhereUniqueWithoutReporter_userInput = {
    where: LostAndFoundWhereUniqueInput
    update: XOR<LostAndFoundUpdateWithoutReporter_userInput, LostAndFoundUncheckedUpdateWithoutReporter_userInput>
    create: XOR<LostAndFoundCreateWithoutReporter_userInput, LostAndFoundUncheckedCreateWithoutReporter_userInput>
  }

  export type LostAndFoundUpdateWithWhereUniqueWithoutReporter_userInput = {
    where: LostAndFoundWhereUniqueInput
    data: XOR<LostAndFoundUpdateWithoutReporter_userInput, LostAndFoundUncheckedUpdateWithoutReporter_userInput>
  }

  export type LostAndFoundUpdateManyWithWhereWithoutReporter_userInput = {
    where: LostAndFoundScalarWhereInput
    data: XOR<LostAndFoundUpdateManyMutationInput, LostAndFoundUncheckedUpdateManyWithoutReporter_userInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
  }

  export type UserCreateWithoutEventInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
  }

  export type LostAndFoundCreateWithoutEventInput = {
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    claim_user: UserCreateNestedOneWithoutClaim_userInput
    reporter_user: UserCreateNestedOneWithoutReporter_userInput
  }

  export type LostAndFoundUncheckedCreateWithoutEventInput = {
    lost_and_found_id?: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type LostAndFoundCreateOrConnectWithoutEventInput = {
    where: LostAndFoundWhereUniqueInput
    create: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput>
  }

  export type LostAndFoundCreateManyEventInputEnvelope = {
    data: LostAndFoundCreateManyEventInput | LostAndFoundCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type SponsorCreateWithoutEventInput = {
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
  }

  export type SponsorUncheckedCreateWithoutEventInput = {
    sponsor_id?: number
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
  }

  export type SponsorCreateOrConnectWithoutEventInput = {
    where: SponsorWhereUniqueInput
    create: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput>
  }

  export type SponsorCreateManyEventInputEnvelope = {
    data: SponsorCreateManyEventInput | SponsorCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type AdvertisementCreateWithoutEventInput = {
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
  }

  export type AdvertisementUncheckedCreateWithoutEventInput = {
    advertisement_id?: number
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
  }

  export type AdvertisementCreateOrConnectWithoutEventInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput>
  }

  export type AdvertisementCreateManyEventInputEnvelope = {
    data: AdvertisementCreateManyEventInput | AdvertisementCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventMapCreateWithoutEventInput = {
    map_object: string
  }

  export type EventMapUncheckedCreateWithoutEventInput = {
    event_map_id?: number
    map_object: string
  }

  export type EventMapCreateOrConnectWithoutEventInput = {
    where: EventMapWhereUniqueInput
    create: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput>
  }

  export type EventMapCreateManyEventInputEnvelope = {
    data: EventMapCreateManyEventInput | EventMapCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ShopsCreateWithoutEventInput = {
    shop_name: string
    shop_type: string
    shoppayment?: ShopPaymentCreateNestedManyWithoutShopInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutShopInput
  }

  export type ShopsUncheckedCreateWithoutEventInput = {
    shop_id?: number
    shop_name: string
    shop_type: string
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutShopInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopsCreateOrConnectWithoutEventInput = {
    where: ShopsWhereUniqueInput
    create: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput>
  }

  export type ShopsCreateManyEventInputEnvelope = {
    data: ShopsCreateManyEventInput | ShopsCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ShopPaymentCreateWithoutEventInput = {
    amount: number
    shop: ShopsCreateNestedOneWithoutShoppaymentInput
    User: UserCreateNestedOneWithoutShoppaymentInput
  }

  export type ShopPaymentUncheckedCreateWithoutEventInput = {
    payment_id?: number
    amount: number
    shop_id: number
    user_id: number
  }

  export type ShopPaymentCreateOrConnectWithoutEventInput = {
    where: ShopPaymentWhereUniqueInput
    create: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput>
  }

  export type ShopPaymentCreateManyEventInputEnvelope = {
    data: ShopPaymentCreateManyEventInput | ShopPaymentCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutEventInput = {
    review_title: string
    review_desc: string
    rating: number
    timestamp: Date | string
    User: UserCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutEventInput = {
    review_id?: number
    review_title: string
    review_desc: string
    user_id: number
    rating: number
    timestamp: Date | string
  }

  export type ReviewCreateOrConnectWithoutEventInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput>
  }

  export type ReviewCreateManyEventInputEnvelope = {
    data: ReviewCreateManyEventInput | ReviewCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ItineraryCreateWithoutEventInput = {
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
    favourite?: FavouriteCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutEventInput = {
    itinerary_id?: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
    favourite?: FavouriteUncheckedCreateNestedManyWithoutItineraryInput
  }

  export type ItineraryCreateOrConnectWithoutEventInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput>
  }

  export type ItineraryCreateManyEventInputEnvelope = {
    data: ItineraryCreateManyEventInput | ItineraryCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type FavouriteCreateWithoutEventInput = {
    itinerary: ItineraryCreateNestedOneWithoutFavouriteInput
    user: UserCreateNestedOneWithoutFavouriteInput
  }

  export type FavouriteUncheckedCreateWithoutEventInput = {
    itinerary_id: number
    user_id: number
  }

  export type FavouriteCreateOrConnectWithoutEventInput = {
    where: FavouriteWhereUniqueInput
    create: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput>
  }

  export type FavouriteCreateManyEventInputEnvelope = {
    data: FavouriteCreateManyEventInput | FavouriteCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type Token_TransactionCreateWithoutEventInput = {
    transaction_type: string
    token: number
    transaction: TransactionCreateNestedOneWithoutTokentransactionInput
    shop: ShopsCreateNestedOneWithoutTokentransactionInput
  }

  export type Token_TransactionUncheckedCreateWithoutEventInput = {
    ID?: number
    transaction_type: string
    token: number
    transaction_ID: number
    shop_ID: number
  }

  export type Token_TransactionCreateOrConnectWithoutEventInput = {
    where: Token_TransactionWhereUniqueInput
    create: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput>
  }

  export type Token_TransactionCreateManyEventInputEnvelope = {
    data: Token_TransactionCreateManyEventInput | Token_TransactionCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type AmenitiesCreateWithoutEventInput = {
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
  }

  export type AmenitiesUncheckedCreateWithoutEventInput = {
    amenity_id?: number
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
  }

  export type AmenitiesCreateOrConnectWithoutEventInput = {
    where: AmenitiesWhereUniqueInput
    create: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput>
  }

  export type AmenitiesCreateManyEventInputEnvelope = {
    data: AmenitiesCreateManyEventInput | AmenitiesCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type Emergency_ContactsCreateWithoutEventInput = {
    contact_name: string
    contact_number: string
    contact_type: string
  }

  export type Emergency_ContactsUncheckedCreateWithoutEventInput = {
    id?: number
    contact_name: string
    contact_number: string
    contact_type: string
  }

  export type Emergency_ContactsCreateOrConnectWithoutEventInput = {
    where: Emergency_ContactsWhereUniqueInput
    create: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput>
  }

  export type Emergency_ContactsCreateManyEventInputEnvelope = {
    data: Emergency_ContactsCreateManyEventInput | Emergency_ContactsCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutEventInput = {
    name: string
    address: string
    latitude: Date | string
    longitude: string
  }

  export type VenueUncheckedCreateWithoutEventInput = {
    id?: number
    name: string
    address: string
    latitude: Date | string
    longitude: string
  }

  export type VenueCreateOrConnectWithoutEventInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput>
  }

  export type UserUpsertWithoutEventInput = {
    update: XOR<UserUpdateWithoutEventInput, UserUncheckedUpdateWithoutEventInput>
    create: XOR<UserCreateWithoutEventInput, UserUncheckedCreateWithoutEventInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventInput, UserUncheckedUpdateWithoutEventInput>
  }

  export type UserUpdateWithoutEventInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LostAndFoundUpsertWithWhereUniqueWithoutEventInput = {
    where: LostAndFoundWhereUniqueInput
    update: XOR<LostAndFoundUpdateWithoutEventInput, LostAndFoundUncheckedUpdateWithoutEventInput>
    create: XOR<LostAndFoundCreateWithoutEventInput, LostAndFoundUncheckedCreateWithoutEventInput>
  }

  export type LostAndFoundUpdateWithWhereUniqueWithoutEventInput = {
    where: LostAndFoundWhereUniqueInput
    data: XOR<LostAndFoundUpdateWithoutEventInput, LostAndFoundUncheckedUpdateWithoutEventInput>
  }

  export type LostAndFoundUpdateManyWithWhereWithoutEventInput = {
    where: LostAndFoundScalarWhereInput
    data: XOR<LostAndFoundUpdateManyMutationInput, LostAndFoundUncheckedUpdateManyWithoutEventInput>
  }

  export type SponsorUpsertWithWhereUniqueWithoutEventInput = {
    where: SponsorWhereUniqueInput
    update: XOR<SponsorUpdateWithoutEventInput, SponsorUncheckedUpdateWithoutEventInput>
    create: XOR<SponsorCreateWithoutEventInput, SponsorUncheckedCreateWithoutEventInput>
  }

  export type SponsorUpdateWithWhereUniqueWithoutEventInput = {
    where: SponsorWhereUniqueInput
    data: XOR<SponsorUpdateWithoutEventInput, SponsorUncheckedUpdateWithoutEventInput>
  }

  export type SponsorUpdateManyWithWhereWithoutEventInput = {
    where: SponsorScalarWhereInput
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyWithoutEventInput>
  }

  export type SponsorScalarWhereInput = {
    AND?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    OR?: SponsorScalarWhereInput[]
    NOT?: SponsorScalarWhereInput | SponsorScalarWhereInput[]
    sponsor_id?: IntFilter<"Sponsor"> | number
    event_id?: IntFilter<"Sponsor"> | number
    title?: StringFilter<"Sponsor"> | string
    description?: StringFilter<"Sponsor"> | string
    image_url?: StringFilter<"Sponsor"> | string
    start_time?: StringFilter<"Sponsor"> | string
    end_time?: StringFilter<"Sponsor"> | string
    venue_id?: IntFilter<"Sponsor"> | number
  }

  export type AdvertisementUpsertWithWhereUniqueWithoutEventInput = {
    where: AdvertisementWhereUniqueInput
    update: XOR<AdvertisementUpdateWithoutEventInput, AdvertisementUncheckedUpdateWithoutEventInput>
    create: XOR<AdvertisementCreateWithoutEventInput, AdvertisementUncheckedCreateWithoutEventInput>
  }

  export type AdvertisementUpdateWithWhereUniqueWithoutEventInput = {
    where: AdvertisementWhereUniqueInput
    data: XOR<AdvertisementUpdateWithoutEventInput, AdvertisementUncheckedUpdateWithoutEventInput>
  }

  export type AdvertisementUpdateManyWithWhereWithoutEventInput = {
    where: AdvertisementScalarWhereInput
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyWithoutEventInput>
  }

  export type AdvertisementScalarWhereInput = {
    AND?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    OR?: AdvertisementScalarWhereInput[]
    NOT?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    advertisement_id?: IntFilter<"Advertisement"> | number
    event_id?: IntFilter<"Advertisement"> | number
    title?: StringFilter<"Advertisement"> | string
    level?: StringFilter<"Advertisement"> | string
    start_date?: DateTimeFilter<"Advertisement"> | Date | string
    end_date?: DateTimeFilter<"Advertisement"> | Date | string
    image_url?: StringFilter<"Advertisement"> | string
  }

  export type EventMapUpsertWithWhereUniqueWithoutEventInput = {
    where: EventMapWhereUniqueInput
    update: XOR<EventMapUpdateWithoutEventInput, EventMapUncheckedUpdateWithoutEventInput>
    create: XOR<EventMapCreateWithoutEventInput, EventMapUncheckedCreateWithoutEventInput>
  }

  export type EventMapUpdateWithWhereUniqueWithoutEventInput = {
    where: EventMapWhereUniqueInput
    data: XOR<EventMapUpdateWithoutEventInput, EventMapUncheckedUpdateWithoutEventInput>
  }

  export type EventMapUpdateManyWithWhereWithoutEventInput = {
    where: EventMapScalarWhereInput
    data: XOR<EventMapUpdateManyMutationInput, EventMapUncheckedUpdateManyWithoutEventInput>
  }

  export type EventMapScalarWhereInput = {
    AND?: EventMapScalarWhereInput | EventMapScalarWhereInput[]
    OR?: EventMapScalarWhereInput[]
    NOT?: EventMapScalarWhereInput | EventMapScalarWhereInput[]
    event_map_id?: IntFilter<"EventMap"> | number
    map_object?: StringFilter<"EventMap"> | string
    event_id?: IntFilter<"EventMap"> | number
  }

  export type ShopsUpsertWithWhereUniqueWithoutEventInput = {
    where: ShopsWhereUniqueInput
    update: XOR<ShopsUpdateWithoutEventInput, ShopsUncheckedUpdateWithoutEventInput>
    create: XOR<ShopsCreateWithoutEventInput, ShopsUncheckedCreateWithoutEventInput>
  }

  export type ShopsUpdateWithWhereUniqueWithoutEventInput = {
    where: ShopsWhereUniqueInput
    data: XOR<ShopsUpdateWithoutEventInput, ShopsUncheckedUpdateWithoutEventInput>
  }

  export type ShopsUpdateManyWithWhereWithoutEventInput = {
    where: ShopsScalarWhereInput
    data: XOR<ShopsUpdateManyMutationInput, ShopsUncheckedUpdateManyWithoutEventInput>
  }

  export type ShopsScalarWhereInput = {
    AND?: ShopsScalarWhereInput | ShopsScalarWhereInput[]
    OR?: ShopsScalarWhereInput[]
    NOT?: ShopsScalarWhereInput | ShopsScalarWhereInput[]
    shop_id?: IntFilter<"Shops"> | number
    shop_name?: StringFilter<"Shops"> | string
    event_id?: IntFilter<"Shops"> | number
    shop_type?: StringFilter<"Shops"> | string
  }

  export type ShopPaymentUpsertWithWhereUniqueWithoutEventInput = {
    where: ShopPaymentWhereUniqueInput
    update: XOR<ShopPaymentUpdateWithoutEventInput, ShopPaymentUncheckedUpdateWithoutEventInput>
    create: XOR<ShopPaymentCreateWithoutEventInput, ShopPaymentUncheckedCreateWithoutEventInput>
  }

  export type ShopPaymentUpdateWithWhereUniqueWithoutEventInput = {
    where: ShopPaymentWhereUniqueInput
    data: XOR<ShopPaymentUpdateWithoutEventInput, ShopPaymentUncheckedUpdateWithoutEventInput>
  }

  export type ShopPaymentUpdateManyWithWhereWithoutEventInput = {
    where: ShopPaymentScalarWhereInput
    data: XOR<ShopPaymentUpdateManyMutationInput, ShopPaymentUncheckedUpdateManyWithoutEventInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutEventInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutEventInput, ReviewUncheckedUpdateWithoutEventInput>
    create: XOR<ReviewCreateWithoutEventInput, ReviewUncheckedCreateWithoutEventInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutEventInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutEventInput, ReviewUncheckedUpdateWithoutEventInput>
  }

  export type ReviewUpdateManyWithWhereWithoutEventInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutEventInput>
  }

  export type ItineraryUpsertWithWhereUniqueWithoutEventInput = {
    where: ItineraryWhereUniqueInput
    update: XOR<ItineraryUpdateWithoutEventInput, ItineraryUncheckedUpdateWithoutEventInput>
    create: XOR<ItineraryCreateWithoutEventInput, ItineraryUncheckedCreateWithoutEventInput>
  }

  export type ItineraryUpdateWithWhereUniqueWithoutEventInput = {
    where: ItineraryWhereUniqueInput
    data: XOR<ItineraryUpdateWithoutEventInput, ItineraryUncheckedUpdateWithoutEventInput>
  }

  export type ItineraryUpdateManyWithWhereWithoutEventInput = {
    where: ItineraryScalarWhereInput
    data: XOR<ItineraryUpdateManyMutationInput, ItineraryUncheckedUpdateManyWithoutEventInput>
  }

  export type ItineraryScalarWhereInput = {
    AND?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    OR?: ItineraryScalarWhereInput[]
    NOT?: ItineraryScalarWhereInput | ItineraryScalarWhereInput[]
    itinerary_id?: IntFilter<"Itinerary"> | number
    event_id?: IntFilter<"Itinerary"> | number
    itinerary_name?: StringFilter<"Itinerary"> | string
    itinerary_description?: StringFilter<"Itinerary"> | string
    timestamp?: DateTimeFilter<"Itinerary"> | Date | string
    image_url?: StringFilter<"Itinerary"> | string
  }

  export type FavouriteUpsertWithWhereUniqueWithoutEventInput = {
    where: FavouriteWhereUniqueInput
    update: XOR<FavouriteUpdateWithoutEventInput, FavouriteUncheckedUpdateWithoutEventInput>
    create: XOR<FavouriteCreateWithoutEventInput, FavouriteUncheckedCreateWithoutEventInput>
  }

  export type FavouriteUpdateWithWhereUniqueWithoutEventInput = {
    where: FavouriteWhereUniqueInput
    data: XOR<FavouriteUpdateWithoutEventInput, FavouriteUncheckedUpdateWithoutEventInput>
  }

  export type FavouriteUpdateManyWithWhereWithoutEventInput = {
    where: FavouriteScalarWhereInput
    data: XOR<FavouriteUpdateManyMutationInput, FavouriteUncheckedUpdateManyWithoutEventInput>
  }

  export type Token_TransactionUpsertWithWhereUniqueWithoutEventInput = {
    where: Token_TransactionWhereUniqueInput
    update: XOR<Token_TransactionUpdateWithoutEventInput, Token_TransactionUncheckedUpdateWithoutEventInput>
    create: XOR<Token_TransactionCreateWithoutEventInput, Token_TransactionUncheckedCreateWithoutEventInput>
  }

  export type Token_TransactionUpdateWithWhereUniqueWithoutEventInput = {
    where: Token_TransactionWhereUniqueInput
    data: XOR<Token_TransactionUpdateWithoutEventInput, Token_TransactionUncheckedUpdateWithoutEventInput>
  }

  export type Token_TransactionUpdateManyWithWhereWithoutEventInput = {
    where: Token_TransactionScalarWhereInput
    data: XOR<Token_TransactionUpdateManyMutationInput, Token_TransactionUncheckedUpdateManyWithoutEventInput>
  }

  export type Token_TransactionScalarWhereInput = {
    AND?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
    OR?: Token_TransactionScalarWhereInput[]
    NOT?: Token_TransactionScalarWhereInput | Token_TransactionScalarWhereInput[]
    ID?: IntFilter<"Token_Transaction"> | number
    transaction_type?: StringFilter<"Token_Transaction"> | string
    token?: IntFilter<"Token_Transaction"> | number
    event_ID?: IntFilter<"Token_Transaction"> | number
    transaction_ID?: IntFilter<"Token_Transaction"> | number
    shop_ID?: IntFilter<"Token_Transaction"> | number
  }

  export type AmenitiesUpsertWithWhereUniqueWithoutEventInput = {
    where: AmenitiesWhereUniqueInput
    update: XOR<AmenitiesUpdateWithoutEventInput, AmenitiesUncheckedUpdateWithoutEventInput>
    create: XOR<AmenitiesCreateWithoutEventInput, AmenitiesUncheckedCreateWithoutEventInput>
  }

  export type AmenitiesUpdateWithWhereUniqueWithoutEventInput = {
    where: AmenitiesWhereUniqueInput
    data: XOR<AmenitiesUpdateWithoutEventInput, AmenitiesUncheckedUpdateWithoutEventInput>
  }

  export type AmenitiesUpdateManyWithWhereWithoutEventInput = {
    where: AmenitiesScalarWhereInput
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyWithoutEventInput>
  }

  export type AmenitiesScalarWhereInput = {
    AND?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    OR?: AmenitiesScalarWhereInput[]
    NOT?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    amenity_id?: IntFilter<"Amenities"> | number
    event_id?: IntFilter<"Amenities"> | number
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    latitude?: DateTimeFilter<"Amenities"> | Date | string
    longitude?: StringFilter<"Amenities"> | string
    image_url?: StringFilter<"Amenities"> | string
  }

  export type Emergency_ContactsUpsertWithWhereUniqueWithoutEventInput = {
    where: Emergency_ContactsWhereUniqueInput
    update: XOR<Emergency_ContactsUpdateWithoutEventInput, Emergency_ContactsUncheckedUpdateWithoutEventInput>
    create: XOR<Emergency_ContactsCreateWithoutEventInput, Emergency_ContactsUncheckedCreateWithoutEventInput>
  }

  export type Emergency_ContactsUpdateWithWhereUniqueWithoutEventInput = {
    where: Emergency_ContactsWhereUniqueInput
    data: XOR<Emergency_ContactsUpdateWithoutEventInput, Emergency_ContactsUncheckedUpdateWithoutEventInput>
  }

  export type Emergency_ContactsUpdateManyWithWhereWithoutEventInput = {
    where: Emergency_ContactsScalarWhereInput
    data: XOR<Emergency_ContactsUpdateManyMutationInput, Emergency_ContactsUncheckedUpdateManyWithoutEventInput>
  }

  export type Emergency_ContactsScalarWhereInput = {
    AND?: Emergency_ContactsScalarWhereInput | Emergency_ContactsScalarWhereInput[]
    OR?: Emergency_ContactsScalarWhereInput[]
    NOT?: Emergency_ContactsScalarWhereInput | Emergency_ContactsScalarWhereInput[]
    id?: IntFilter<"Emergency_Contacts"> | number
    event_id?: IntFilter<"Emergency_Contacts"> | number
    contact_name?: StringFilter<"Emergency_Contacts"> | string
    contact_number?: StringFilter<"Emergency_Contacts"> | string
    contact_type?: StringFilter<"Emergency_Contacts"> | string
  }

  export type VenueUpsertWithWhereUniqueWithoutEventInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutEventInput, VenueUncheckedUpdateWithoutEventInput>
    create: XOR<VenueCreateWithoutEventInput, VenueUncheckedCreateWithoutEventInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutEventInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutEventInput, VenueUncheckedUpdateWithoutEventInput>
  }

  export type VenueUpdateManyWithWhereWithoutEventInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutEventInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: IntFilter<"Venue"> | number
    name?: StringFilter<"Venue"> | string
    address?: StringFilter<"Venue"> | string
    latitude?: DateTimeFilter<"Venue"> | Date | string
    longitude?: StringFilter<"Venue"> | string
  }

  export type User_PlanCreateWithoutPlanInput = {
    is_activate: boolean
    user: UserCreateNestedOneWithoutUser_planInput
  }

  export type User_PlanUncheckedCreateWithoutPlanInput = {
    user_id: number
    is_activate: boolean
  }

  export type User_PlanCreateOrConnectWithoutPlanInput = {
    where: User_PlanWhereUniqueInput
    create: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput>
  }

  export type User_PlanCreateManyPlanInputEnvelope = {
    data: User_PlanCreateManyPlanInput | User_PlanCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type User_PlanUpsertWithWhereUniqueWithoutPlanInput = {
    where: User_PlanWhereUniqueInput
    update: XOR<User_PlanUpdateWithoutPlanInput, User_PlanUncheckedUpdateWithoutPlanInput>
    create: XOR<User_PlanCreateWithoutPlanInput, User_PlanUncheckedCreateWithoutPlanInput>
  }

  export type User_PlanUpdateWithWhereUniqueWithoutPlanInput = {
    where: User_PlanWhereUniqueInput
    data: XOR<User_PlanUpdateWithoutPlanInput, User_PlanUncheckedUpdateWithoutPlanInput>
  }

  export type User_PlanUpdateManyWithWhereWithoutPlanInput = {
    where: User_PlanScalarWhereInput
    data: XOR<User_PlanUpdateManyMutationInput, User_PlanUncheckedUpdateManyWithoutPlanInput>
  }

  export type UserCreateWithoutTransactionInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type Token_TransactionCreateWithoutTransactionInput = {
    transaction_type: string
    token: number
    event: EventCreateNestedOneWithoutTokentransactionInput
    shop: ShopsCreateNestedOneWithoutTokentransactionInput
  }

  export type Token_TransactionUncheckedCreateWithoutTransactionInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    shop_ID: number
  }

  export type Token_TransactionCreateOrConnectWithoutTransactionInput = {
    where: Token_TransactionWhereUniqueInput
    create: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput>
  }

  export type Token_TransactionCreateManyTransactionInputEnvelope = {
    data: Token_TransactionCreateManyTransactionInput | Token_TransactionCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Token_TransactionUpsertWithWhereUniqueWithoutTransactionInput = {
    where: Token_TransactionWhereUniqueInput
    update: XOR<Token_TransactionUpdateWithoutTransactionInput, Token_TransactionUncheckedUpdateWithoutTransactionInput>
    create: XOR<Token_TransactionCreateWithoutTransactionInput, Token_TransactionUncheckedCreateWithoutTransactionInput>
  }

  export type Token_TransactionUpdateWithWhereUniqueWithoutTransactionInput = {
    where: Token_TransactionWhereUniqueInput
    data: XOR<Token_TransactionUpdateWithoutTransactionInput, Token_TransactionUncheckedUpdateWithoutTransactionInput>
  }

  export type Token_TransactionUpdateManyWithWhereWithoutTransactionInput = {
    where: Token_TransactionScalarWhereInput
    data: XOR<Token_TransactionUpdateManyMutationInput, Token_TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutUser_planInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_planInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_planInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_planInput, UserUncheckedCreateWithoutUser_planInput>
  }

  export type PlanCreateWithoutUser_planInput = {
    plan_features: string
    payment: number
    plan_name: string
  }

  export type PlanUncheckedCreateWithoutUser_planInput = {
    plan_id?: number
    plan_features: string
    payment: number
    plan_name: string
  }

  export type PlanCreateOrConnectWithoutUser_planInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutUser_planInput, PlanUncheckedCreateWithoutUser_planInput>
  }

  export type UserUpsertWithoutUser_planInput = {
    update: XOR<UserUpdateWithoutUser_planInput, UserUncheckedUpdateWithoutUser_planInput>
    create: XOR<UserCreateWithoutUser_planInput, UserUncheckedCreateWithoutUser_planInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_planInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_planInput, UserUncheckedUpdateWithoutUser_planInput>
  }

  export type UserUpdateWithoutUser_planInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_planInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanUpsertWithoutUser_planInput = {
    update: XOR<PlanUpdateWithoutUser_planInput, PlanUncheckedUpdateWithoutUser_planInput>
    create: XOR<PlanCreateWithoutUser_planInput, PlanUncheckedCreateWithoutUser_planInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutUser_planInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutUser_planInput, PlanUncheckedUpdateWithoutUser_planInput>
  }

  export type PlanUpdateWithoutUser_planInput = {
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
  }

  export type PlanUncheckedUpdateWithoutUser_planInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    plan_features?: StringFieldUpdateOperationsInput | string
    payment?: FloatFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRoleInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    user_id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    contact_number?: StringFilter<"User"> | string
    token?: IntFilter<"User"> | number
    role_id?: IntFilter<"User"> | number
  }

  export type EventCreateWithoutSponsorInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSponsorInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSponsorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSponsorInput, EventUncheckedCreateWithoutSponsorInput>
  }

  export type EventUpsertWithoutSponsorInput = {
    update: XOR<EventUpdateWithoutSponsorInput, EventUncheckedUpdateWithoutSponsorInput>
    create: XOR<EventCreateWithoutSponsorInput, EventUncheckedCreateWithoutSponsorInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutSponsorInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutSponsorInput, EventUncheckedUpdateWithoutSponsorInput>
  }

  export type EventUpdateWithoutSponsorInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSponsorInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutAdvertisementInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutAdvertisementInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutAdvertisementInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAdvertisementInput, EventUncheckedCreateWithoutAdvertisementInput>
  }

  export type EventUpsertWithoutAdvertisementInput = {
    update: XOR<EventUpdateWithoutAdvertisementInput, EventUncheckedUpdateWithoutAdvertisementInput>
    create: XOR<EventCreateWithoutAdvertisementInput, EventUncheckedCreateWithoutAdvertisementInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutAdvertisementInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutAdvertisementInput, EventUncheckedUpdateWithoutAdvertisementInput>
  }

  export type EventUpdateWithoutAdvertisementInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutAdvertisementInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutLostandfoundInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutLostandfoundInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutLostandfoundInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLostandfoundInput, EventUncheckedCreateWithoutLostandfoundInput>
  }

  export type UserCreateWithoutClaim_userInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClaim_userInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClaim_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaim_userInput, UserUncheckedCreateWithoutClaim_userInput>
  }

  export type UserCreateWithoutReporter_userInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReporter_userInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReporter_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReporter_userInput, UserUncheckedCreateWithoutReporter_userInput>
  }

  export type EventUpsertWithoutLostandfoundInput = {
    update: XOR<EventUpdateWithoutLostandfoundInput, EventUncheckedUpdateWithoutLostandfoundInput>
    create: XOR<EventCreateWithoutLostandfoundInput, EventUncheckedCreateWithoutLostandfoundInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutLostandfoundInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutLostandfoundInput, EventUncheckedUpdateWithoutLostandfoundInput>
  }

  export type EventUpdateWithoutLostandfoundInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutLostandfoundInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutClaim_userInput = {
    update: XOR<UserUpdateWithoutClaim_userInput, UserUncheckedUpdateWithoutClaim_userInput>
    create: XOR<UserCreateWithoutClaim_userInput, UserUncheckedCreateWithoutClaim_userInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaim_userInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaim_userInput, UserUncheckedUpdateWithoutClaim_userInput>
  }

  export type UserUpdateWithoutClaim_userInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClaim_userInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReporter_userInput = {
    update: XOR<UserUpdateWithoutReporter_userInput, UserUncheckedUpdateWithoutReporter_userInput>
    create: XOR<UserCreateWithoutReporter_userInput, UserUncheckedCreateWithoutReporter_userInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReporter_userInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReporter_userInput, UserUncheckedUpdateWithoutReporter_userInput>
  }

  export type UserUpdateWithoutReporter_userInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReporter_userInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCreateWithoutEventmapInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventmapInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventmapInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventmapInput, EventUncheckedCreateWithoutEventmapInput>
  }

  export type EventUpsertWithoutEventmapInput = {
    update: XOR<EventUpdateWithoutEventmapInput, EventUncheckedUpdateWithoutEventmapInput>
    create: XOR<EventCreateWithoutEventmapInput, EventUncheckedCreateWithoutEventmapInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventmapInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventmapInput, EventUncheckedUpdateWithoutEventmapInput>
  }

  export type EventUpdateWithoutEventmapInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventmapInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutShopInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutShopInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutShopInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutShopInput, EventUncheckedCreateWithoutShopInput>
  }

  export type ShopPaymentCreateWithoutShopInput = {
    amount: number
    event: EventCreateNestedOneWithoutShoppaymentInput
    User: UserCreateNestedOneWithoutShoppaymentInput
  }

  export type ShopPaymentUncheckedCreateWithoutShopInput = {
    payment_id?: number
    amount: number
    event_id: number
    user_id: number
  }

  export type ShopPaymentCreateOrConnectWithoutShopInput = {
    where: ShopPaymentWhereUniqueInput
    create: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput>
  }

  export type ShopPaymentCreateManyShopInputEnvelope = {
    data: ShopPaymentCreateManyShopInput | ShopPaymentCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type Token_TransactionCreateWithoutShopInput = {
    transaction_type: string
    token: number
    event: EventCreateNestedOneWithoutTokentransactionInput
    transaction: TransactionCreateNestedOneWithoutTokentransactionInput
  }

  export type Token_TransactionUncheckedCreateWithoutShopInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    transaction_ID: number
  }

  export type Token_TransactionCreateOrConnectWithoutShopInput = {
    where: Token_TransactionWhereUniqueInput
    create: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput>
  }

  export type Token_TransactionCreateManyShopInputEnvelope = {
    data: Token_TransactionCreateManyShopInput | Token_TransactionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutShopInput = {
    update: XOR<EventUpdateWithoutShopInput, EventUncheckedUpdateWithoutShopInput>
    create: XOR<EventCreateWithoutShopInput, EventUncheckedCreateWithoutShopInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutShopInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutShopInput, EventUncheckedUpdateWithoutShopInput>
  }

  export type EventUpdateWithoutShopInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutShopInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ShopPaymentUpsertWithWhereUniqueWithoutShopInput = {
    where: ShopPaymentWhereUniqueInput
    update: XOR<ShopPaymentUpdateWithoutShopInput, ShopPaymentUncheckedUpdateWithoutShopInput>
    create: XOR<ShopPaymentCreateWithoutShopInput, ShopPaymentUncheckedCreateWithoutShopInput>
  }

  export type ShopPaymentUpdateWithWhereUniqueWithoutShopInput = {
    where: ShopPaymentWhereUniqueInput
    data: XOR<ShopPaymentUpdateWithoutShopInput, ShopPaymentUncheckedUpdateWithoutShopInput>
  }

  export type ShopPaymentUpdateManyWithWhereWithoutShopInput = {
    where: ShopPaymentScalarWhereInput
    data: XOR<ShopPaymentUpdateManyMutationInput, ShopPaymentUncheckedUpdateManyWithoutShopInput>
  }

  export type Token_TransactionUpsertWithWhereUniqueWithoutShopInput = {
    where: Token_TransactionWhereUniqueInput
    update: XOR<Token_TransactionUpdateWithoutShopInput, Token_TransactionUncheckedUpdateWithoutShopInput>
    create: XOR<Token_TransactionCreateWithoutShopInput, Token_TransactionUncheckedCreateWithoutShopInput>
  }

  export type Token_TransactionUpdateWithWhereUniqueWithoutShopInput = {
    where: Token_TransactionWhereUniqueInput
    data: XOR<Token_TransactionUpdateWithoutShopInput, Token_TransactionUncheckedUpdateWithoutShopInput>
  }

  export type Token_TransactionUpdateManyWithWhereWithoutShopInput = {
    where: Token_TransactionScalarWhereInput
    data: XOR<Token_TransactionUpdateManyMutationInput, Token_TransactionUncheckedUpdateManyWithoutShopInput>
  }

  export type ShopsCreateWithoutShoppaymentInput = {
    shop_name: string
    shop_type: string
    event: EventCreateNestedOneWithoutShopInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutShopInput
  }

  export type ShopsUncheckedCreateWithoutShoppaymentInput = {
    shop_id?: number
    shop_name: string
    event_id: number
    shop_type: string
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopsCreateOrConnectWithoutShoppaymentInput = {
    where: ShopsWhereUniqueInput
    create: XOR<ShopsCreateWithoutShoppaymentInput, ShopsUncheckedCreateWithoutShoppaymentInput>
  }

  export type EventCreateWithoutShoppaymentInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutShoppaymentInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutShoppaymentInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutShoppaymentInput, EventUncheckedCreateWithoutShoppaymentInput>
  }

  export type UserCreateWithoutShoppaymentInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShoppaymentInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShoppaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShoppaymentInput, UserUncheckedCreateWithoutShoppaymentInput>
  }

  export type ShopsUpsertWithoutShoppaymentInput = {
    update: XOR<ShopsUpdateWithoutShoppaymentInput, ShopsUncheckedUpdateWithoutShoppaymentInput>
    create: XOR<ShopsCreateWithoutShoppaymentInput, ShopsUncheckedCreateWithoutShoppaymentInput>
    where?: ShopsWhereInput
  }

  export type ShopsUpdateToOneWithWhereWithoutShoppaymentInput = {
    where?: ShopsWhereInput
    data: XOR<ShopsUpdateWithoutShoppaymentInput, ShopsUncheckedUpdateWithoutShoppaymentInput>
  }

  export type ShopsUpdateWithoutShoppaymentInput = {
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutShopNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutShopNestedInput
  }

  export type ShopsUncheckedUpdateWithoutShoppaymentInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    shop_type?: StringFieldUpdateOperationsInput | string
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type EventUpsertWithoutShoppaymentInput = {
    update: XOR<EventUpdateWithoutShoppaymentInput, EventUncheckedUpdateWithoutShoppaymentInput>
    create: XOR<EventCreateWithoutShoppaymentInput, EventUncheckedCreateWithoutShoppaymentInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutShoppaymentInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutShoppaymentInput, EventUncheckedUpdateWithoutShoppaymentInput>
  }

  export type EventUpdateWithoutShoppaymentInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutShoppaymentInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutShoppaymentInput = {
    update: XOR<UserUpdateWithoutShoppaymentInput, UserUncheckedUpdateWithoutShoppaymentInput>
    create: XOR<UserCreateWithoutShoppaymentInput, UserUncheckedCreateWithoutShoppaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShoppaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShoppaymentInput, UserUncheckedUpdateWithoutShoppaymentInput>
  }

  export type UserUpdateWithoutShoppaymentInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShoppaymentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReviewInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
  }

  export type EventCreateWithoutReviewInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutReviewInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutReviewInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutReviewInput, EventUncheckedCreateWithoutReviewInput>
  }

  export type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateWithoutReviewInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventUpsertWithoutReviewInput = {
    update: XOR<EventUpdateWithoutReviewInput, EventUncheckedUpdateWithoutReviewInput>
    create: XOR<EventCreateWithoutReviewInput, EventUncheckedCreateWithoutReviewInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutReviewInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutReviewInput, EventUncheckedUpdateWithoutReviewInput>
  }

  export type EventUpdateWithoutReviewInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutReviewInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutItineraryInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutItineraryInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutItineraryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutItineraryInput, EventUncheckedCreateWithoutItineraryInput>
  }

  export type FavouriteCreateWithoutItineraryInput = {
    event: EventCreateNestedOneWithoutFavouriteInput
    user: UserCreateNestedOneWithoutFavouriteInput
  }

  export type FavouriteUncheckedCreateWithoutItineraryInput = {
    event_id: number
    user_id: number
  }

  export type FavouriteCreateOrConnectWithoutItineraryInput = {
    where: FavouriteWhereUniqueInput
    create: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput>
  }

  export type FavouriteCreateManyItineraryInputEnvelope = {
    data: FavouriteCreateManyItineraryInput | FavouriteCreateManyItineraryInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutItineraryInput = {
    update: XOR<EventUpdateWithoutItineraryInput, EventUncheckedUpdateWithoutItineraryInput>
    create: XOR<EventCreateWithoutItineraryInput, EventUncheckedCreateWithoutItineraryInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutItineraryInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutItineraryInput, EventUncheckedUpdateWithoutItineraryInput>
  }

  export type EventUpdateWithoutItineraryInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutItineraryInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type FavouriteUpsertWithWhereUniqueWithoutItineraryInput = {
    where: FavouriteWhereUniqueInput
    update: XOR<FavouriteUpdateWithoutItineraryInput, FavouriteUncheckedUpdateWithoutItineraryInput>
    create: XOR<FavouriteCreateWithoutItineraryInput, FavouriteUncheckedCreateWithoutItineraryInput>
  }

  export type FavouriteUpdateWithWhereUniqueWithoutItineraryInput = {
    where: FavouriteWhereUniqueInput
    data: XOR<FavouriteUpdateWithoutItineraryInput, FavouriteUncheckedUpdateWithoutItineraryInput>
  }

  export type FavouriteUpdateManyWithWhereWithoutItineraryInput = {
    where: FavouriteScalarWhereInput
    data: XOR<FavouriteUpdateManyMutationInput, FavouriteUncheckedUpdateManyWithoutItineraryInput>
  }

  export type EventCreateWithoutFavouriteInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutFavouriteInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutFavouriteInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutFavouriteInput, EventUncheckedCreateWithoutFavouriteInput>
  }

  export type ItineraryCreateWithoutFavouriteInput = {
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
    event: EventCreateNestedOneWithoutItineraryInput
  }

  export type ItineraryUncheckedCreateWithoutFavouriteInput = {
    itinerary_id?: number
    event_id: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
  }

  export type ItineraryCreateOrConnectWithoutFavouriteInput = {
    where: ItineraryWhereUniqueInput
    create: XOR<ItineraryCreateWithoutFavouriteInput, ItineraryUncheckedCreateWithoutFavouriteInput>
  }

  export type UserCreateWithoutFavouriteInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    notification?: NotificationCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavouriteInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavouriteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavouriteInput, UserUncheckedCreateWithoutFavouriteInput>
  }

  export type EventUpsertWithoutFavouriteInput = {
    update: XOR<EventUpdateWithoutFavouriteInput, EventUncheckedUpdateWithoutFavouriteInput>
    create: XOR<EventCreateWithoutFavouriteInput, EventUncheckedCreateWithoutFavouriteInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutFavouriteInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutFavouriteInput, EventUncheckedUpdateWithoutFavouriteInput>
  }

  export type EventUpdateWithoutFavouriteInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutFavouriteInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ItineraryUpsertWithoutFavouriteInput = {
    update: XOR<ItineraryUpdateWithoutFavouriteInput, ItineraryUncheckedUpdateWithoutFavouriteInput>
    create: XOR<ItineraryCreateWithoutFavouriteInput, ItineraryUncheckedCreateWithoutFavouriteInput>
    where?: ItineraryWhereInput
  }

  export type ItineraryUpdateToOneWithWhereWithoutFavouriteInput = {
    where?: ItineraryWhereInput
    data: XOR<ItineraryUpdateWithoutFavouriteInput, ItineraryUncheckedUpdateWithoutFavouriteInput>
  }

  export type ItineraryUpdateWithoutFavouriteInput = {
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutFavouriteInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutFavouriteInput = {
    update: XOR<UserUpdateWithoutFavouriteInput, UserUncheckedUpdateWithoutFavouriteInput>
    create: XOR<UserCreateWithoutFavouriteInput, UserUncheckedCreateWithoutFavouriteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavouriteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavouriteInput, UserUncheckedUpdateWithoutFavouriteInput>
  }

  export type UserUpdateWithoutFavouriteInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavouriteInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCreateWithoutTokentransactionInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTokentransactionInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTokentransactionInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTokentransactionInput, EventUncheckedCreateWithoutTokentransactionInput>
  }

  export type TransactionCreateWithoutTokentransactionInput = {
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
    User: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutTokentransactionInput = {
    id?: number
    user_id: number
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
  }

  export type TransactionCreateOrConnectWithoutTokentransactionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTokentransactionInput, TransactionUncheckedCreateWithoutTokentransactionInput>
  }

  export type ShopsCreateWithoutTokentransactionInput = {
    shop_name: string
    shop_type: string
    event: EventCreateNestedOneWithoutShopInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutShopInput
  }

  export type ShopsUncheckedCreateWithoutTokentransactionInput = {
    shop_id?: number
    shop_name: string
    event_id: number
    shop_type: string
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopsCreateOrConnectWithoutTokentransactionInput = {
    where: ShopsWhereUniqueInput
    create: XOR<ShopsCreateWithoutTokentransactionInput, ShopsUncheckedCreateWithoutTokentransactionInput>
  }

  export type EventUpsertWithoutTokentransactionInput = {
    update: XOR<EventUpdateWithoutTokentransactionInput, EventUncheckedUpdateWithoutTokentransactionInput>
    create: XOR<EventCreateWithoutTokentransactionInput, EventUncheckedCreateWithoutTokentransactionInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTokentransactionInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTokentransactionInput, EventUncheckedUpdateWithoutTokentransactionInput>
  }

  export type EventUpdateWithoutTokentransactionInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTokentransactionInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type TransactionUpsertWithoutTokentransactionInput = {
    update: XOR<TransactionUpdateWithoutTokentransactionInput, TransactionUncheckedUpdateWithoutTokentransactionInput>
    create: XOR<TransactionCreateWithoutTokentransactionInput, TransactionUncheckedCreateWithoutTokentransactionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutTokentransactionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutTokentransactionInput, TransactionUncheckedUpdateWithoutTokentransactionInput>
  }

  export type TransactionUpdateWithoutTokentransactionInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTokentransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
  }

  export type ShopsUpsertWithoutTokentransactionInput = {
    update: XOR<ShopsUpdateWithoutTokentransactionInput, ShopsUncheckedUpdateWithoutTokentransactionInput>
    create: XOR<ShopsCreateWithoutTokentransactionInput, ShopsUncheckedCreateWithoutTokentransactionInput>
    where?: ShopsWhereInput
  }

  export type ShopsUpdateToOneWithWhereWithoutTokentransactionInput = {
    where?: ShopsWhereInput
    data: XOR<ShopsUpdateWithoutTokentransactionInput, ShopsUncheckedUpdateWithoutTokentransactionInput>
  }

  export type ShopsUpdateWithoutTokentransactionInput = {
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutShopNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutShopNestedInput
  }

  export type ShopsUncheckedUpdateWithoutTokentransactionInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    event_id?: IntFieldUpdateOperationsInput | number
    shop_type?: StringFieldUpdateOperationsInput | string
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role: RoleCreateNestedOneWithoutUserInput
    User_plan?: User_PlanCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
    event?: EventCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutUserInput
    review?: ReviewCreateNestedManyWithoutUserInput
    favourite?: FavouriteCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
    role_id: number
    User_plan?: User_PlanUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    event?: EventUncheckedCreateNestedManyWithoutCreatorInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutUserInput
    review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutUserInput
    claim_user?: LostAndFoundUncheckedCreateNestedManyWithoutClaim_userInput
    reporter_user?: LostAndFoundUncheckedCreateNestedManyWithoutReporter_userInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneRequiredWithoutUserNestedInput
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCreateWithoutAmenitiesInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutAmenitiesInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutAmenitiesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAmenitiesInput, EventUncheckedCreateWithoutAmenitiesInput>
  }

  export type EventUpsertWithoutAmenitiesInput = {
    update: XOR<EventUpdateWithoutAmenitiesInput, EventUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<EventCreateWithoutAmenitiesInput, EventUncheckedCreateWithoutAmenitiesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutAmenitiesInput, EventUncheckedUpdateWithoutAmenitiesInput>
  }

  export type EventUpdateWithoutAmenitiesInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutAmenitiesInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutVenueInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutVenueInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    emergency_contacts?: Emergency_ContactsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutVenueInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventUpsertWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventUpdateWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
  }

  export type EventUpdateManyWithWhereWithoutVenueInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutVenueInput>
  }

  export type EventCreateWithoutEmergency_contactsInput = {
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    creator: UserCreateNestedOneWithoutEventInput
    lostandfound?: LostAndFoundCreateNestedManyWithoutEventInput
    sponsor?: SponsorCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementCreateNestedManyWithoutEventInput
    eventmap?: EventMapCreateNestedManyWithoutEventInput
    shop?: ShopsCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentCreateNestedManyWithoutEventInput
    review?: ReviewCreateNestedManyWithoutEventInput
    itinerary?: ItineraryCreateNestedManyWithoutEventInput
    favourite?: FavouriteCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionCreateNestedManyWithoutEventInput
    amenities?: AmenitiesCreateNestedManyWithoutEventInput
    venue?: VenueCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEmergency_contactsInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    creator_id: number
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
    lostandfound?: LostAndFoundUncheckedCreateNestedManyWithoutEventInput
    sponsor?: SponsorUncheckedCreateNestedManyWithoutEventInput
    advertisement?: AdvertisementUncheckedCreateNestedManyWithoutEventInput
    eventmap?: EventMapUncheckedCreateNestedManyWithoutEventInput
    shop?: ShopsUncheckedCreateNestedManyWithoutEventInput
    shoppayment?: ShopPaymentUncheckedCreateNestedManyWithoutEventInput
    review?: ReviewUncheckedCreateNestedManyWithoutEventInput
    itinerary?: ItineraryUncheckedCreateNestedManyWithoutEventInput
    favourite?: FavouriteUncheckedCreateNestedManyWithoutEventInput
    tokentransaction?: Token_TransactionUncheckedCreateNestedManyWithoutEventInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutEventInput
    venue?: VenueUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEmergency_contactsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEmergency_contactsInput, EventUncheckedCreateWithoutEmergency_contactsInput>
  }

  export type EventUpsertWithoutEmergency_contactsInput = {
    update: XOR<EventUpdateWithoutEmergency_contactsInput, EventUncheckedUpdateWithoutEmergency_contactsInput>
    create: XOR<EventCreateWithoutEmergency_contactsInput, EventUncheckedCreateWithoutEmergency_contactsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEmergency_contactsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEmergency_contactsInput, EventUncheckedUpdateWithoutEmergency_contactsInput>
  }

  export type EventUpdateWithoutEmergency_contactsInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEmergency_contactsInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type User_PlanCreateManyUserInput = {
    plan_id: number
    is_activate: boolean
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    plan_id: number
    amount: Decimal | DecimalJsLike | number | string
    GST: Decimal | DecimalJsLike | number | string
    transaction_id: string
    transaction_type: string
  }

  export type EventCreateManyCreatorInput = {
    event_id?: number
    event_name: string
    event_description: string
    location: string
    start_date: Date | string
    end_date: Date | string
    event_tags: string
    approval?: boolean
    status: string
    entry_fee: number
    thumbnail_link: string
    banner_link: Date | string
    video_link: Date | string
    venue_id: number
  }

  export type ShopPaymentCreateManyUserInput = {
    payment_id?: number
    amount: number
    shop_id: number
    event_id: number
  }

  export type ReviewCreateManyUserInput = {
    review_id?: number
    review_title: string
    review_desc: string
    rating: number
    timestamp: Date | string
    event_id: number
  }

  export type FavouriteCreateManyUserInput = {
    event_id: number
    itinerary_id: number
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    body: string
    type: string
    timestamp: Date | string
    event_id: number
  }

  export type LostAndFoundCreateManyClaim_userInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type LostAndFoundCreateManyReporter_userInput = {
    lost_and_found_id?: number
    event_id: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type User_PlanUpdateWithoutUserInput = {
    is_activate?: BoolFieldUpdateOperationsInput | boolean
    plan?: PlanUpdateOneRequiredWithoutUser_planNestedInput
  }

  export type User_PlanUncheckedUpdateWithoutUserInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_PlanUncheckedUpdateManyWithoutUserInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionUpdateWithoutUserInput = {
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
    tokentransaction?: Token_TransactionUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    GST?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction_id?: StringFieldUpdateOperationsInput | string
    transaction_type?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpdateWithoutCreatorInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
    venue?: VenueUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatorInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
    venue?: VenueUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatorInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    shop?: ShopsUpdateOneRequiredWithoutShoppaymentNestedInput
    event?: EventUpdateOneRequiredWithoutShoppaymentNestedInput
  }

  export type ShopPaymentUncheckedUpdateWithoutUserInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentUncheckedUpdateManyWithoutUserInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutUserInput = {
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteUpdateWithoutUserInput = {
    event?: EventUpdateOneRequiredWithoutFavouriteNestedInput
    itinerary?: ItineraryUpdateOneRequiredWithoutFavouriteNestedInput
  }

  export type FavouriteUncheckedUpdateWithoutUserInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_id?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteUncheckedUpdateManyWithoutUserInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    itinerary_id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_id?: IntFieldUpdateOperationsInput | number
  }

  export type LostAndFoundUpdateWithoutClaim_userInput = {
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutLostandfoundNestedInput
    reporter_user?: UserUpdateOneRequiredWithoutReporter_userNestedInput
  }

  export type LostAndFoundUncheckedUpdateWithoutClaim_userInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LostAndFoundUncheckedUpdateManyWithoutClaim_userInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LostAndFoundUpdateWithoutReporter_userInput = {
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutLostandfoundNestedInput
    claim_user?: UserUpdateOneRequiredWithoutClaim_userNestedInput
  }

  export type LostAndFoundUncheckedUpdateWithoutReporter_userInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LostAndFoundUncheckedUpdateManyWithoutReporter_userInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LostAndFoundCreateManyEventInput = {
    lost_and_found_id?: number
    item_name: string
    description: string
    is_claimed: boolean
    claim_user_id: number
    reporting_timestamp: Date | string
    claim_timestamp: Date | string
    reporter_user_id: number
  }

  export type SponsorCreateManyEventInput = {
    sponsor_id?: number
    title: string
    description: string
    image_url: string
    start_time: string
    end_time: string
    venue_id: number
  }

  export type AdvertisementCreateManyEventInput = {
    advertisement_id?: number
    title: string
    level: string
    start_date: Date | string
    end_date: Date | string
    image_url: string
  }

  export type EventMapCreateManyEventInput = {
    event_map_id?: number
    map_object: string
  }

  export type ShopsCreateManyEventInput = {
    shop_id?: number
    shop_name: string
    shop_type: string
  }

  export type ShopPaymentCreateManyEventInput = {
    payment_id?: number
    amount: number
    shop_id: number
    user_id: number
  }

  export type ReviewCreateManyEventInput = {
    review_id?: number
    review_title: string
    review_desc: string
    user_id: number
    rating: number
    timestamp: Date | string
  }

  export type ItineraryCreateManyEventInput = {
    itinerary_id?: number
    itinerary_name: string
    itinerary_description: string
    timestamp: Date | string
    image_url: string
  }

  export type FavouriteCreateManyEventInput = {
    itinerary_id: number
    user_id: number
  }

  export type Token_TransactionCreateManyEventInput = {
    ID?: number
    transaction_type: string
    token: number
    transaction_ID: number
    shop_ID: number
  }

  export type AmenitiesCreateManyEventInput = {
    amenity_id?: number
    name: string
    description: string
    latitude: Date | string
    longitude: string
    image_url: string
  }

  export type Emergency_ContactsCreateManyEventInput = {
    id?: number
    contact_name: string
    contact_number: string
    contact_type: string
  }

  export type LostAndFoundUpdateWithoutEventInput = {
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_user?: UserUpdateOneRequiredWithoutClaim_userNestedInput
    reporter_user?: UserUpdateOneRequiredWithoutReporter_userNestedInput
  }

  export type LostAndFoundUncheckedUpdateWithoutEventInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LostAndFoundUncheckedUpdateManyWithoutEventInput = {
    lost_and_found_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_claimed?: BoolFieldUpdateOperationsInput | boolean
    claim_user_id?: IntFieldUpdateOperationsInput | number
    reporting_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type SponsorUpdateWithoutEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type SponsorUncheckedUpdateWithoutEventInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type SponsorUncheckedUpdateManyWithoutEventInput = {
    sponsor_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }

  export type AdvertisementUpdateWithoutEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AdvertisementUncheckedUpdateWithoutEventInput = {
    advertisement_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AdvertisementUncheckedUpdateManyWithoutEventInput = {
    advertisement_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type EventMapUpdateWithoutEventInput = {
    map_object?: StringFieldUpdateOperationsInput | string
  }

  export type EventMapUncheckedUpdateWithoutEventInput = {
    event_map_id?: IntFieldUpdateOperationsInput | number
    map_object?: StringFieldUpdateOperationsInput | string
  }

  export type EventMapUncheckedUpdateManyWithoutEventInput = {
    event_map_id?: IntFieldUpdateOperationsInput | number
    map_object?: StringFieldUpdateOperationsInput | string
  }

  export type ShopsUpdateWithoutEventInput = {
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
    shoppayment?: ShopPaymentUpdateManyWithoutShopNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutShopNestedInput
  }

  export type ShopsUncheckedUpdateWithoutEventInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutShopNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopsUncheckedUpdateManyWithoutEventInput = {
    shop_id?: IntFieldUpdateOperationsInput | number
    shop_name?: StringFieldUpdateOperationsInput | string
    shop_type?: StringFieldUpdateOperationsInput | string
  }

  export type ShopPaymentUpdateWithoutEventInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    shop?: ShopsUpdateOneRequiredWithoutShoppaymentNestedInput
    User?: UserUpdateOneRequiredWithoutShoppaymentNestedInput
  }

  export type ShopPaymentUncheckedUpdateWithoutEventInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentUncheckedUpdateManyWithoutEventInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    shop_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutEventInput = {
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutEventInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutEventInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    review_title?: StringFieldUpdateOperationsInput | string
    review_desc?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItineraryUpdateWithoutEventInput = {
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    favourite?: FavouriteUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateWithoutEventInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
    favourite?: FavouriteUncheckedUpdateManyWithoutItineraryNestedInput
  }

  export type ItineraryUncheckedUpdateManyWithoutEventInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    itinerary_name?: StringFieldUpdateOperationsInput | string
    itinerary_description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type FavouriteUpdateWithoutEventInput = {
    itinerary?: ItineraryUpdateOneRequiredWithoutFavouriteNestedInput
    user?: UserUpdateOneRequiredWithoutFavouriteNestedInput
  }

  export type FavouriteUncheckedUpdateWithoutEventInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteUncheckedUpdateManyWithoutEventInput = {
    itinerary_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUpdateWithoutEventInput = {
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    transaction?: TransactionUpdateOneRequiredWithoutTokentransactionNestedInput
    shop?: ShopsUpdateOneRequiredWithoutTokentransactionNestedInput
  }

  export type Token_TransactionUncheckedUpdateWithoutEventInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUncheckedUpdateManyWithoutEventInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type AmenitiesUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AmenitiesUncheckedUpdateWithoutEventInput = {
    amenity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type AmenitiesUncheckedUpdateManyWithoutEventInput = {
    amenity_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsUpdateWithoutEventInput = {
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type Emergency_ContactsUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    contact_type?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: DateTimeFieldUpdateOperationsInput | Date | string
    longitude?: StringFieldUpdateOperationsInput | string
  }

  export type User_PlanCreateManyPlanInput = {
    user_id: number
    is_activate: boolean
  }

  export type User_PlanUpdateWithoutPlanInput = {
    is_activate?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUser_planNestedInput
  }

  export type User_PlanUncheckedUpdateWithoutPlanInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_PlanUncheckedUpdateManyWithoutPlanInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    is_activate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Token_TransactionCreateManyTransactionInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    shop_ID: number
  }

  export type Token_TransactionUpdateWithoutTransactionInput = {
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event?: EventUpdateOneRequiredWithoutTokentransactionNestedInput
    shop?: ShopsUpdateOneRequiredWithoutTokentransactionNestedInput
  }

  export type Token_TransactionUncheckedUpdateWithoutTransactionInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUncheckedUpdateManyWithoutTransactionInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    shop_ID?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyRoleInput = {
    user_id?: number
    full_name: string
    email: string
    password: string
    contact_number: string
    token?: number
  }

  export type UserUpdateWithoutRoleInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
    event?: EventUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutUserNestedInput
    review?: ReviewUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUpdateManyWithoutUserNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    User_plan?: User_PlanUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    event?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutUserNestedInput
    review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutUserNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    claim_user?: LostAndFoundUncheckedUpdateManyWithoutClaim_userNestedInput
    reporter_user?: LostAndFoundUncheckedUpdateManyWithoutReporter_userNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentCreateManyShopInput = {
    payment_id?: number
    amount: number
    event_id: number
    user_id: number
  }

  export type Token_TransactionCreateManyShopInput = {
    ID?: number
    transaction_type: string
    token: number
    event_ID: number
    transaction_ID: number
  }

  export type ShopPaymentUpdateWithoutShopInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    event?: EventUpdateOneRequiredWithoutShoppaymentNestedInput
    User?: UserUpdateOneRequiredWithoutShoppaymentNestedInput
  }

  export type ShopPaymentUncheckedUpdateWithoutShopInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type ShopPaymentUncheckedUpdateManyWithoutShopInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUpdateWithoutShopInput = {
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event?: EventUpdateOneRequiredWithoutTokentransactionNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutTokentransactionNestedInput
  }

  export type Token_TransactionUncheckedUpdateWithoutShopInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
  }

  export type Token_TransactionUncheckedUpdateManyWithoutShopInput = {
    ID?: IntFieldUpdateOperationsInput | number
    transaction_type?: StringFieldUpdateOperationsInput | string
    token?: IntFieldUpdateOperationsInput | number
    event_ID?: IntFieldUpdateOperationsInput | number
    transaction_ID?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteCreateManyItineraryInput = {
    event_id: number
    user_id: number
  }

  export type FavouriteUpdateWithoutItineraryInput = {
    event?: EventUpdateOneRequiredWithoutFavouriteNestedInput
    user?: UserUpdateOneRequiredWithoutFavouriteNestedInput
  }

  export type FavouriteUncheckedUpdateWithoutItineraryInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type FavouriteUncheckedUpdateManyWithoutItineraryInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type EventUpdateWithoutVenueInput = {
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    creator?: UserUpdateOneRequiredWithoutEventNestedInput
    lostandfound?: LostAndFoundUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUpdateManyWithoutEventNestedInput
    shop?: ShopsUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUpdateManyWithoutEventNestedInput
    review?: ReviewUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutVenueInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
    lostandfound?: LostAndFoundUncheckedUpdateManyWithoutEventNestedInput
    sponsor?: SponsorUncheckedUpdateManyWithoutEventNestedInput
    advertisement?: AdvertisementUncheckedUpdateManyWithoutEventNestedInput
    eventmap?: EventMapUncheckedUpdateManyWithoutEventNestedInput
    shop?: ShopsUncheckedUpdateManyWithoutEventNestedInput
    shoppayment?: ShopPaymentUncheckedUpdateManyWithoutEventNestedInput
    review?: ReviewUncheckedUpdateManyWithoutEventNestedInput
    itinerary?: ItineraryUncheckedUpdateManyWithoutEventNestedInput
    favourite?: FavouriteUncheckedUpdateManyWithoutEventNestedInput
    tokentransaction?: Token_TransactionUncheckedUpdateManyWithoutEventNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutEventNestedInput
    emergency_contacts?: Emergency_ContactsUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutVenueInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_tags?: StringFieldUpdateOperationsInput | string
    creator_id?: IntFieldUpdateOperationsInput | number
    approval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    entry_fee?: FloatFieldUpdateOperationsInput | number
    thumbnail_link?: StringFieldUpdateOperationsInput | string
    banner_link?: DateTimeFieldUpdateOperationsInput | Date | string
    video_link?: DateTimeFieldUpdateOperationsInput | Date | string
    venue_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionCountOutputTypeDefaultArgs instead
     */
    export type TransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopsCountOutputTypeDefaultArgs instead
     */
    export type ShopsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryCountOutputTypeDefaultArgs instead
     */
    export type ItineraryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueCountOutputTypeDefaultArgs instead
     */
    export type VenueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use User_PlanDefaultArgs instead
     */
    export type User_PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = User_PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SponsorDefaultArgs instead
     */
    export type SponsorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SponsorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisementDefaultArgs instead
     */
    export type AdvertisementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvertisementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LostAndFoundDefaultArgs instead
     */
    export type LostAndFoundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LostAndFoundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventMapDefaultArgs instead
     */
    export type EventMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventMapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopsDefaultArgs instead
     */
    export type ShopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopPaymentDefaultArgs instead
     */
    export type ShopPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItineraryDefaultArgs instead
     */
    export type ItineraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItineraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavouriteDefaultArgs instead
     */
    export type FavouriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavouriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Token_TransactionDefaultArgs instead
     */
    export type Token_TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Token_TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AmenitiesDefaultArgs instead
     */
    export type AmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AmenitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueDefaultArgs instead
     */
    export type VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Emergency_ContactsDefaultArgs instead
     */
    export type Emergency_ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Emergency_ContactsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}